---
title: "Y-Fast Trieを編む [UEC Advent Calendar 2024] 12日目"
# description: 

date: 2024-12-12
# lastmod: yyyy-mm-dd
# hidedate: true

# ogimage: https://hoge/fuga/piyo.img

tags:
  - アルゴリズム
  - データ構造
  - UEC Advent Calendar
archives:
  - 2024
  - 2024-12
# sample
# - yyyy
# - yyyy-mm

draft: true
math: true
# toc: false
# build: {list: never}
---

## まえがき
こんにちは、[InTheBloom](https://x.com/UU9782wsEdANDhp)です。
今年もUECアドカレの季節がやってきましたね。Twitterでカレンダーが生えたのを観測したので、これ幸いと枠をいただきました。これで3年目になります。

このエントリはUEC Advent Calendar 2024の12日目を担当します。

<iframe src="https://adventar.org/calendars/10127/embed" width="620" height="362" frameborder="0" loading="lazy"></iframe>

また、今年もUEC2が建っています。

<iframe src="https://adventar.org/calendars/10198/embed" width="620" height="362" frameborder="0" loading="lazy"></iframe>

11日目はえぐちさんの～～～～～～～～～～とはんかくさんの～～～～～でした。

[感想を書く]

今年も力作ぞろいです。これからのエントリも楽しみですね！

## はじめに
このエントリでは、Y-Fast Trie(ワイ-ファスト トライ)と呼ばれるデータ構造の動作原理を説明し、実際に組んだものを示します。
Y-Fast Trieの美しさ、ロマンを体感してください！

誤りの指摘は随時募集しています。指摘いただいたものは随時修正していきますので、お気軽にどうぞ。

## データ構造とは
Y-Fast Trieは**データ構造**です。まず、データ構造とは何なのかを再考しましょう。

データ構造とは何かについて厳密に定義を与えるのは難しいですが、大まかに、いくつかの抽象化された操作を行うブラックボックスのようなものです。
pythonの`set`([リファレンス](https://docs.python.org/ja/3/library/stdtypes.html#set))を例に考えてみましょう。私たちは、setが内部で何を行っているかを知ることなく、

- setに値を追加する
- setにある値が存在するか確認する
- setにいくつ値が存在するか確認する

などの操作を行うことができます。上記のような、あるデータ構造が行うことができる操作の集合を**インターフェース**と呼ぶことにします。

インターフェースは外から見たときのふるまいを定義します。たとえば、`set`のインターフェースを`list`を用いて実装することも可能です。

しかし、読者の大半が`list`で構築された`set`インターフェースは使い物にならないことを知っていると思います。値の存在確認や削除に圧倒的に時間がかかるからです。

このように、データ構造を考えるうえでは、インターフェースのみではなく、

- 各操作にどれだけ時間がかかるのか
- データ構造はどれくらいのメモリを必要とするのか

を含めて議論するべきでしょう。
これらを踏まえて、Y-Fast Trieの性能を見ていきます。

## Y-Fast Trie
Y-Fast Trieは非負整数の集合を扱うことができます。
具体的には、扱う整数の範囲を$\lbrack 0, 2 ^ w - 1 \rbrack$としたとき、以下のクエリをサポートします。

| 操作                      | 内容                                | 時間計算量                    |
| ------------------------- | ----------------------------------- | ----------------------------- |
| $\mathrm{insert}(x)$      | 集合に$x$を追加する                 | $\text{expected } O(\log(w))$ |
| $\mathrm{remove}(x)$      | 集合から$x$を削除する               | $\text{expected } O(\log(w))$ |
| $\mathrm{successor}(x)$   | 集合に含まれる$x$以上最小の値を返す | $\text{expected } O(\log(w))$ |
| $\mathrm{predecessor}(x)$ | 集合に含まれる$x$以下最大の値を返す | $\text{expected } O(\log(w))$ |

また、操作$N$回を行うとき、空間計算量は$O(N)$になります。

計算量というのは、かかる時間や必要な領域を定量的に評価するための概念です。
詳細は[計算量について(外部リンク)](https://noshi91.hatenablog.com/entry/2019/10/08/235335)を参照してください。

$\text{expected}$はその操作にかかる時間が確率変数で表現されることを表します。値はその期待値です。
空間計算量が$O(N)$であるとは、格納した値や補助のデータを含めて$O(N)$byteしか必要としないことを表します。

このインターフェースを二分探索木により実装した場合、各操作は$O(\log(N))$時間になります。
一方、Y-Fast Trieは$O(\log(w))$時間です。

$w$は整数を表現するのに必要なビット数であり、自然な仮定の元ではY-Fast Trieは二分探索木よりも理論的に高速です。
(ほとんどの環境で、`long long int`などの型を用いたときに$w = 64$になるはずです。)
扱う値を非負整数に絞ることにより、二分探索木よりも高速な動作を実現することができます。

前置きはここまでです。次の章からはY-Fast Trieの動作原理を見ていきましょう。

## Binary Trieによるsuccessor query
Y-Fast Trieの仕組みを理解するためには、trie木を知る必要があります。
trieは**グラフ**の一種です。グラフとは、頂点集合$V$と頂点間を結ぶ辺集合$E$の組のことで、ものとものの**つながりかた**だけを抜き出した数学モデルです。

![graph\_sample.png](/images/uec-advent2024/graph_sample.png)

これがグラフです。この場合、頂点数が6で、辺数が8です。[Graph Editor](https://csacademy.com/app/graph_editor/)でビジュアライザを試すことができます。

trieは、文字列の集合を表現するグラフです。
常に次のルールに従っています。

- 根と呼ばれる「スタート地点」をもつ。
- 各辺には文字が割り当てられる。
- 根は空文字列を表現する。他の頂点は、根からそこまでたどったときに通った辺の文字を連結した文字列を表現する。

![trie木](/images/uec-advent2024/trie_wiki.png)

wikipediaの[トライ](https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%A9%E3%82%A4_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0))からパブリックドメインの画像をお借りしました。
これがtrie木です。"A", "to", "tea", "ted", "ten", "i", "in", "inn"から構築されています。

trieに文字列を追加/削除することもできます。

追加するときは、根から出来るだけ既存の頂点を経由して文字を伸ばしていけばよいです。
削除するときは、その文字列を表現する頂点からはじめて、他の文字列に影響しない部分の頂点を削除しながら根までのぼっていけばよいです。

### Binary Trie
進数表記された数字を文字列として扱うことができます。
つまり、1234を"1234"、432795を"432795"としてみなすということです。
これにより、trieで数字を扱うことができるようになります。

trieの辺に乗せられる文字を"0"と"1"に限定することにします。
すると、各ノードは0と1の連結を表現します。
こうすることで、任意の数を
