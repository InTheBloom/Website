<!DOCTYPE html>
<html lang="ja">
<head>





<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>サイト内全文検索 - InTheDayDream</title>
<meta name="description" content="">

<meta name="author" content="">

<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
<link rel="alternate" href="/index.xml?c=ded62938f2b9b67414820e7a3375078eca8f58d1" type="application/rss+xml" title="RSS" />
<meta property="og:title" content="サイト内全文検索 - InTheDayDream">
</meta>
<meta property="og:url" content="http://inthebloom.github.io/search/">
<meta property="og:type" content="article">
<meta property="og:site_name" content="InTheDayDream">
<meta property="og:description" content="">

<meta property="og:image" content="http://inthebloom.github.io//images/featured_image.jpg">

<meta name="twitter:card" content="summary_large_image" /></meta>
<meta name="twitter:site" content="@UU9782wsEdANDhp"></meta>
<meta name="twitter:creator" content="@UU9782wsEdANDhp"></meta>
<meta name="twitter:title" content="サイト内全文検索 - InTheDayDream"></meta>
<meta name="twitter:url" content="http://inthebloom.github.io/search/"></meta>
<meta name="twitter:description" content=""></meta>

<meta property="og:image" content="http://inthebloom.github.io//images/featured_image.jpg">


<link rel="stylesheet" href="/css/main.css?c=ded62938f2b9b67414820e7a3375078eca8f58d1">
<link rel="stylesheet" href="/css/color.css?c=ded62938f2b9b67414820e7a3375078eca8f58d1">


<link rel="stylesheet" href="/css/custom.css?c=ded62938f2b9b67414820e7a3375078eca8f58d1">



</head>

<body class="theme-default">






<div id="content-header" class="title">
  
  <a class="site-title" href="/">InTheDayDream</a>
  
  <span class="site-sub-title"></span>

  

  <div id="main-menu-nav">
    <div id="main-menu-nav-items">
      
        <div class="nav-item"><a href="/">Home</a></div>
      
        <div class="nav-item"><a href="/tags/">Tags</a></div>
      
        <div class="nav-item"><a href="/archives/">Archives</a></div>
      
        <div class="nav-item"><a href="/about/">About</a></div>
      
        <div class="nav-item"><a href="/search/">Search</a></div>
      
    </div>
  </div>
</div>
<div id="content" class="main">




<h1>サイト内全文検索</h1>








<p>サイト内の文章からインクリメント検索が可能です。
下の入力欄に入力することで検索ができます。</p>
<p>本ページは検索の対象外になっています。</p>

<head>
  <meta charset="UTF-8">
  <style>
    body {
      background: #fafafa;
    }
    input {
      color: deeppink;
      font-size: 1.2em;
      font-weight: bolder;
    }
    input::-webkit-input-placeholder {
      color: pink;
    }
    #result {
      margin: 1em;
    }
    .item_title {
      text-decoration: none;
      color: #36f;
      font-weight: bolder;
    }
    .item_excerpt {
      background: white;
      margin: 0.5em 2em 1em;
      padding: 0.5em;
      border: dashed 1px lightgray;
      font-size: smaller;
    }
    .item_excerpt b {
      background: pink;
    }
  </style>
</head>
<body>

<input onkeyup="search(this.value)" size="15" autocomplete="off" autofocus placeholder="検索ワード" />
<span id="inputWord"></span> <span id="resultCount"></span>
<div id="result"></div>

<script>

const data = [
  {
    url: "/post/abc328/",
    title: "ABC328参加記録",
    date: "2023-11-12T00:00:00Z",
    body: "ABC328参加記録 はじめに 本稿は、2023-11-11に行われたABC328の参加記録です。 戦績 今回の提出は以下の通りでした。 AからEの5問正解できました。 今回のレーティング変動は以下の通りでした。 パフォーマンスは1281で、 レーティング変動は1241→1245(+4) でした。 所感 今回はDまでかなり早く解ましたがE問題で詰まってしまい、パフォーマンスがあまり伸びませんでした。 解けないとマズいという問題は解けたので、とりあえず良しとします。 今回のF問題がPotentialized UnionFindというものを利用すれば簡単に解けたらしく、 自分が解法にたどり着けなかったという点と、ちゃんと前もって学習できていなかったということに対してかなり悔しく感じてします。 今週のプロコンは、このデータ構造を理解してD言語による実装を与えることを目標にやろうかなと思います。 学ぶ機会をもらったと思って頑張ります。 問題振り返り A - Not Too Hard 問題へのリンク 最近のA問題の中でも結構簡単な方な気がします。配点をひとつづつ見ていって、X以下なら足しましょう。 import std; void main () { int N, X; readln.read(N, X); int[] S = readln.split.to!(int[]); int ans = 0; foreach (s; S) if (s \u0026lt;= X) ans += s; writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - 11/11 問題へのリンク 実装を考えるとき、有効な月/日を生成することと、ゾロ目になることを分けて考えるとやりやすいのかなと思います。 型変換(int -\u0026gt; string)を簡単にできる言語なら、次のような実装がよいかと思います。 import std; void main () { int N = readln.chomp.to!int; int[] D = readln.split.to!(int[]); int ans = 0; for (int i = 1; i \u0026lt;= N; i++) { for (int j = 1; j \u0026lt;= D[i-1]; j++) { auto S = i.to!string ~ j.to!string; bool ok = true; foreach (s; S) if (s != S[0]) ok = false; if (ok) ans++; } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } そうでない言語なら、判定部分を bool ok = true; int basis = i%10; while (0 \u0026lt; i) { if (i%10 != basis) ok = false; i /= 10; } while (0 \u0026lt; j) { if (j%10 != basis) ok = false; j /= 10; } という感じになるかなと思います。 C - Consecutive 問題へのリンク ナイーブに操作すると$r_i - l_i$が大きいクエリばかり飛んでくるときが最悪ケースで、$O(N^2)$です。 区間クエリを高速化する問題は、累積和を考えると良い場合があります。この問題はまさにそうで、 cum[i] := (S[j] == S[j+1]なら1、そうでないなら0 の 0\u0026lt;=j\u0026lt;=iの総和)と定めると、 前処理$O(N)$クエリ$O(1)$で答えることができます。 クエリをどうやって処理するべきかを一回考えると思いつきやすいような気がします。 (連続区間において条件を満たす場所を数える) -\u0026gt; (条件を満たす場所を1、満たさない場所を0と対応させて、Static Range Sum Queryに帰着) -\u0026gt; 累積和 という流れなのかなと思います。 2番目の考察(あるを1、ないを0に対応させること)がかなりad-hocな気がしますが、これはかなり頻出なので覚えるべきことなのかな？ ちなみに、2番目の考察はDynamic Kth Elementとか$O(N \\log N)$の転倒数にも現れるアイデアです。 import std; void main () { int N, Q; readln.read(N, Q); string S = readln.chomp; solve(N, Q, S); } void solve (int N, int Q, string S) { // imosをやる long[] cum = new long[](N); foreach (i; 0..S.length-1) if (S[i] == S[i+1]) cum[i]++; foreach (i; 1..N) cum[i] += cum[i-1]; foreach (_; 0..Q) { int l, r; readln.read(l, r); l--, r--; if (l == r) { writeln(0); continue; } if (0 \u0026lt; l) writeln(cum[r-1]-cum[l-1]); else writeln(cum[r-1]); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Take ABC 問題へのリンク ナイーブに操作すると削除の後に「詰める」操作が発生するので、$O(N^2)$になります。これを改善します。 「左から削除していく」という文言を見た時点で、括弧列の対応を見る問題との共通点を感じました。 \u0026quot;ABC\u0026quot;が\u0026quot;()\u0026quot;だったら有効括弧列を消す問題になるんじゃないかな？ 括弧列の問題 -\u0026gt; 文字列を先頭から見ていって(見たやつをスタックに積んでいって) \u0026quot;)\u0026quot;が出てきたらスタックの先頭が\u0026quot;(\u0026quot;かどうかチェックする。 この問題 -\u0026gt; 文字列を先頭から見ていって\u0026quot;C\u0026quot;が出てきたらスタックの先頭が\u0026quot;AB\u0026quot;かどうかチェックする。 みたいな感じで処理できます。一つの文字を高々2回までしか参照しないので、$O(N)$です。 import std; void main () { string S = readln.chomp; solve(S); } void solve (string S) { /* 前から見ていけばよろしい */ char[] ans; foreach (c; S) { ans ~= c; if (3 \u0026lt;= ans.length) { if (ans[$-3..$] == \u0026#34;ABC\u0026#34;) { ans = ans[0..$-3]; } } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } E - Modulo MST 問題へのリンク 全域木(Spanning Tree)とは、与えられた$G$の部分グラフ$G\u0026rsquo;$であって、$G$のすべての頂点$V(G)$を含み、かつ木であるようなものをいいます。 全域木であって、辺の重みの総和が最小であるものを最小全域木(MST)といいますが、本問では総和ではなく総和を$K$で割ったあまりをコストとしています。 最小全域木を求めるアルゴリズム(クラスカル法など)は役に立ちそうにないです。 制約を見ると、不自然に小さいです。また、あまりを含む最小化問題は感覚的に全探索しかなさそうな感じがします。 そこで、全探索を考えましょう。 「$G\u0026rsquo;$が全域木である」 ならば 「$G\u0026rsquo;$は$N-1$本の辺を持つ」 は真です。つまり、 $G$が全部で$M$本の辺を持つ時、 $\\dbinom{M}{N-1}$通りの辺の取り方を全部調べることができたら十分なことは明らかです。 (この組み合わせには全域木にならないケースも含まれる可能性がありますが、それはコスト更新の時に無視したらよいです。) 今回に関しては最大ケースで$\\dbinom{28}{7} = 1184040$になります。これで通せそうです。 import std; struct trio { int u, v; long w; } void main () { int N, M; long K; readln.read(N, M, K); trio[] edge = new trio[](M); foreach (i; 0..M) with(edge[i]) { readln.read(u, v, w); u--, v--; } solve(N, M, K, edge); } void solve (int N, int M, long K, trio[] edge) { /* Nが十分に小さいので、あり得る全域木を全探索すればよろしい */ /* ほげほげのコストを無視すれば、ありうる全域木は28C7 ~ 10^6通りのはず */ /* あほか？28C7列挙すればいいだろう */ int[][] graph = new int[][](N, 0); bool[] visited = new bool[](N); bool check (trio[] edge) { foreach (ref g; graph) g.length = 0; foreach (e; edge) { graph[e.u] ~= e.v; graph[e.v] ~= e.u; } visited[] = false; void dfs (int pos) { visited[pos] = true; foreach (to; graph[pos]) { if (!visited[to]) dfs(to); } } dfs(0); foreach (v; visited) if (!v) return false; return true; } long ans = long.max; foreach (e; enumComb(edge, N-1)) { if (check(e)) { long sum = 0; foreach (ee; e) (sum += ee.w) %= K; ans = min(ans, sum); } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } struct enumComb_(T) { import std.exception; import std.format; import std.range.primitives : ElementType, isRandomAccessRange; long N, K; long[] idx; bool isEmpty; enum bool isNumeric = __traits(isIntegral, T); static if (!isNumeric) { static assert(__traits(compiles, isRandomAccessRange!(T)) || is(T == E[n], E, size_t n) || is(T == E[], E), \u0026#34;T must be Integral type or RandomAccessRange. Now T = \u0026#34;, T.stringof); alias E = ElementType!(T); E[] res; T arr; } this (T N, long K) { static if (isNumeric) { auto msgN = format(\u0026#34;Line : %s, N must be greater than or equal to 0. your input = %s\u0026#34;, __LINE__, N); enforce(0 \u0026lt;= N, msgN); this.N = N; } else { this.N = N.length; arr = N; res = new E[](cast(uint) K); } auto msgK = format(\u0026#34;Line : %s, K must be greater than or equal to 0. your input = %s\u0026#34;, __LINE__, K); enforce(0 \u0026lt;= K, msgK); this.K = K; idx = new long[](cast(uint) K); init(); } void init () { foreach (i; 0..K) { idx[cast(uint) i] = i; } if (N \u0026lt; K) { isEmpty = true; } } bool empty() const { return isEmpty; } static if (isNumeric) { long[] front() { return idx; } } else { E[] front () { foreach (i, x; idx) { res[i] = arr[cast(uint) x]; } return res; } } void popFront() { long index; (){ foreach (i; 0..K) { if (idx[cast(uint) ($-i-1)] \u0026lt; N-i-1) { idx[cast(uint) ($-i-1)]++; index = K-i-1; return; } } // there is no choice :( isEmpty = true; }(); foreach (i; index+1..K) { idx[cast(uint)i] = idx[cast(uint)i-1] + 1; } } } auto enumComb(T) (T N, long K) { return enumComb_!(T)(N, K); } ちょうど$\\dbinom{N}{K}$を列挙するアルゴリズムを用意していたので、そんなに苦労せず実装できました。 1700msだったのであまりよくない実装をしていたっぽい\u0026hellip;？ F - Good Set Query 問題へのリンク 題意自体はつかめたのですが、いつものトポロジカル順に処理する奴ではうまく列$(X_1, X_2, \\dots, X_N)$ を決められないなーと思い、そこで行き詰りました。 どうやら重み付き(ポテンシャル付き)UnionFindなるデータ構造で解けるようです。 今週中に解法及びデータ構造を理解して、ACします。(時間があれば別記事たてます。) 終わりに 書きたいことは大体書いたので、あとは適当に近況でも書きます。 最近レーティングが1200あたりで収束している感じがあり、上に行くためにはもっとプロコンに力を入れないとなーと感じています。もっといろんな知識を仕入れたいです。 短期的な目標としては来年までに1300到達、もう少し長期的な目標は次のICPCまでに1600到達です。 無理かもしれませんが、Problemsの水色埋めを客観的に見た感じ到達可能にも感じます。 あと、思うこととして、レーティングとかの指標は本来過去の自分と比較すべきだと考えているのですが、 Twitterとかを追っていると意味のない焦りや嫉妬によって無駄なエネルギーが消耗している実感があります。本来こんな無駄なことをせずに研鑽すべきなんですがね。。。 過去の経験も含めて自分はSNS依存の傾向があるので、自制していきたいですね。 最近、品田遊著「名称未設定ファイル」Amazonリンク(アフィではないです)を読みました。 星新一が好きな人とかおすすめです。あと、普段本じゃなくてネットばっかり見てる私みたいな人にもおすすめです。 それではこのあたりにしておこうと思います。また次のエントリで。"
  },
  {
    url: "/",
    title: "InTheDayDream",
    date: "2023-11-12T00:00:00Z",
    body: "InTheDayDream"
  },
  {
    url: "/post/",
    title: "Posts",
    date: "2023-11-12T00:00:00Z",
    body: "Posts"
  },
  {
    url: "/post/abc100d/",
    title: "ABC100D - Patisserie ABC",
    date: "2023-11-06T00:00:00Z",
    body: "ABC100D - Patisserie ABC 問題概要 問題へのリンク $N$種類のケーキがある。$i$種類目のケーキは「綺麗さ」$x_i$、「おいしさ」$y_i$、「人気度」$z_i$を持っている。 このうち$M$種類のケーキを選んで食べる。ただし、同じ種類のケーキを2つとることはできない。 選んだ$M$種類のケーキに対して、スコアを $\\left| \\displaystyle\\sum_{i=1}^M x_i \\right| + \\left| \\displaystyle\\sum_{i=1}^M y_i \\right| + \\left| \\displaystyle\\sum_{i=1}^M z_i \\right|$ と定める。 スコアの最大値を求めよ。 制約 $1 \\leq N \\leq 1000$ $0 \\leq M \\leq N$ $1 \\leq i \\leq N$に対して、$-10^{10} \\leq x_i, y_i, z_i \\leq 10^{10}$ 考察 ナイーブに全探索を考えると、とりうるケーキの組み合わせの数は $\\displaystyle\\binom{N}{M}$通りになるが、$N = 1000, M = 500$において非常に大きくなるため現実的でない。 また、各$x_i, y_i, z_i$の値が大きいため部分和問題のようなdpはできない。 どうしようか？ 解法1 典型テクニック: 「絶対値関数はmax関数で外す」を用いる。 頑張って変形していく。 $$ \\begin{equation*} \\begin{split} \\left| \\displaystyle\\sum x_i \\right| + \\left| \\displaystyle\\sum y_i \\right| + \\left| \\displaystyle\\sum z_i \\right| \u0026= \\max \\left( \\displaystyle\\sum x_i, ~ -\\displaystyle\\sum x_i \\right) + \\max \\left( \\displaystyle\\sum y_i, ~ -\\displaystyle\\sum y_i \\right) + \\max \\left( \\displaystyle\\sum z_i, ~ -\\displaystyle\\sum z_i \\right) \\\\ \u0026= \\max \\left( \\displaystyle\\sum x_i + \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~ \\displaystyle\\sum x_i + \\displaystyle\\sum y_i - \\displaystyle\\sum z_i, ~ \\displaystyle\\sum x_i - \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~ \\displaystyle\\sum x_i - \\displaystyle\\sum y_i - \\displaystyle\\sum z_i, ~ -\\displaystyle\\sum x_i + \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~ -\\displaystyle\\sum x_i + \\displaystyle\\sum y_i - \\displaystyle\\sum z_i, ~ -\\displaystyle\\sum x_i - \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~ -\\displaystyle\\sum x_i - \\displaystyle\\sum y_i - \\displaystyle\\sum z_i \\right) \\\\ \u0026= \\max \\left( \\displaystyle\\sum (x_i + y_i + z_i), ~ \\displaystyle\\sum (x_i + y_i - z_i), ~ \\displaystyle\\sum (x_i - y_i + z_i), ~ \\displaystyle\\sum (x_i - y_i - z_i), ~ \\displaystyle\\sum (-x_i + y_i + z_i), ~ \\displaystyle\\sum (-x_i + y_i - z_i), ~ \\displaystyle\\sum (-x_i - y_i + z_i), ~ \\displaystyle\\sum (-x_i - y_i - z_i) \\right) \\end{split} \\end{equation*} $$ とてもすっきりした式になった。 よく見ると、最後のmax関数の中にある各項は$O(N\\log N)$で計算できることが分かる。 よって全体$O(N\\log N)$で解くことができる。 import std; alias trio = Tuple!(long, \u0026#34;x\u0026#34;, long, \u0026#34;y\u0026#34;, long, \u0026#34;z\u0026#34;); void main () { int N, M; readln.read(N, M); trio[] cake = new trio[](N); foreach (i; 0..N) { with (cake[i]) readln.read(x, y, z); } solve(N, M, cake); } void solve (int N, int M, trio[] cake) { /* 典型テク: 絶対値記号を外すやつ によって符号を変えた8通りの和で貪欲にとればよい。O(N log(N)) */ long[] val = new long[](N); int[] sign = new int[](3); long ans = -long.max; void calc () { foreach (i; 0..N) { val[i] = 0; foreach (j, c; cake[i]) { if (sign[j] == 0) val[i] += c; if (sign[j] == 1) val[i] -= c; } } val.sort!\u0026#34;a\u0026gt;b\u0026#34;; ans = max(ans, val[0..M].sum); } void dfs (int level) { if (level == 3) { /* 処理 */ calc(); return; } foreach (i; 0..2) { sign[level] = i; dfs(level+1); } } dfs(0); writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 解法2 はまやんさんの解説で紹介されているdpをすることもできる。 結論から言うと、最初検討した部分和問題ではなく $$ \\begin{equation*} dp[i][j] = (i項目までのうちj項をとったとき、あり得る最大値) \\end{equation*} $$ を考える。 このdpを考えるに至る考察は大体次のような感じになる。 $x_i, y_i, z_i$別々だとだるいので、まず$x_i$についてだけ考える。 絶対値をとるので、最適解は$\\sum x_i$が最大または最小になるときだと分かる。 →最大の値が採用されるときは普通にdpで解ける。 最小になるときが最適解になるときは総和が負になるはずなので、符号を反転させた状態でのdpも考える。 3軸に戻す。3軸すべてが最大をとるタイミングを採用できるように、8通りの符号でdpする。 詳しいアルゴリズムは実装例を参考にしてください。 import std; struct trio { long x, y, z; } void main () { int N, M; readln.read(N, M); trio[] cake = new trio[](N); foreach (i; 0..N) { with (cake[i]) readln.read(x, y, z); } solve(N, M, cake); } void solve (int N, int M, trio[] cake) { long[][] dp = new long[][](N+1, M+1); // dp[i][j] := (i項目までからj項選んだ時の最大値) long ans = 0; /* 符号8通りでdp */ for (int a = -1; a \u0026lt;= 1; a++) for (int b = -1; b \u0026lt;= 1; b++) for (int c = -1; c \u0026lt;= 1; c++) if (a*b*c != 0) { foreach (d; dp) d[] = -long.max; dp[0][0] = 0; foreach (i; 0..N) foreach (j; 0..M+1) { if (dp[i][j] == -long.max) continue; long diff = a*cake[i].x + b*cake[i].y + c*cake[i].z; // 採用 if (j+1 \u0026lt;= M) dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + diff); // 採用しない dp[i+1][j] = max(dp[i+1][j], dp[i][j]); } ans = max(ans, dp[N][M]); } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 発展 解法1は45度回転と呼ばれるテクニックとも関連がある。 45度回転とは2次元座標平面上においてマンハッタン距離を考えるときに有用になるテクニックである。 1問紹介しておこう。 ABC178E - Dist Max 問題文 2点$(a, b), ~ (c, d)$に対して2点間のマンハッタン距離を$|a - c|+|b - d|$と定める。 $N$点$(x_i, y_i)$が与えられる。2点間のマンハッタン距離としてあり得る最大の値を求めよ。 制約 $2 \\leq N \\leq 2\\times 10^5$ $1 \\leq x_i, y_i \\leq 10^9$ これを同様に処理してみる。 適当な二点についてマンハッタン距離を考えると、次のようになる。 $$ \\begin{equation*} \\begin{split} |x_i - x_j| + |y_i - y_j| \u0026= \\max (x_i - x_j, ~ x_j - x_i) + \\max (y_i - y_j, ~ y_j - y_i) \\\\\\\\ \u0026= \\max ((x_i - x_j)+(y_i - y_j), ~ (x_i - x_j)+(y_j - y_i), ~ (x_j - x_i)+(y_i - y_j), ~ (x_j - x_i)+(y_j - y_i)) \\\\\\\\ \u0026= \\max ((x_i + y_i)-(x_j + y_j), ~ (x_i - y_i)-(x_j - y_j), ~ -(x_i - y_i)+(x_j - y_j), ~ -(x_i + y_i)+(x_j + y_j)) \\\\\\\\ \u0026= \\max (|(x_i + y_i) - (x_j + y_j)|, ~ |(x_i - y_i) - (x_j - y_j)|) \\end{split} \\end{equation*} $$ を得る。 最後の式から、すべての点に対して$x_i + y_i$と$x_i - y_i$を計算して、 それぞれの差分の絶対値の最大値を見つければよい。 これは単にそれぞれの最大値と最小値を与える点を見つければよいため、全体$O(N)$で処理できる。 以上より、マンハッタン距離を代表とする絶対値記号は、max関数を用いて外すとうまく計算できる場合がある。 筆者は解法を理解していないが、yukicoder No.2520 L1 Explosionも45度回転を用いるらしい。 この問題は今後の課題としたい。 終わりに いつか取り上げたいと思っていたトピックに触れることができてよかった。 ただし、現状私はこの変換がなぜうまくいくのかという数学的背景を知らないため、 さらに勉強ないし応用の余地があると思う。 が、疲れたのでこのあたりにしておく。"
  },
  {
    url: "/post/abc327/",
    title: "ABC327参加記録",
    date: "2023-11-05T00:00:00Z",
    body: "ABC327参加記録 はじめに 本稿は、2023-11-04に行われたABC327の参加記録です。 戦績 今回の提出状況は次の通りです。 AからEまでの5問正解できました。 パフォーマンスは1513で、 レーティング変化は1207→1241(+34)でした。 所感 今回は割と早解きできた回だったかなという感じです。 5問目は割と非自明だと思ったのですがかなりたくさんの人が通していました。 とりあえず緑色に再び落下しなくてほっとしています。 問題雑振り返り A - ab 問題へのリンク Nが十分に小さいため、全部ナイーブに見ていくことで十分ACできます。 最初勘違いしていたため、サンプルに\u0026quot;ba\u0026quot;の順でYesが出るものがあってよかったです。 import std; void main () { int N = readln.chomp.to!int; string S = readln.chomp; foreach (i; 0..S.length-1) { if ((S[i] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; S[i+1] == \u0026#39;b\u0026#39;) || (S[i] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; S[i+1] == \u0026#39;a\u0026#39;)) { writeln(\u0026#34;Yes\u0026#34;); return; } } writeln(\u0026#34;No\u0026#34;); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - A^A 問題へのリンク $A^A$はかなり急激に大きくなるので、$A$を1から順番に$A^A$が$B$を超えるまで増やしていけばよさそうです。 実際、$10^{18} \u0026lt; 16^{16} = 18446744073709551616$なので、$A = 15$までを調べればよいです。 import std; void main () { long B = readln.chomp.to!long; for (long A = 1; ; A++) { if (B \u0026lt; A^^A) { writeln(-1); return; } if (B == A^^A) { writeln(A); break; } } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } ちなみに私の提出は通ってはいるものの、かなりまずいことをしています。 というのも、long.maxよりも$16^{16}$のほうが大きいためオーバーフローしています。 しかし、偶然オーバーフローを含めて$10^{18} \u0026lt; A^A$となるAが存在するようです。 ちゃんとACをとる場合はA=15で止めるか多倍長整数を使うと良いです。 C - Number Place 問題へのリンク 条件1と条件2は二重ループで簡単に判定できます。 条件3は少し複雑ですが、3×3領域を9回判定すると考えると比較的楽に判定をつくれます。 具体的には3×3領域のスタート地点(0, 0), (0, 3), (0, 6), \u0026hellip;, (6, 6)をループで列挙して、 判定自体はつかいまわします。 import std; void main () { int[][] A = new int[][](9, 0); foreach (i; 0..A.length) A[i] = readln.split.to!(int[]); solve(A); } void solve (int[][] A) { bool isOk = true; int[] mp = new int[](10); /* 条件1 */ foreach (i; 0..A.length) { mp[] = 0; foreach (j; 0..A[i].length) { mp[A[i][j]]++; } foreach (k; 1..10) { if (mp[k] != 1) isOk = false; } } /* 条件2 */ foreach (j; 0..A[0].length) { mp[] = 0; foreach (i; 0..A.length) mp[A[i][j]]++; foreach (k; 1..10) { if (mp[k] != 1) isOk = false; } } /* 条件3 */ int SY, SX; SY = 0; foreach (_; 0..3) { SX = 0; foreach (__; 0..3) { /* 処理 */ mp[] = 0; foreach (i; 0..3) foreach (j; 0..3) { int y = SY + i; int x = SX + j; mp[A[y][x]]++; } foreach (k; 1..10) { if (mp[k] != 1) isOk = false; } SX += 3; } SY += 3; } if (isOk) { writeln(\u0026#34;Yes\u0026#34;); } else { writeln(\u0026#34;No\u0026#34;); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Good Tuple Problem 問題へのリンク 二つの数列によってXの2項間に制約が課されていきます。 経験上、数列に制約を課していくような問題はグラフ表現に置き換えられないかを検討すると解けることがあります。 この問題はその方針さえ引ければかなり見えやすいと思います。 要はA[i]項目とB[i]項目が違えばよいので、 A[i]項目とB[i]項目の間に無向辺を張ったときに全体が二部グラフを成せばよいです。 二部グラフの判定にUnionFindを使えるらしいですが、よく理解していないので普通にdfsしました。 import std; void main () { int N, M; readln.read(N, M); int[] A = readln.split.to!(int[]); int[] B = readln.split.to!(int[]); solve(N, M, A, B); } void solve (int N, int M, int[] A, int[] B) { /* グラフ表現に落とし込んで解く */ /* 要は二部グラフなら良い */ A[] -= 1; B[] -= 1; int[][] graph = new int[][](N, 0); foreach (i; 0..M) { graph[A[i]] ~= B[i]; graph[B[i]] ~= A[i]; } int[] visited = new int[](N); visited[] = -1; bool isOk = true; void dfs (int pos) { foreach (to; graph[pos]) { if (visited[to] == -1) { if (visited[pos] == 0) visited[to] = 1; if (visited[pos] == 1) visited[to] = 0; dfs(to); } else { /* 矛盾がないか判定 */ if (visited[pos] == visited[to]) isOk = false; } } } foreach (i; 0..N) { if (visited[i] == -1) { visited[i] = 0; dfs(i); } } if (isOk) { writeln(\u0026#34;Yes\u0026#34;); } else { writeln(\u0026#34;No\u0026#34;); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } E - Maximize Rating 問題へのリンク 式をぐっとにらむところから考察スタートしました。 kがいろいろな値をとると面倒くさいので、とりあえず固定して考えます。 すると、$\\sum_{i=1}^{k} (0.9)^{k-i} Q_i$を最大化する問題になります。 が、変な係数がかかっているせいでQは貪欲にとれそうにありません。どうしましょう。 貪欲に取れない状況下で最適な部分集合を選ぶ問題というのは基本的に「全部見る」しかないはずです。 なので、この段階でdp濃厚だなーという感じです。(もちろん違う方針なときもあります。) ここで天啓が訪れます。 パフォーマンス$P_i$をx番目の項として採用する場合、 それまでにx-1個を採用した部分集合のみを考えればよいはずです。この方針で状態を圧縮します。 あとからとった項が前にとった項に直接寄与することがないので、次のdpができます。 $$ dp[i][j] = (Pを逆から見て、i項目までにj項とったときの\\sum (0.9)^{k-i} Q_iの最大値) $$ 遷移は /* 採用 */ dp[i+1][j+1] = dp[i+1][j+1], dp[i][j] + P[N-i-1]\\*pow(0.9, j)); /* 採用しない */ dp[i+1][j] = max(dp[i+1][j], dp[i][j]); となります。 このようなdpを私は勝手に「とる/とらないdp」と呼んでいるのですが、 圧縮後の値に部分集合の何項目に採用されたかという情報ものせられるのかと勉強になりました。 import std; void main () { int N = readln.chomp.to!int; int[] P = readln.split.to!(int[]); solve(N, P); } void solve (int N, int[] P) { /* いくつとるかを定めると、あとは最適なPの部分集合を見つける作業になる。 */ /* 最近のものほど重みが高い... -\u0026gt; 最適な部分集合は変わりうる。 */ /* 逆から考えれば、i項目まで見て、j個とって...とすると最適解をタプルに縮退できる。 */ /* dpをしましょう。 */ double[][] dp = new double[][](N+1, N+1); // dp[i][j] := 逆からi項目まで見て、j個とったとき、ありうる最大の分子 foreach (d; dp) d[] = -1; dp[0][0] = 0; foreach (i; 0..N) foreach (j; 0..N) { if (0 \u0026lt;= dp[i][j]) { // とる dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + P[$-i-1]*pow(0.9, j)); // とらない dp[i+1][j] = max(dp[i+1][j], dp[i][j]); } } double[] denominators = new double[](N+1); denominators[] = 0; denominators[1] = 1; foreach (i; 2..N+1) denominators[i] = denominators[i-1] + pow(0.9, i-1); double ans = -double.max; foreach (i; 0..N+1) foreach (j; 0..N+1) { if (0 \u0026lt; j) { ans = max(ans, dp[i][j]/denominators[j] - (1200/sqrt(j.to!double))); } } writefln(\u0026#34;%.10f\u0026#34;, ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } F問題以降 難しくてよくわからない。。。 F問題は考察の方針は非常に良かったようですが、解法を理解できるレベルに到達していないので本稿では触れません。 終わりに 最近$O(\\log N)$くらいの演算だからたくさん呼び出してもいいかーという 軽い気持ちでTLがぎりぎりになったりしていて、前計算の重要性を身に染みています。 前計算徹底いたします(ビッグモーター並感)。 近況も軽く書いておきます。 PG BATTLEで10位に入ることができて、商品をいただけるようです。やったね。 私の参加記録 PG BATTLE結果 PG BATTLE10位でしたーやったー 240点の中でトップらしい... あぶねーーー \u0026mdash; In (@UU9782wsEdANDhp) October 28, 2023 ちなみに商品は肉にしました。鍋にしたすぎ。 今年もUEC Advent Calendar 2023に参加します。プログラミングコンテストについて書く予定です。 皆さんも参加してみては？ アドベントカレンダー あと関係ないですが、最近自分の句読点の使い方の下手さにビビっています。 ほかの方が書いた文章や、プロの書いた文章に比べて明らかにリズムが悪い気がしています。 これを読んでいるあなたはどう思いますか？ まともな文章を書く訓練ってどうやってやるんでしょうね。 というわけでこのあたりにしておきます。また次の記事で～"
  },
  {
    url: "/post/abc190f/",
    title: "ABC190F - Shift and Inversions",
    date: "2023-11-01T00:00:00Z",
    body: "ABC190F - Shift and Inversions 問題概要 問題へのリンク $0$から$N-1$までの整数をちょうど一つづつ含む数列$A$が与えられる。 $k \\in \\mathbb{Z}$に対して、数列$B$を次のように定める。 $$ \\begin{equation*} B \\coloneqq \\{b_i\\}_{i=0}^{N-1}, ~ b_i = a_{i+k ~ \\mathrm{mod} ~ N} \\end{equation*} $$ $k = 0, 1, 2, \\dots , N-1$のそれぞれに対して、$B$の転倒数を求めよ。 制約 $2 \\leq N \\leq 2 \\times 10^5$ 考察 $k$を一つ変える操作は、変える前の数列を左シフトしたようなものになっている。 例えば、$A = (0, 1, 2, 3, 4)$であったとき、 $k=0$ : $B = (0, 1, 2, 3, 4)$ $k=1$ : $B = (1, 2, 3, 4, 0)$ $k=2$ : $B = (2, 3, 4, 0, 1)$ $k=3$ : $B = (3, 4, 0, 1, 2)$ $k=4$ : $B = (4, 0, 1, 2, 3)$ となる。 まずは転倒数について確認しておく。 転倒数とは、簡単に定義するなら、次の条件を満たす組$(i, j)$の個数である。 $i \u0026lt; j$ $B_i \u0026gt; B_j$ 言葉で言うなら、各要素に対しての「自分より左にいる、自分より大きなものの総数」の和である。 さて、操作によって転倒数がどう変化するかを考えよう。 操作は、「一番左の要素を一番右に持っていく」というものになっている。 これを行うと、全体の転倒数は次のように変化することがわかる。 動かした要素より小さい要素の数だけ転倒数が減る。 動かした要素より大きな要素の数だけ転倒数が増加する。 これは転倒数の定義からも簡単に確認できるだろう。 これで、操作1回によって転倒数がどれだけ変化するかはすぐ算出できることがわかった。 後は最初の数列の転倒数を求められればACできそうだ。 典型テク: 転倒数を$O(N \\log N)$で求める。 さて、数列$A$に対してナイーブに転倒数を求めるアルゴリズムを考えると、次のようなものになるだろう。 int InversionNumber = 0; for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; i; j++) { if (A[j] \u0026lt; A[i]) InversionNumber++; } } これは明らかに$O(N^2)$で、間に合わない。 さてどうしよう。 実は、転倒数を$O(N \\log N)$で求めるアルゴリズムが存在する。 ここからその説明をする。 転倒数の定義から、次が成立する。 $$ \\begin{equation*} (転倒数) = \\sum_{i=0}^{N-1} ((j\u0026lt;i) ~ \\land ~ (A_i \u0026lt; A_j)を満たすjの数) \\end{equation*} $$ 少し寄り道をする。 まず、非負数列$B$に対して数列$C$を次のように定める。 $$ \\begin{equation*} C \\coloneqq \\{c_i\\}_{i=0}, ~ c_i = (数列Bに含まれるiの個数) \\end{equation*} $$ 具体例を挙げよう。 数列$(0, 1, 2, 3)$に対して、$C = (1, 1, 1, 1, 0, 0, \\dots)$であり、 数列$(1, 1, 3, 5, 7)$に対して、$C = (0, 2, 0, 1, 0, 1, 0, 1, 0, \\dots)$となる。 また、数列$B$に対して定められる数列$C$を$C_B$と表すことにする。 数列$A$の$i$項目から$j$項目までを順番を変えずに切り取った数列を、$A$の連続部分数列と呼び、 $A[i \\dots j]$と表すとする。 これらを用いて先程の転倒数の定義を言い換えると、次のようになる。 $$ \\begin{equation*} (転倒数) = \\sum_{i=1}^{N-1} \\sum c \\in ( C_{A[0 \\dots i-1]}[A_i+1 \\dots \\infty] ) \\end{equation*} $$ 式が最悪すぎるのには目をつぶってほしい\u0026hellip;数学に明るくなく、うまい定式化ができなかった。 さて、ここで$C_{A[0 \\dots i-1]}$については各ケースに対して1から求める必要は無く、 $C_{A[0 \\dots i-2]}$に$A_i$を含めてやればよいことがわかるだろう。 また、数列$C$は(数列$A$の最大値)番目以降は全て0になるため、そこで打ち切って良い。 したがって、各ケースで 「数列の要素を一つだけ変更する。新しく得た数列の$A_i+1$番目から最後までの総和を求めよ」という問題を解けば良い。 この問題は、数列の動的区間和を高速に求めるデータ構造(BITやSegment Tree)を用いることで解ける。 例えば、Segment Treeを使った場合、区間和の更新と取得で$O(\\log N)$かかるため、全体で$O(N \\log N)$になる。 以上で最初の一つの転倒数を$O(N \\log N)$で得ることができた。 補足: 本章では必要以上にややこしい説明を行っていますが、これは自分が後で見返したときのためです。 正直ググって他の資料をあたったほうがわかりやすいと思います。ごめんなさい。 実装例 import std; void main () { int N = readln.chomp.to!int; int[] a = readln.split.to!(int[]); solve(N, a); } void solve (int N, int[] a) { /* 転倒数 O(NlogN) */ auto RSQ = new SegmentTree!(int, (int a, int b) =\u0026gt; (a+b), () =\u0026gt; 0)(a.length); long[] ans = new long[](N); foreach (i; 0..a.length) { ans[0] += RSQ.prod(a[i]+1, a.length); RSQ.set(a[i], RSQ.get(a[i])+1); } /* 左端を右端に動かすとき、(もとの数列がわかれば)転倒数の変化は比較的簡単にわかるので、最初の一回を求められれば後はO(N) */ foreach (i; 1..N) { ans[i] = ans[i-1] - a[i-1] + (N-a[i-1]-1); } foreach (i; 0..N) writeln(ans[i]); } Segment Treeの実装は長いので省略した。 感想 自力でACできたのと、転倒数を$O(N \\log N)$で求めるアルゴリズムに触れたので良かった。 このように、「すでにわかっている結果から少しいじると他の解がわかる」 みたいなタイプの問題を落とさないようにしたい(3戦1勝2敗)。"
  },
  {
    url: "/post/abc235e/",
    title: "ABC235E、あるいはクエリ並列処理",
    date: "2023-10-31T00:00:00Z",
    body: "ABC235E、あるいはクエリ並列処理 問題概要 問題 辺の重みがすべて異なる無向連結グラフ$G$が与えられる。 さらに、クエリ$i$で$G$中のどの辺とも異なる重みをもつ辺$(u_i, v_i, w_i)$が与えられる。 クエリ$i$で与えられた辺を$G$に追加したグラフ$G\u0026rsquo;$を考える。 すべての$i$に対して、辺$(u_i, v_i, w_i)$は$G\u0026rsquo;$の最小全域木に含まれるか判定せよ。 制約 $2 \\leq N \\leq 2 \\times 10^5$ ($G$の頂点数) $N-1 \\leq M \\leq 2 \\times 10^5$ ($G$の辺数) $1 \\leq Q \\leq 2 \\times 10^5$ 考察と解法 クラスカル法を考えると、辺を重みと連結性で貪欲にとればよい。 したがって、一つのクエリに対して$O(N \\log N)$で答えることができる。 しかし、このままだと全体$O(QN \\log N)$で間に合わない。 高速化を考える。 一つ一つのクエリは最小全域木に含まれるかどうかのみを判定して、元のグラフ$G$に取り込まれないことを利用しよう。 クラスカル法によると、辺の重みでソートして、辺が結ぶ頂点がまだ連結でない場合にのみ辺を採用すればよい。 そこで、次のアルゴリズムを考える。 すべてのクエリを先読みして、もとからあった$M$個の辺と$Q$個の辺を重みでソートする。 クラスカル法に基づいて、辺を採用するかどうかを判定していく。 ただし、クエリで与えられた辺は採用できる場合でも採用しない。 これでうまくいく。 なぜなら、一つのクエリから見れば、ほかのクエリによる$Q-1$個の辺は必ず採用されないため、 グラフ$G$の連結性に影響を与えていないからだ。 時間計算量は$O((N+Q) \\log (N+Q))$となる。 実装例 import std; struct edge { int u, v; long w; int idx; } void main () { int N, M, Q; readln.read(N, M, Q); edge[] e = new edge[](M+Q); foreach (i; 0..M) { with (e[i]) { readln.read(u, v, w); u--, v--; idx = -1; } } foreach (i; 0..Q) { with (e[i+M]) { readln.read(u, v, w); u--, v--; idx = i; } } solve(N, M, Q, e); } void solve (int N, int M, int Q, edge[] e) { /* 解説AC クラスカル法を適用すればクエリ単品なら簡単に解ける。これをどうするか？ -\u0026gt; クエリ先読みして、全部の辺をまとめてソートしたうえでその辺を採用できるかどうかを見ると行ける。 */ e.sort!\u0026#34;a.w \u0026lt; b.w\u0026#34;; string[] ans = new string[](Q); auto UF = UnionFind!int(N+Q); foreach (ee; e) with(ee) { if (UF.areInSameGroup(u, v)) { if (idx == -1) continue; ans[idx] = \u0026#34;No\u0026#34;; } else { if (idx == -1) { UF.unite(u, v); continue; } ans[idx] = \u0026#34;Yes\u0026#34;; } } foreach (i; 0..Q) { writeln(ans[i]); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } UnionFindの実装は長いので省いている。 典型テク: クエリ並列処理 今回の問題のように、あるクエリがほかのクエリに影響を与えない場合、 すべてのクエリを一斉に処理することで高速に解くことができる場合がある。 クエリが飛んでくる問題が来た時に一度は検討したい方針である。 発展 今回の問題は、別の解法もある。 クエリ$i$で$(u_i, v_i, w_i)$が来た時、 この辺が最小全域木に採用されるかどうかは、 $(u_i, v_i)$を結ぶパス(木なので、ちょうど一つ存在)に含まれる辺の最大重みが $w_i$より重いかどうかで判定することができる。 より具体的には、 もし$w_i$より重い辺が存在するなら、その辺をカットして、 $(u_i, v_i, w_i)$を採用することで全域木であることを保ちつつ、より総和が小さくなる。 そうでない場合は必ず総和が増える。 実は、この問題は解くことができる。(らしい) 詳しくはkyopuro_friendsさんの解説に載っているが、 私はまだ理解できていないため、紹介にとどめる。 終わりに この発想は出なかった。次見たときには解けるようになりたい。"
  },
  {
    url: "/post/pgbattle2023/",
    title: "PG BATTLE 2023参加記録",
    date: "2023-10-23T00:00:00Z",
    body: "PG BATTLE 2023参加記録 \r始まりは突然に 10月9日に、やきとりさん(@yktr_drm06)からPG BATTLEに誘われて、 私、やきとりさん、ryotaさん(@95s7k84695a)のチームで参加することになりました。 このコンテストの存在は知っていたものの、学内に競技プログラミングをしている知り合いが存在しないため、どうしようか迷っていました。(最悪電通大競プロサークルのDiscordで募集かけようかと思っていた。) そんな時にお誘いいただいたので、ぜひ！ということで参加させていただきました。 メンバーが私よりも強い方なので、ラッキーだなとか思っていました(すいません。) PG BATTLEについて 普段はAtCoderのコンテスト及び類似のコンテストしか出ていないので、PG BATTLEのルールはちょっと新鮮でした。 要点は以下の通りです。 3人1チーム ひとりひとり解く問題が違う(配点は1/3ずつ) チーム内相談禁止 提出は一回のみ 総得点及び解答提出時間で勝負 ICPCですら提出は何回かできるので、プログラミングコンテストとしてはかなり珍しい方だなと思います。 問題は、ましゅまろ/せんべい/かつおぶしの三種類あり、誰がどの問題を解くかは事前に決めることができます。 私は二番目に簡単なせんべいを担当しました。 せんべい雑振り返り すべての問題はここで公開されています。 難易度2 積の符号 ちょっと前にTwitterで話題になっていた、注意力を要求するB問題みたいな雰囲気のする問題です。 符号を当てればよいので、全部掛け算する必要はなく、0があるかどうかで場合分けをすればよいです。 0がなければ、-の要素が偶数個か奇数個かでACできます。 import std; void main () { int N = readln.chomp.to!int; int[] A = readln.split.to!(int[]); int minus = false; A.sort; foreach (i; 0..N) { if (A[i] == 0) { writeln(0); return; } if (A[i] \u0026lt; 0) minus++; } if (minus % 2 == 0) { writeln(\u0026#34;+\u0026#34;); } else { writeln(\u0026#34;-\u0026#34;); } } 難易度3 ABCの個数 期待値を求める系の問題は大体よくわかってないので、 苦手問題来たーって思って身構えました。 ググって何とかならないかなーと思って、 「期待値の線形性」というキーワードで出てきたこのサイトを見ていたら、 応用例2がまさにこの問題でした。ラッキー！ どうやら各部分で\u0026quot;ABC\u0026quot;が作れる確率を足し合わせればよいようです。 期待値の線形性ってこうやって使うんだなぁと勉強になったような気がします。 ただ、数学的理解が怪しいのでうーんという感じです。 import std; void main () { string S = readln.chomp; solve(S); } void solve (string S) { /* 期待値の線形性を使う */ /* 場所iをスタートにしてABCができる確率X_iとすると、解はE[Σ(X_i)] */ double ans = 0; foreach (i; 0..S.length) { if (S.length \u0026lt;= i+2) continue; if ((S[i] != \u0026#39;?\u0026#39; \u0026amp;\u0026amp; S[i] != \u0026#39;A\u0026#39;) || (S[i+1] != \u0026#39;?\u0026#39; \u0026amp;\u0026amp; S[i+1] != \u0026#39;B\u0026#39;) || (S[i+2] != \u0026#39;?\u0026#39; \u0026amp;\u0026amp; S[i+2] != \u0026#39;C\u0026#39;)) continue; /* 確率0 */ int UnComfirmed = 0; for (int j = 0; j \u0026lt; 3; j++) if (S[i+j] == \u0026#39;?\u0026#39;) UnComfirmed++; ans += 1./(3^^UnComfirmed); } writefln(\u0026#34;%.10f\u0026#34;, ans); } 難易度4 距離K これは割とすぐ解法が見えました。 まずは数列を次のようにK個のグループに分けます。 $$\\mathrm{group}[i] \\coloneqq \\{ A[x] \\mid \\forall j, ~ x = i+jK \\}$$ 実は、操作によって入れ替わることができるのは同一グループに属する要素だけです。 簡単のため、ある一つのグループ以外を固定して考えます。 この時、数列Aは操作できるグループの「同じものを含む順列」通り数になります。 同様の議論をすべてのグループに適用することで、数列Aの変化先の総数は、 すべてのグループについての「同じものを含む順列」の総積であることが分かります。 式におこしましょう。$\\mathrm{group}[i]$が要素$x[j]$を$y[j]$個持つとすると、求める値は $$ \\prod_{i} \\frac{\\left( \\sum_{j} y[j] \\right)!}{\\prod_j (y[j]!)} $$ となります。$\\sum_{j}y[j] \\leq N$なので、 Nまでの階乗及びその逆元をを空間/時間$O(N)$で先に求めておけば、上の式を高速に求めることができます。 import std; void main () { int N, K; readln.read(N, K); int[] A = readln.split.to!(int[]); solve(N, K, A); } void solve (int N, int K, int[] A) { const long MOD = 998244353; /* 階乗前計算 */ long[] fact = new long[](N+1); long[] factInv = new long[](N+1); fact[0] = factInv[0] = 1; for (int i = 1; i \u0026lt;= N; i++) { fact[i] = i*fact[i-1] % MOD; factInv[i] = modInv(fact[i], MOD); } int[][] ModuloKGroups = new int[][](K, 0); foreach (i; 0..K) { if (N \u0026lt;= i) continue; int pos = i; while (pos \u0026lt; N) { ModuloKGroups[i] ~= A[pos]; pos += K; } } /* 最後にprodの総積をとる */ long[] prod = new long[](K); int[int] count; foreach (i; 0..K) { int ElemSize = cast(int) ModuloKGroups[i].length; foreach (m; ModuloKGroups[i]) count[m]++; prod[i] = fact[ElemSize]; foreach (key, val; count) { prod[i] *= factInv[val]; prod[i] %= MOD; } count.clear; } long ans = 1; foreach (i; 0..K) { ans *= prod[i]; ans %= MOD; } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } long modPow (long a, long x, const int MOD) { // assertion assert(0 \u0026lt;= x); assert(1 \u0026lt;= MOD); // normalize a %= MOD; a += MOD; a %= MOD; // simple case if (MOD == 1) { return 0L; } if (x == 0) { return 1L; } if (x == 1) { return a; } // calculate long res = 1L; long base = a % MOD; while (x != 0) { if ((x\u0026amp;1) != 0) { res *= base; res %= MOD; } base = base*base; base %= MOD; x \u0026gt;\u0026gt;= 1; } return res; } long modInv (long x, const int MOD) { import std.exception; enforce(1 \u0026lt;= MOD, format(\u0026#34;Line : %s, MOD must be greater than 1. Your input = %s\u0026#34;, __LINE__, MOD)); return modPow(x, MOD-2, MOD); } 難易度6 トリオ なんもわからん！こんなの無理だろ！と文句を言っていたらコンテストが終わりました。。。 chokudaiさんが解説を上げていたので見ましたが、これは本番解けるわけないな\u0026hellip;となりました。 しかし、一応状態$O(3^N)$までは見えていたので、悪くはないかな？ 終わりに チーム戦も面白いですね。 またこういうコンテストに出たいなぁと思いました。 チーム合計240点で割とよさげなので、なんか商品もらえるといいなぁ やきとりさん、ryotaさん、お誘いいただきありがとうございました。"
  },
  {
    url: "/post/functional-graph-cycle/",
    title: "Functional Graphのサイクル検出をいい感じに",
    date: "2023-10-13T00:00:00Z",
    body: "Functional Graphのサイクル検出をいい感じに はじめに グラフ表現に帰着できる問題を考察していると、Functional Graphと呼ばれるグラフのサイクル検出に帰着する場合があります。 本稿では、Functional Graphのサイクル検出の比較的簡単な実装を紹介します。 前提条件 本稿における、Functional Graphの定義は次のとおりです。 有向グラフであって、各頂点の出次数がちょうど1であるもの。 方法 まず、画像でイメージを掴んでもらいます。 これがFunctional Graphです。各頂点から一つだけ有向辺があるのが確認できると思います。 ここで、頂点{1, 2, 3, 4, 5}は閉路をなしていますが、それ以外は閉路に含まれていません。 これをどうやって検出するかが本題です。 UnionFind(dsu)を使います。 まず、Functional Graphの重要な性質に、連結成分がちょうど一つの閉路を持つというものがあります。 証明(厳密でない)\r連結成分が少なくとも一つの閉路を持つこと 頂点1つから考えて、まだ連結成分でない頂点へ有向辺を張ると、必ず連結成分のサイズが1増えます。 つまり、サイズkの連結成分を成す最小の有向辺はk-1本です。 一方、Functional Graphにおけるサイズkの連結成分は必ずk本の有向辺を持ちます。 これは、少なくとも1本はすでに連結である頂点へと有向辺を張っていることになり、閉路を含みます。 高々1つの閉路を持つこと あるFunctional Graphの連結成分が2つの閉路を持つと仮定します。 閉路が頂点を共有するとき 少なくとも2つの頂点が出次数2になり、違反します。 閉路が頂点を共有しないとき 閉路同士を結ぶ辺が必要ですが、このときに少なくとも1つの頂点が出次数2になり、違反します。 3以上も同様に証明できます(ほんとか？)。よって、閉路は高々1つです。 証明終わり。 UnionFindで連結成分を増やしていくと、どこかですでに同じ連結成分に属する頂点が見つかるはずです。 このとき見つかる頂点は、必ず閉路の中に入っている頂点になります。 Functional Graphにおける連結成分はちょうど一つだけ閉路を持ち、 出次数が必ず1であるため、閉路を構成する1頂点が見つかれば、 閉路に入っている他の全ての頂点もたどっていくだけで全て見つけることができます。 よって、以下のアルゴリズムを得ます。 以下、G[i]は頂点iに隣接する頂点を指す。 i=0,1,\u0026hellip;,Nに対して、次を行う。 頂点iと頂点G[i]が同じ連結成分に属していなければ、頂点iと頂点G[i]をマージして終了。同じ連結成分に属していれば、2に進む。 pos=iとして、再びpos=iとなるまでpos=G[pos]として更新する。 その途中でposに代入された頂点は、全て記録しておく。 記録された頂点は、一つの連結成分の閉路をなす頂点集合と一致する。 時間計算量はO(Nα(N))です。(α(N))はアッカーマン逆関数) また、本稿では詳しく紹介しませんが、強連結成分分解によって時間と空間O(N)を達成することもできます。 しかし、実装のコストは(強連結成分分解ライブラリがなければ)こちらのほうが軽いです。 どちらもおすすめです。 実装例 D言語による実装例を示します。 auto UF = UnionFind!int(); bool[int] NumberInCycle; foreach (i; 0..N) { if (!UF.is_same_group(i, A[i])) { UF.merge_group(i, A[i]); continue; } // 閉路検出 int cur = i; do { NumberInCycle[cur] = true; cur = A[cur]; } while (cur != i); } このコードを実行したあとにNumberInCycleに存在する要素は、Functional Graphのいずれかの連結成分における閉路を構成する頂点である。 練習問題 練習問題を3問用意しました。ぜひ解いてみてください。 1問はまさにこのアルゴリズムを用いる問題ですが、他の2問は考察部分があり、Functional Graphに帰着するのは自明ではないです。 なので、ネタバレが嫌だという方は1問目だけ解くと良いです。 ABC311C 解法\r状況設定はほとんど同じです。\r紹介したアルゴリズムを用いるだけで解くことができます。\rなお、この問題に関しては列を求める必要があるため、強連結成分分解よりもUnionFindの方が直接的に求められます。 ABC296E 解法\rこのゲームにおけるK_i回の操作は、Functional Graphにおける辺を移動していくことだとみなせます。\rそこで、もしこのグラフのある閉路に頂点iが含まれる場合、ゲームiにおいて任意のK_iに対して勝てる初期配置が存在します。 逆に、そうでないとき、十分に大きなK_iを指定するだけで必ず青木くんが勝てます。(例えば、K_i=10^9を考えてみてください。) すなわち、この問題はFunctional Graphの閉路に含まれる頂点の種類数を数える問題に帰着します。 ABC256E 解法\r人iから人X_iに有向辺を張ったグラフを考えます。すると、これはFunctional Graphになります。\rうまく順列を選ぶことで、必ず一つの連結成分あたり一人以外の不満度を0にすることができます。 連結成分は閉路をなしますから、全員を不満度0にはできません。 そこで、連結成分の誰を不満にするかを選ぶ問題に帰着します。 これは明らかに最小の不満度を取る貪欲法が有効です。 よって、Functional Graphの閉路に含まれる頂点を列挙する問題に帰着されました。 終わりに 本アイディアはABC256Eのnyaanさんの公式解説で紹介されていたものです。"
  },
  {
    url: "/post/yuki407/",
    title: "yukicoder contest407参加記録",
    date: "2023-10-06T00:00:00Z",
    body: "yukicoder contest407参加記録 はじめに 本稿は2023-10-06に行われたyukicoder contest 407の参加記録です。 戦績 雑振り返り A - napsack Problem? 問題へのリンク 重さW以下のナップサックのうち、容量の最大値を見ていくだけです。O(N) この人は単にデカいナップサックが欲しいだけみたいですね。 import std; void main () { int N, W; readln.read(N, W); int[] v = new int[](N); int[] w = new int[](N); foreach (i; 0..N) { readln.read(v[i], w[i]); } int ans = -1; foreach (i; 0..N) { if (w[i] \u0026lt;= W \u0026amp;\u0026amp; ans \u0026lt; v[i]) { ans = v[i]; } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - K-th in L2 with L1 問題へのリンク 結構問題文の読解が難しいと感じました。 ユークリッド距離がDであるような点は高々4D個になるので、 全部列挙 すべてに対するユークリッド距離を計算して配列に格納 良い点一つ一つについて、条件を満たすかどうか二分探索 でO(Dlog(D))だと思います。 import std; void main () { int Q = readln.chomp.to!int; foreach (_; 0..Q) { int D, K; readln.read(D, K); solve(D, K); } } void solve (int D, int K) { // マンハッタン距離Dの点集合を列挙 alias coord = Tuple!(int, \u0026#34;y\u0026#34;, int, \u0026#34;x\u0026#34;); bool[coord] DistanceDPoints; for (int i = 0; i \u0026lt;= D; i++) { int y = D-i; int x = i; DistanceDPoints[coord(y, x)] = true; DistanceDPoints[coord(y, -x)] = true; DistanceDPoints[coord(-y, x)] = true; DistanceDPoints[coord(-y, -x)] = true; } int[] dist; foreach (key, val; DistanceDPoints) { dist ~= key.y^^2 + key.x^^2; } dist.sort; // 二分探索 int f (int idx) { if (idx \u0026lt; 0) return -int.max; if (dist.length \u0026lt;= idx) return int.max; return dist[idx]; } foreach (key, val; DistanceDPoints) { int EuclidDist = key.y^^2 + key.x^^2; { int ok = 0, ng = cast(int) dist.length; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid) \u0026lt;= EuclidDist) { ok = mid; } else { ng = mid; } } if (ok+1 \u0026lt; K) continue; } { int ok = -1, ng = cast(int) dist.length; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid) \u0026lt; EuclidDist) { ok = mid; } else { ng = mid; } } if (K \u0026lt;= ok+1) continue; } writeln(\u0026#34;Yes\u0026#34;); writeln(key.x, \u0026#34; \u0026#34;, key.y); return; } writeln(\u0026#34;No\u0026#34;); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } おそらくかなり無駄の多い実装になっています。 こういうの結構苦手より。 C - Sum within Components 問題へのリンク 連結成分を列挙していくだけです。 visited[i]をboolにするのではなく、iを含む連結成分の総和が配列の何番目に入っているか？ という情報を入れておくことで、最後x=1, 2, \u0026hellip;, Nについての問題をO(1)で解けます。 割と明らかな問題な気がします。Bより簡単でした。 import std; void main () { int N, M; readln.read(N, M); int[] A = readln.split.to!(int[]); int[][] graph = new int[][](N, 0); foreach (_; 0..M) { int U, V; readln.read(U, V); U--, V--; graph[U] ~= V; graph[V] ~= U; } solve(N, M, A, graph); } void solve (int N, int M, int[] A, int[][] graph) { // 連結成分を列挙していけばよいですね～ const long MOD = 998244353; int[] visited = new int[](N); DList!int Q; long[] SumOfComponent; int idx = 0; visited[] = -1; foreach (i; 0..N) { if (visited[i] != -1) continue; visited[i] = idx; Q.insertBack(i); SumOfComponent ~= A[i]; SumOfComponent[idx] %= MOD; while (!Q.empty) { auto head = Q.front; Q.removeFront; foreach (to; graph[head]) { if (visited[to] != -1) continue; visited[to] = idx; (SumOfComponent[idx] += A[to]) %= MOD; Q.insertBack(to); } } idx++; } long ans = 1; foreach (x; 0..N) { ans *= SumOfComponent[ visited[x] ]; ans %= MOD; } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Three Sets 問題へのリンク 式いかつ過ぎです。 |S|は必ず非負整数なので、ΣAとかはなるたけでかい方が良いです。 したがって、部分集合といいつつ、要素を削るなら小さいものから削るのが最適なことが分かります。 これで各列から何個整数を持ってくるかを全探索できます。 累積和を用いてO(N3)です。 全く間に合いませんが、これ以上はわかりませんでした。 import std; void main () { // なるたけどれもデカいほうが良い。部分集合といいつつ、削るなら最小要素から削るべき(要素数は負にならないので、できるだけでかい方がお得) // O(N^3)しかわからんけど... int[3] N; int[][3] X; readln.read(N[0], N[1], N[2]); X[0] = readln.split.to!(int[]); X[1] = readln.split.to!(int[]); X[2] = readln.split.to!(int[]); solve(N, X); } void solve (int[3] N, int[][3] X) { // O(N^3) foreach (ref x; X) x.sort!\u0026#34;a\u0026gt;b\u0026#34;; int[][3] sum; foreach (i, ref s; sum) s = new int[](N[i]+1); foreach (idx, ref s; sum) foreach (i, ref ss; s) { if (i == 0) { ss = 0; continue; } ss = s[i-1] + X[idx][i-1]; } long ans = -long.max; for (int i = 0; i \u0026lt;= N[0]; i++) for (int j = 0; j \u0026lt;= N[1]; j++) for (int k = 0; k \u0026lt;= N[2]; k++) { ans = max(ans, sum[0][i]*j + sum[1][j]*k + sum[2][k]*i); } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } E以降 Dが解けていないのであまり見ていません。 終わりに yukicoderいつも難しくて良くて3問か4問までしか解けません。"
  },
  {
    url: "/post/mod-division-tech/",
    title: "割れるし割りたいのに割れない数を割る方法",
    date: "2023-10-05T00:00:00Z",
    body: "割れるし割りたいのに割れない数を割る方法 状況設定 $x, ~ y, ~ z \\in \\mathbb N$ $x\\%y = 0$ $1 \u0026lt; \\mathrm{gcd}(y, z)$ $x$は陽に求められないほど大きく、$y$、$z$は常識的な大きさ 問題 $xy^{-1}$を$z$で割った非負最小剰余を求めよ。 何が厳しいのか $\\mathrm{gcd}(y, z) = 1$が満たされていれば話は終了です。 なぜなら、このような$y$は$\\mathrm{mod} ~ z$上で逆元を持つからです。 普通に拡張ユークリッドの互除法などを用いれば答えられます。 問題はそうでない時です。 この時、$y$は逆元を持ちませんから、先に$\\dfrac{x}{y}$を計算したくなります。 しかし、$x$はデカいので、陽に求めるのは無理です。 さてどうしましょう？ 解答 結論から言います。$\\mathrm{mod} ~ yz$上で考えるとうまくいきます。 もう少し具体的には、次の手順を踏むことで答えることができます。 $x ~ \\mathrm{mod} ~ yz$を求める。 それを$y$で割る。 正当性を追っていきます。 除法定理より、次を満たす整数$q, ~ r$の組がただ一つ存在します。 $x = q(yz) + r$ $0 \\leq r \u0026lt; yz$ ちなみに$r = x ~ \\mathrm{mod} ~ yz$です。 ここで、$x\\%y = 0$を仮定しているので、必ず$r\\%y = 0$となっています。 両辺$y$で割ります。 $$ \\begin{equation} \\frac{x}{y} = qz + \\frac{r}{y} \\end{equation} $$ です。 ここから少し定義に戻って確認します。 $\\dfrac{x}{y} ~ \\mathrm{mod} ~ z$を求めるとは $$ \\begin{equation} \\dfrac{x}{y} = q\u0026rsquo;z + r\u0026rsquo; ~ \\left( 0 \\leq r\u0026rsquo; \u0026lt; z \\right) \\end{equation} $$ なる$r\u0026rsquo;$を求めることです。 ここで、除法定理よりこのような整数の組$(q\u0026rsquo;, r\u0026rsquo;)$はただ一つに定まります。 さて、式(1)を見てみましょう。 $0 \\leq r \u0026lt; yz$でありますから、$0 \\leq \\dfrac{r}{y} \u0026lt; z$であることが分かります。 式(2)と見比べてみましょう。$r\u0026rsquo; = \\dfrac{r}{y}$となっていることが確認できます。 なんということでしょう。求めることができてしまいました。除法定理が強力すぎますね。 応用例 実際にこのテクニックを使える問題を2問紹介します。 ARC111A - Simple Math 2 解法\r$10^N = qM + r ~ (0 \\leq r \u003c M)$と表すと、\r$\\left\\lfloor \\dfrac{10^N}{M} \\right\\rfloor = \\left\\lfloor \\dfrac{qM + r}{M} \\right\\rfloor = q$\rであるから、解は$q\\%M$です。\rこれをもとに変形していきます。\r$$ qM = 10^N - r $$ $$ q = \\frac{10^N-r}{M} $$ ここまで変形すると今回のテクニックに帰着します。 求めたいのは$q ~ \\mathrm{mod} ~ M$ですが、$M$は$\\mathrm{mod} ~ M$上で逆元を持ちません。 また、$10^N-r$も大きすぎて陽に求めるのは無理です。 そこで、$(10^N - r) ~ \\mathrm{mod} ~ M^2$を計算してから最後に$M$で割ってやるとうまくいきます。 実装例(一部抜粋) void solve (long N, int M) { // 10^N = qM + r (0\u0026lt;=r\u0026lt;M) を得たとき、解はq%M // 両辺Mで剰余をとってみると、 (10^N)%M = r%M // 条件より、(10^N)%M = r // 典型テク: mod MK (Mは最後に求めたい剰余、Kは割りたいけど法と互いに素でない数) で考える。 long ans = modPow(10, N, M^^2); ans -= modPow(10, N, M); if (ans \u0026lt; 0) { ans += M^^2; } ans /= M; writeln(ans); } ABC293E - Geometric Progression 解法\r解法がたくさんありますが、kyopro_friendsさんのユーザー解説と同じ方法です。\r丁寧に式変形を追っていきます。 $S(x) \\coloneqq \\displaystyle\\sum_{i=0}^{x}A^i$と定めます。 $0 \\leq N$を用いて、 $$ \\begin{alignat*}{3} A \\times S(N) \u0026amp;= \u0026amp;\u0026amp;A^1 + A^2 + \\cdots + A^N-1 + A^N + A^{N+1} \\\\ S(N) \u0026amp;= A^0 + \u0026amp;\u0026amp;A^1 + A^2 + \\cdots + A^N-1 + A^N \\\\ \\end{alignat*} $$ が成立します。そこで、 $$ A \\times S(N) - S(N) = A^{N+1} - A^0 $$ となります。$S(N)$でくくると、 $$ (A-1) \\times S(N) = A^{N+1} - 1 $$ です。$A-1 \\neq 0$ならば、両辺を割れて、 $$ S(N) = \\frac{A^{N+1}-1}{A-1} $$ を得ます。 さて、今回求める値は$S(X-1) ~ \\mathrm{mod} ~ M$にほかなりません。$A-1 \\neq 0$のとき、$0 \\leq X-1$なので、上式を適用できます。 $$ S(X-1) = \\frac{A^X-1}{A-1} $$ ここで、$A-1$は$\\mathrm{mod} ~ M$上で逆元を持つとは限りません。今回のテクを使いましょう。 つまり、$\\mathrm{mod} ~ M(A-1)$で考えるとうまくいきます。 注意点として、この値は法としてはかなり大きくなる(それでも十分常識の範囲ですが)ので、 計算途中で64bit整数型を超える可能性が高いです。128bit整数や、多倍長整数を使いましょう。 多倍長整数とはいえ、そこまで桁数は大きくならないので十分高速です。 よくわからない人はpythonを使うとよいです。 また、$A-1 = 0$の時はすべての項が1になるため、簡単に計算できます。 実装例(一部抜粋) void solve (int A, long X, int M) { // 解は (A^x - 1) / (A - 1) // 場合分けが必要なケース if (A == 1) { writeln(X%M); return; } BigInt a = A, x = X, m = M; BigInt ans = std.bigint.powmod(a, x, m*(a-1)) - 1; if (ans \u0026lt; 0) ans += m*(a-1); ans /= A-1; writeln(ans); } 補足 問題2の解法説明で、 「逆元を持つとは限りません」と書きましたが、逆元を持っていてもよいことに注意してください。 正当性の証明のパートを見ればわかるように、法と除数の関係性は正当性を示すのに用いていないためです。 もちろん$\\mathrm{gcd}(M, A-1)$を計算して、逆元を持つ場合はそちらを経由するという方法でも解けます。 また、問題2に関しては、行列累乗による$O(\\log(X))$解法や、平方分割による解法など勉強になる解法がたくさん紹介されています。 余裕のある人はぜひ学んでみてください。(ちなみに私は学べてないです。コーナーで差をつけろ！) 終わりに いつかまとめようと思っていたネタです。 ほんの思い付きで書き始めたつもりが約2時間たっていて現在深夜1時です。 助けてくれ。 このアイディア自体はまさに上で紹介したABC293Eのユーザー解説から得たものです。 かなり行間が広いと感じたので、そこを埋める目的で作りました。 なので、この主張がどこまで一般化できるのかなどは私はわかっていません。 誤りがありましたら指摘していただければありがたいです。"
  },
  {
    url: "/post/floyd-warshall/",
    title: "ワーシャル・フロイド法について調べて、納得したこと",
    date: "2023-10-02T00:00:00Z",
    body: "ワーシャル・フロイド法について調べて、納得したこと はじめに 辺に任意の重みがある$N$頂点有向グラフ(ネットワーク)において、負の長さの閉路が存在しないとき、 全点対の最短経路を$O(N^3)$時間で求めるワーシャル・フロイド法と呼ばれるアルゴリズムが存在する。 本稿では、筆者がワーシャル・フロイド法について調べ、理解したことを記録する。 ワーシャル・フロイド法でできるもの 負閉路が存在しないネットワークにおいて、任意の2頂点間の最短経路を求める。 頂点数を$N$としたとき、空間$O(N^2)$と時間$O(N^3)$を要する。 アルゴリズムの詳細 以降、頂点のインデックスは0を基準とする。 また、頂点iから頂点jへの辺の重みを$w_{i,j}$とする。 $\\mathrm{dist}[i][j]:=$「頂点iから頂点jへの最短経路」とする。 最初、$\\mathrm{dist}[i][j]$を次のように初期化する。 $$ \\mathrm{dist}[i][j] = \\begin{cases} w_{i,j} \u0026amp; \\text{if ~ $i$から$j$への辺が存在,}\\\\ \\infty{} \u0026amp; \\text{if ~ $i$から$j$への辺が存在しない,} \\\\ 0 \u0026amp; \\text{if ~ $i = j$.} \\end{cases} $$ $k = 0, 1, \\cdots{} N-1$に対して、順に次の手順を行う。 全ての$0 \\leq{} i, ~ j \\leq{} N-1$の組に対して、 $$ \\mathrm{dist}[i][j] \\leftarrow{} \\min{}(\\mathrm{dist}[i][j], ~ \\mathrm{dist}[i][k] + \\mathrm{dist}[k][j]) $$ 以上を終えたとき、$\\mathrm{dist}[i][j]$は頂点iから頂点jへの最短経路長が入っている。 アルゴリズムの説明 下準備として、与えられたネットワークの辺が存在しない頂点対には距離無限大の辺が存在するとみなす。 こうすると、N頂点有向完全グラフになる。 そして、到達可能性を距離が有限であるかどうかで判定するとする。 このアルゴリズムは次の部分問題を用いた動的計画法とみなせる。 番号k以下の頂点のみを経由するとき、頂点iから頂点jへの最短経路はいくらか？ この問題が解けるとすると、k=N-1の問題に対する解が求めたい解そのものである。 このアルゴリズムを理解する鍵は、あるkとk+1における問題を考えることであると思う。 適当なkに対して問題を考える。 頂点iから頂点jへの最短経路は次のような構造になっている。 頂点i -\u0026gt; (頂点i, jを除いたk以下の頂点集合の部分集合の順列) -\u0026gt; 頂点j k+1に対して問題を考える。 kに対する問題が解けているという仮定のもとで議論を進める。 このとき、新しく最短経路となりうるのは、途中経路に頂点k+1を含むものに限られる。 (なぜなら、k以下に限った解は上の部分問題で解けているから) つまり、最短経路は次のような構造になっている。 頂点i -\u0026gt; (頂点i, jを除いたk以下の頂点集合の部分集合の順列) -\u0026gt; 頂点k+1 -\u0026gt; (頂点i, jを除いたk以下の頂点集合の部分集合の順列) -\u0026gt; 頂点j ここで、負閉路が存在しないことを仮定しているため、 上の経路が最短になるのは、i-\u0026gt;k+1とk+1-\u0026gt;jの経路が最短になるときである。 なぜなら、そうでない場合は経路を最短のものに変えることで距離を必ず改善できるからである。 さて、i-\u0026gt;k+1とk+1-\u0026gt;jの最短経路は、kに対しての部分問題を解いたときにすでに解けていることに気づくだろうか？ わからない人は、部分問題の設定を見直してみてほしい。 したがって、k+1における問題は $$ \\mathrm{dist}[i][j] = \\min(\\mathrm{dist}[i][j], ~ \\mathrm{dist}[i][k+1] + \\mathrm{dist}[k+1][j]) $$ という遷移で解けることがわかる。 まとめ ここまで分かったことをまとめる。 解きたい問題は、k=N-1のときの部分問題である。 kに対して問題が解けるならば、k+1に対して問題が解ける。 あと必要なのは、一番最初のケースを解けるのか？ということである。 k=-1を考える。 これは、始点と終点以外の頂点を一切経由しないときの最短経路問題であり、この部分問題のベースケースである。 この問題は明らかに頂点iから頂点jへ辺が存在するかどうかを見るだけで解くことができる。 以上より、帰納的に問題が解けることが理解できる。 負閉路が存在するとき 負閉路が存在するとき、そこを通ることができる経路に対する最短経路はいくらでも縮めることができる。 しかし、このときワーシャル・フロイド法は$-\\infty$を返さないことがあり得る。(というか、まず$-\\infty$にはならない) 遷移を見ればわかるとおり、ワーシャル・フロイド法により求まるのは最短「パス」であるからである。 つまり、真の最短経路が閉路を含む(同じ頂点を2回以上通る)ものは正しく結果を求めることができない。 追記(2023-10-05) 以下、アルゴリズムロジックからの情報を追加します。 疲れているときに書いたので、普段以上に内容が怪しいかもしれません。ご注意ください。 負閉路の検出 負閉路が含まれているとき、閉路中の任意の一つの頂点をiとする。すると、iからiへの最短パスは総和が最小となる負閉路をぐるっと一周回ったものが採用される。 負閉路がない時、$\\mathrm{dist}[i][i] = 0$となるはずなので、これを用いて$O(N)$で検出できる。 bool hasNegativeCycle () { for (int i = 0; i \u0026lt; N; i++) { if (dist[i][i] \u0026lt; 0) return true; } return false; } 最短距離の一つを復元 $\\mathrm{prev}[i][j] \\coloneqq$ ($i$から$j$への最短経路で、$j$の一つ前にいた頂点) とすると、空間$O(N^2)$を用いて復元できる。 $\\mathrm{prev}$は$\\mathrm{dist}$と一緒に更新するとよい。 $\\mathrm{prev}$の初期値は次のようになる。 $$ \\mathrm{prev}[i][j] \\coloneqq \\begin{cases} i \u0026amp; \\text{if $(i = j) \\lor (iからjへ辺が存在する)$,} \\\\ -1 \u0026amp; \\text{otherwise.} \\end{cases} $$ -1は異常値として採用しています。 更新は、$\\mathrm{dist}$と一緒に行います。 for (int k = 0; k \u0026lt; N; k++) { for (int i = 0; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; N; j++) { if (dist[i][k] \u0026lt; int.max \u0026amp;\u0026amp; dist[k][j] \u0026lt; int.max \u0026amp;\u0026amp; dist[i][k] + dist[k][j] \u0026lt; dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; prev[i][j] = prev[k][j]; } } } 復元は次のようになります。 int[] restorePath (int start, int end) { if (prev[start][end] == -1) return []; int[] res; int cur = end; while (cur != start) { res ~= cur; cur = prev[start][cur]; } res ~= start; res.reverse; return res; } 実装例 次の問題に回答するD言語によるコードを示す。(本問題はワーシャル・フロイド法を用いなくても解けるが、簡単のため採用した。) 問題 頂点$U$から頂点$V$への最短経路を出力せよ。到達不能である場合、-1を出力せよ。 入力形式 N M\rU V\ru_1 v_1 w_1\ru_2 v_2 w_2\r.\r.\r.\ru_M v_M w_M\rimport std; void main () { /* input N, M */ int N, M; readln.read(N, M); int U, V; readln.read(U, V); U--, V--; // 0-indexed /* difine dist[][] */ int[][] dist = new int[][](N, N); foreach (i; 0..N) foreach (j; 0..N) dist[i][j] = int.max; foreach (i; 0..N) dist[i][i] = 0; /* input all edge */ foreach (_; 0..M) { int u, v, w; readln.read(u, v, w); u--, v--; dist[u][v] = w; } solve(N, M, U, V, dist); } void solve (int N, int M, int U, int V, int[][] dist) { /* Floyd-Warshall Algorithm */ for (int k = 0; k \u0026lt; N; k++) { for (int i = 0; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; N; j++) { if (dist[i][k] \u0026lt; int.max \u0026amp;\u0026amp; dist[k][j] \u0026lt; int.max) { dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } } } /* output */ if (dist[U][V] \u0026lt; int.max) { writeln(dist[U][V]); } else { writeln(-1); } } ジャッジはないし、veryfyもないです。何ならコンパイルすらしてないので間違っているかもしれないですが、参考程度でお願いします。 練習問題 本記事を読んだ方は、ぜひ挑戦してみてほしい。 大抵の場合、全点対最短距離に帰着するまでのパートはかなり明らかなことが多いので、ネタバレはそこまで問題ではないと思う。 ABC208D ABC79D 参考文献 浅野 孝夫. グラフ・ネットワークアルゴリズムの基礎 数理とCプログラム(初版). 近代科学社, 2017. 様々なグラフアルゴリズムを簡潔に紹介しています。グラフ理論による厳密な証明などは比重が小さく、数学系でない人も気軽に内容を浚える本だと思います。 rp523. \u0026ldquo;ワーシャルフロイド法がなぜうまくいくのか、改めて考えてみる\u0026rdquo;. qiita. 2022. https://qiita.com/rp523/items/8fba3882c4a6ea203757, (2023-10-02閲覧). この動的計画法がどのようにして状態を圧縮しているのかを丁寧に説明しています。 吉田 雄真. \u0026ldquo;参考文献の書き方\u0026rdquo;. 新潟大学付属図書館. 2021. https://www.lib.niigata-u.ac.jp/learning_support/doc/20210709-3.pdf, (2023-10-02閲覧). 参考文献リストはこの文献を参考に書きました。"
  },
  {
    url: "/post/abc322/",
    title: "ABC322参加記録",
    date: "2023-09-30T00:00:00Z",
    body: "ABC322参加記録 はじめに 本稿は、2023/09/30に行われたABC322の参加記録です。 戦績 今回の提出状況は次の通りです。 AからDまでの5完でした。パフォーマンス1480で、レーティング変化は1195 =\u0026gt; 1227でした。 所感 遂に水色乗れました。うれしいです。 今回はDEがかなり実装が大変でした。 D問題TLEしてしまって、あきらめそうになりましたが、定数倍高速化をいろいろやってみたら通りました。 E問題はあまり賢くない実装方針をとってしまいかなり大変でしたが、何とか通せてよかったです。 解法 A - First ABC2 問題へのリンク nの定義域が明示されているのは楽でいいですね。 前から力任せ法で見ていけば十分高速です。 スライスがある言語なら、スライスを用いるとちょっと楽かもしれないです。 import std; void main () { int N = readln.chomp.to!int; string S = readln.chomp; solve(N, S); } void solve (int N, string S) { foreach (i; 0..S.length-2) { if (S[i..i+3] == \u0026#34;ABC\u0026#34;) { writeln(i+1); return; } } writeln(-1); } B - Prefix and Suffix 問題へのリンク SがTの接頭辞であるかどうか？とSがTの接尾辞であるか？を判定する方法があればif文で解けます。 N、Mは十分小さい上、制約でSの長さはT以下であることが保証されているので、全部言われたとおりに見ていけばよいです。 実装ではスライスを用いていますが、普通にfor文回しても解けます。 この場合、関数化するとちょっと楽だと思います。 import std; void main () { int N, M; readln.read(N, M); string S = readln.chomp; string T = readln.chomp; solve(N, M, S, T); } void solve (int N, int M, string S, string T) { int ans = 3; if (S.length \u0026lt;= T.length \u0026amp;\u0026amp; T[0..S.length] == S \u0026amp;\u0026amp; T[$-S.length..$] == S) ans = 0; if (S.length \u0026lt;= T.length \u0026amp;\u0026amp; T[0..S.length] == S \u0026amp;\u0026amp; T[$-S.length..$] != S) ans = 1; if (S.length \u0026lt;= T.length \u0026amp;\u0026amp; T[0..S.length] != S \u0026amp;\u0026amp; T[$-S.length..$] == S) ans = 2; writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - Festival 問題へのリンク 二分探索を用いてi\u0026lt;=Ajが初めて成立するポイントを探します。 AM=Nなので、境界を多少雑に扱っても解けます。 普段ならAM\u0026lt;iである可能性があるので、判定関数をA[M\u0026lt;x]=infとするのですが、今回は必要ないです。 import std; void main () { int N, M; readln.read(N, M); int[] A = readln.split.to!(int[]); solve(N, M, A); } void solve (int N, int M, int[] A) { bool f (int i, int x) { return i \u0026lt;= A[x]; } for (int i = 1; i \u0026lt;= N; i++) { int ok = M-1, ng = -1; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng)/2; if (f(i, mid)) ok = mid; else ng = mid; } writeln(A[ok]-i); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Polyomino 問題へのリンク 少し大きな台紙を用意して、はみだし、かぶりのないように張り付けて条件を満たすかを見ていく全探索をしました。 3つあるミノのうちの1つは向きを固定してよいため、そこで少し高速化しています。 1300msかかってるの私だけっぽいので、もう少しマシな解き方を復習しようかなと思います。 import std; void main () { char[][][] mino = new char[][][](3, 4, 0); foreach (i; 0..3) foreach (j; 0..4) mino[i][j] = readln.chomp.dup; solve(mino); } void solve (char[][][] mino) { char[][] field = new char[][](12, 12); void AllClear () { foreach (ref f; field) f[] = \u0026#39;.\u0026#39;; } bool isOver () { foreach (i, ff; field) foreach (j, f; ff) { if (f == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; (i \u0026lt; 4 || 8 \u0026lt;= i || j \u0026lt; 4 || 8 \u0026lt;= j)) return true; } return false; } bool paste (int idx, int i, int j) { foreach (y; i..i+4) foreach (x; j..j+4) { if (mino[idx][y-i][x-j] == \u0026#39;.\u0026#39;) continue; if (mino[idx][y-i][x-j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; field[y][x] == \u0026#39;#\u0026#39;) return false; if (mino[idx][y-i][x-j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; (y \u0026lt; 4 || 8 \u0026lt;= y || x \u0026lt; 4 || 8 \u0026lt;= x)) return false; if (mino[idx][y-i][x-j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; field[y][x] == \u0026#39;.\u0026#39;) field[y][x] = \u0026#39;#\u0026#39;; } //return !isOver(); return true; } bool check () { int count = 0; foreach (i, ff; field) foreach (j, f; ff) if (f == \u0026#39;#\u0026#39;) count++; return count == 16; } // 始点縦と横 foreach (i1; 0..7) foreach (j1; 0..7) { // 1ピースは向き確定でもよい。 //foreach (_1; 0..4) { mino[0] = mino[0].rotate; foreach (i2; 0..7) foreach (j2; 0..7) foreach (_2; 0..4) { mino[1] = mino[1].rotate; foreach (i3; 0..7) foreach (j3; 0..7) foreach (_3; 0..4) { mino[2] = mino[2].rotate; AllClear(); if (paste(0, i1, j1) \u0026amp;\u0026amp; paste(1, i2, j2) \u0026amp;\u0026amp; paste(2, i3, j3) \u0026amp;\u0026amp; check()) { writeln(\u0026#34;Yes\u0026#34;); return; } } } } writeln(\u0026#34;No\u0026#34;); } char[][] rotate (char[][] X) { if (X.length == 0) return []; char[][] res = new char[][](X[0].length, X.length); foreach (i; 0..X.length) foreach (j; 0..X[i].length) res[$-j-1][i] = X[i][j]; return res; } E - Product Development 問題へのリンク こういうのは大抵貪欲は無理だと相場が決まっています。また、とるかとらないかのO(2N)全探索もNが少し大きすぎます。 そこで、パラメータの取りうる値が小さいことに着目します。 一つのパラメーターに対して、P以上になったものはすべて同一視してよいため、本質的に区別すべき状態はパラメーターがP未満のもののみです。 いくつかの開発案を採択したとき、ありうる状態はパラメーター1つあたり0からPまでのP+1通りになり、パラメーターがK個独立に存在するので、(P+1)K通りになります。 これを持ちながら多次元部分和問題のようなことをやります。 私は全ケースK=5に帰着させて解きました。具体的には、K\u0026lt;jであってAi,jが存在しない時、Ai,j=Pと定義してあります。 こうすることで、本来存在しない架空のパラメータを一つ以上の開発案をとれば必ず達成できるとみなしています。 こういうdpは、多次元空間をイメージするよりも「ノードの識別子(一意に特定するために必要なタグ)がK種類ある」という理解が良いと思います。 一応この手のdpは過去にたくさん出題例があります。 その一部を紹介します。 ABC219D yukicoder No.2317 import std; void main () { int N, K, P; readln.read(N, K, P); int[] C = new int[](N); int[][] A = new int[][](N, 0); foreach (i; 0..N) { int[] input = readln.split.to!(int[]); C[i] = input[0]; A[i] = input[1..$]; } solve(N, K, P, C, A); } void solve (int N, int K, int P, int[] C, int[][] A) { long[][][][][][] dp = new long[][][][][][](N+1, P+1, P+1, P+1, P+1, P+1); // dp[i][j][k][l][m] := (i, j, k, l, m)を達成できる最小コスト(ただし、パラメータ=5は達成できている) foreach (dim; 0..N+1) foreach (i; 0..P+1) foreach (j; 0..P+1) foreach (k; 0..P+1) foreach (l; 0..P+1) dp[dim][i][j][k][l][] = long.max; dp[0][0][0][0][0][0] = 0; int f (int[] a, int idx) { if (idx \u0026lt; a.length) return a[idx]; return P; } foreach (dim, a; A) foreach (i; 0..P+1) foreach (j; 0..P+1) foreach (k; 0..P+1) foreach (l; 0..P+1) foreach (m; 0..P+1) { if (dp[dim][i][j][k][l][m] == long.max) continue; // とる dp[dim+1][min(f(a, 0) + i, P)][min(f(a, 1) + j, P)][min(f(a, 2) + k, P)][min(f(a, 3) + l, P)][min(f(a, 4) + m, P)] = min(dp[dim][i][j][k][l][m] + C[dim], dp[dim+1][min(f(a, 0) + i, P)][min(f(a, 1) + j, P)][min(f(a, 2) + k, P)][min(f(a, 3) + l, P)][min(f(a, 4) + m, P)]); // とらない dp[dim+1][i][j][k][l][m] = min(dp[dim+1][i][j][k][l][m], dp[dim][i][j][k][l][m]); } if (dp[N][P][P][P][P][P] == long.max) { writeln(-1); } else { writeln(dp[N][P][P][P][P][P]); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 急いで解いたので、一部コメントが間違っています。そもそももう少しましな方針があるので、そちらを参考にすべきです。 終わりに 最近レーティングに取り憑かれている実感があったので、とりあえず水色に乗って一区切りつけることができてよかった。 純粋にProblem Solvingを楽しめるように努力したいと思った。プロコンを嫌いにならないためにも。"
  },
  {
    url: "/post/abc270e/",
    title: "ABC270E - Apple Baskets on Circle",
    date: "2023-09-26T00:00:00Z",
    body: "ABC270E - Apple Baskets on Circle 問題概要 問題へのリンク 円環状に並べてある$1$から$N$の番号が付いた$N$個のかごがある。 かごは$1$から$N$まで順番に並んでおり、かご$N$の隣にはかご$1$がある。 かご$i$にはりんごが$A_i$個入っている。 高橋君は、以下の行動を繰り返す。 目の前にあるかごの中にりんごがあれば$1$個かごから取り出して食べる。その後、りんごを食べたかどうかにかかわらず、右隣のかごの前に移動する。 高橋君がちょうど$K$個のりんごを食べた時点で、各かごに入っているりんごの数を求めよ。 制約 $1 \\leq{} N \\leq{} 10^5$ $0 \\leq{} A_i \\leq{} 10^{12}$ $1 \\leq{} K \\leq{} 10^{12}$ $K \\leq{} \\sum A_i$ 解法 $K$の値が非常に大きいため、高橋君の動きをシミュレートすることはできない。 そこで、高橋君の動きを少しずつまとめよう。 例えば、ある時点において$0$個を除いたりんごの最小値が$x$個であって、かつ$1$個以上のりんごが入ったかごが$y$個であったとする。 この時、少なくとも$x$周している間は$y$は一定になるはずであるから、素直にシミュレートすると$x$周必要なところを$1$周にまとめることができる。 $x$周しても$A_i$における大小関係は逆転しない($A_i \u0026lt; A_j$が$A_i = A_j$になることはあるが、$A_i \u0026lt; A_j$が$A_j \u0026lt; A_i$となることはない)ので、次の最小値$x$を容易に計算することができる。 また、$x$周している間に$K$個を超えてしまうときは、$K$個を超えないで何周できるかを計算するとよい。 具体的には、今まで食べたりんごを$\\mathrm{sum}$として、$\\lfloor{} (K-\\mathrm{sum})/y \\rfloor{}$とすればよい。 最後の一周は高々$N$回の操作で終わるので、シミュレートすればよいだろう。 そこで、次の解法を得る。 解法1 詳しいアルゴリズムは言語による説明よりもソースを見る方が早いかと思うので、D言語による実装を掲載する。 Remainingはその時点で$0$個以上のりんごが入っているかごの数である。 また、現時点で最小のりんごの数を得るために優先度付きキューを利用している。 これは上で説明した大小関係が保存されることを利用している。 void solve (int N, long K, long[] A) { long sum = 0; long Remaining = 0; foreach (a; A) if (0 \u0026lt; a) Remaining++; BinaryHeap!(pair[], \u0026#34;b.val \u0026lt; a.val\u0026#34;) PQ = []; foreach (i, a; A) PQ.insert(pair(cast(int) i, a)); while (sum \u0026lt; K) { auto head = PQ.front; PQ.removeFront; with (head) { if (A[idx] == 0) continue; if (K \u0026lt;= sum + Remaining) { // 一周とれば終了 int i = 0; while (sum \u0026lt; K) { if (0 \u0026lt; A[i]) sum++, A[i]--; i++; } break; } if (sum + Remaining \u0026lt; K) { // A[idx]が最小なので、これを上限にして、できるだけとる long take = min(A[idx], (K-sum)/Remaining); sum += Remaining*take; foreach (ref a; A) if (0 \u0026lt; a) { a -= take; if (a == 0) Remaining--; } } } } // output foreach (i; 0..A.length) write(A[i], (i == A.length-1 ? \u0026#34;\\n\u0026#34; : \u0026#34; \u0026#34;)); } この解法は確かに正しい解を得るが、実は$\\text{worst} ~ O(N^2)$となっている。(筆者はこれに気づかずに2TLEした。) 例えば$A_i = i$であって、$K = \\sum A_i$であるときがこのケースに当たる。 更新が$N$行われて、かつ更新一回で$O(N)$回の操作が必要であるからだ。 素直にシミュレートするよりはかなり高速化したが、これでは間に合わない。 解法2 さて、少し突飛な発想であるかもしれないが、$x$周したときに何個りんごをとれるかを考えよう。 $x$個に満たないかごからは$A_i$個までしかとれないので、$\\sum \\min{} (x, A_i)$個ということになる。 この値は$x$に対して(適切な区間で)狭義単調増加する。 すると、この値が$K$を超えるかどうかで二分探索ができることが分かる。 要するに、何周までなら$K$を超えないのかを高速に求めることができる。 最後の一周は素直にシミュレートすればよいので、これで解ける。 時間計算量は$O(N \\log{} (\\max{} A_i))$である。 以下にD言語による実装例を載せる。 void solve2 (int N, long K, long[] A) { // A[i]からとれるならX個とるとするとき、その総和がKを超えるかどうかで二分探索 // 二分探索: f(x) := sum( min(x, A[i]) ) に対して、f(ok) \u0026lt;= K \u0026lt; f(ng) // ok \u0026lt;- [0, max(A)] long f (long x) { long sum = 0; foreach (a; A) sum += min(x, a); return sum \u0026lt;= K; } long ok = 0, ng = 10L^^12+1; while (1 \u0026lt; abs(ok-ng)) { long mid = (ok+ng)/2; if (f(mid)) { ok = mid; } else { ng = mid; } } long sum = 0; // 少なくとも(とれるなら)ok個とってよい。 foreach (ref a; A) sum += min(a, ok), a -= min(a, ok); // 端数を一周して合わせる { int i = 0; while (sum \u0026lt; K) { if (0 \u0026lt; A[i]) sum++, A[i]--; i++; } } // output foreach (i; 0..A.length) write(A[i], (i == A.length-1 ? \u0026#34;\\n\u0026#34; : \u0026#34; \u0026#34;)); } 振り返り 解法2は解法1をさらにまとめた形だということもできるだろう。 筆者がこの解法に至るまでに次のような手順を踏んだ。 (解法1がTLEして)$A$がばらばらの値の時にまずいのか\u0026hellip; なんか何回も同じ要素を引き算してんな\u0026hellip;どうにかならんかな\u0026hellip; $0$個になったかごは無視してもいいから\u0026hellip;(天啓が下りてきて)可能なら$x$個とる方針で行けば二分探索できそう？ \u0026hellip;うまく言語化できない。というよりは、どうやって思いついたのか詳細にはわからないというのが正しいのか\u0026hellip; ただ、やはり最後の一周とそれまでを区別して考えるのは大事なポイントだと思う。 もし各かごにりんごが無限に入っていたとしたらこのように「何周するのか」に着目する解法を容易に構成できると思う。 が、今回は、りんごの減少に伴って変化が生じるので発想の難易度が上がっていると思った。 より易しい問題設定を考えたり、過去に解いた問題の記憶をためることが重要なのかなと思う。 (2023-09-28追記) 深夜に考えていたら少し思いついたので補足します。 この手の問題は「解の構造」を考えることが大事だと思います。 K個目のりんごを食べるときにかごのりんごがどのように減っているかを考えると、 0になるまで減る、または今まで周回した分だけ減るということが分かります。 すると、何周したかに着目できるのかなと思いました。 何周したかに着目できれば二分探索に帰着するのはそんなに難しくないと思います。 しかし、この手の問題は大抵シミュレーションの高速化で解けることが多いので、解法1を組み切る力も必要かなと思います。 (もちろん、シミュレーションの最悪計算量を一発で見抜く力も) 類似問題 ABC216E"
  },
  {
    url: "/post/abc202d/",
    title: "ABC202D - aab aba baa",
    date: "2023-09-24T00:00:00Z",
    body: "ABC202D - aab aba baa 問題概要 問題へのリンク A個のaとB個のbからなる文字列であって、辞書順でK番目のものを求めよ。 制約 1 \u0026lt;= A, B \u0026lt;= 30 辞書順でK番目の文字列が存在する。 解法 まず、問題文の条件を満たす文字列は$\\displaystyle\\frac{(A+B)!}{A!B!}$通り存在する。 これは、単にA+B個を並べたものからAの重複とBの重複を除いたものである。 また、これは二項係数$\\displaystyle\\binom{A+B}{A} = \\binom{A+B}{B}$でもあり、 A+B個の枠のうち、AかBを入れる場所を決めれば文字列が一つ定まると解釈することもできる。 制約下で最も種類数が多くなるのはA=B=30のときで、これは$\\displaystyle\\frac{60!}{30!30!} = \\binom{60}{30} = 118264581564861424$通りである。 したがって、文字列をすべて列挙して解くことはできない。 そこで、先頭からどの文字を使うかを決めていくことを考える。 ちなみにこれは辞書順を考えるときの典型テクニックらしいので、ある程度パターンマッチングとして選択肢に入れておくようにすると良いかもしれない。 先頭にaを入れた時を考える。 このとき、残るA-1個のaとB個のbで作ることができる文字列の種類は$\\displaystyle\\binom{A+B-1}{A-1}$通りになる。 もしKがこの値よりも大きければ、先頭にaを入れた時点でK番目に到達できないことが確定する。 つまり、先頭の1文字目は次の条件分岐で決定できる。 $K \\leq{} \\displaystyle\\binom{A+B-1}{A-1}$であるとき、a そうでないとき、b 続けて次の文字を決定したいが、その前にやることがある。 上記の条件分岐でbを先頭に入れた場合、aが先頭であったときにあり得た$\\displaystyle\\binom{A+B-1}{A-1}$通りは 必ず自分よりも辞書順で若いはずである。 つまり、現時点で少なくとも$\\displaystyle\\binom{A+B-1}{A-1}$通り分のパディングを持っていることになる。 これを記録しておく必要がある。 さて、2文字目を決定しよう。 実は2文字目もほとんど同様に決めることができる。 1文字目との変化は 1文字目にとった文字の分減らして考えないといけない パディングを忘れないようにする という点だけである。 つまり、2文字目は次の条件分岐で決定できる。 $$ now = \\begin{cases} \\displaystyle\\binom{A+B-1}{A-1} \u0026amp; \\text{if 先頭がbである。} \\\\ 0 \u0026amp; \\text{if 先頭がaである。} \\end{cases} $$ として、先頭の文字に合わせて$A \\leftarrow{} A-1$または$B \\leftarrow{} B-1$とする。 $K \\leq{} now + \\displaystyle\\binom{A+B-1}{A-1}$であるとき、a そうでないとき、b とできる。 これを繰り返すことで文字列を決定できる。 注意として、aかbどちらかを使い切ってしまえば文字列が確定するので、最後まで手順を繰り返す必要はない。 時間計算量は、二項係数1回求める時間を$O(x)$と置くと、$O(x\\cdot{}\\mathrm{max}(A, B))$である。(多分) 提出 import std; void main () { int A, B; long K; readln.read(A, B, K); solve(A, B, K); } void solve (int A, int B, long K) { // 先頭からaとbどっちにするか決めていく。 // n_i個のアルファベットA_i(1\u0026lt;=i\u0026lt;=n)で構成される文字列の種類は多項係数の数だけ存在するので、頭の一つを決めれば後ろに何個存在するかがわかる。 long now = 0; char[] ans; ans.reserve(A+B); while (0 \u0026lt; A \u0026amp;\u0026amp; 0 \u0026lt; B) { if (now + nCk(A+B-1, A-1) \u0026lt; K) { now += nCk(A+B-1, A-1); ans ~= \u0026#39;b\u0026#39;; B--; } else { ans ~= \u0026#39;a\u0026#39;; A--; } } foreach (_; 0..A) ans ~= \u0026#39;a\u0026#39;; foreach (_; 0..B) ans ~= \u0026#39;b\u0026#39;; writeln(ans); } long nCk (int n, int k) { assert(0 \u0026lt;= n \u0026amp;\u0026amp; 0 \u0026lt;= k); if (n \u0026lt; k) return 0L; long res = 1; for (int i = 1; i \u0026lt;= k; i++) { res *= n-i+1; res /= i; } return res; } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 発展 3種類以上の文字を含む場合にも同様の手順で辞書順K番目の文字列を求めることができる。 $m$種類の文字に対して、文字$c_i$が$N_i$個含まれる文字列の種類数は多項係数 $$ \\binom{\\sum{}N_i}{N_1, N_2, \\dots{}, N_m} = \\frac{(\\sum{}N_i)!}{\\prod{}N_i!} $$ により求めることができるから、これを用いて上のアルゴリズムを適用すれば良い。 しかし、現実的には多項係数が非常に大きくなるので問題には出にくいと思う。"
  },
  {
    url: "/post/abc321/",
    title: "ABC321参加してきた。",
    date: "2023-09-23T00:00:00Z",
    body: "ABC321参加してきた。 久しぶりに参加記録を書きます。 ここ1か月くらい参加記録をずっとさぼっていましたが、hugoに移行したことでだいぶん楽になったので今週はちゃんと書きます。 本稿はABC321の参加記録です。 戦績 今回の提出は以下の通りでした。 今回AからEの5問解くことができました。 所感 今回はD問題まではさっと解法が見えました。 C問題は以前にABCの過去問で広義単調増加列の全探索をしたことがあったので、パッと見た瞬間に全列挙可能だと分かりました。 E問題はエーッ！やりたくないです！みたいな見た目をしていたが、こういう時に後ろの問題を見に行っていいことがあったためしがないので頑張って取り組みました。 雑振り返り A - 321-like Checker 問題文 書いてある通りにチェックしたらOKです。こういう時は文字列として受け取ると楽です。 import std; void main () { string N = readln.chomp; foreach (i; 0..N.length-1) { if (N[i] \u0026lt;= N[i+1]) { writeln(\u0026#34;No\u0026#34;); return; } } writeln(\u0026#34;Yes\u0026#34;); } B - Cutoff 問題文 制約がデカければ面倒くさそうですが、実は簡単な全探索が通ります。 Nラウンド目に0から100点のどれかしか取れないので、最終結果としてあり得るものは高々100通りです。 よって、これらすべてについて問題文の通りにチェックを入れると解けます。 「全部見る」ということで複雑さを全部破壊するのは気持ちよいですね。 import std; void main () { int N, X; readln.read(N, X); int[] A = readln.split.to!(int[]); int[] B; int ans = int.max; for (int i = 0; i \u0026lt;= 100; i++) { B = A.dup; B ~= i; B.sort; int score = 0; for (int j = 1; j \u0026lt; B.length-1; j++) { score += B[j]; } if (X \u0026lt;= score) { ans = min(ans, i); } } if (ans == int.max) { writeln(-1); } else { writeln(ans); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - 321-like Searcher 問題文 実は以前もう少し緩い制約で定義される数を探索する問題を解いたことがあって、その時の記憶が残っていたので即座に全探索の判断をとりました。 上の桁から決めていくような感じでdfsで掘りました。 重複とか怖かったので一応対策しています。 1WAでペナってしまったので、おそらくオーバーフローかな？ import std; void main () { int K = readln.chomp.to!int; solve(K); } void solve (int K) { // 狭義単調減少列は少なかったような気がするので全列挙します。 long[] number; void dfs (long current, int last) { for (int i = 0; i \u0026lt; last; i++) { dfs(10*current+i, i); } if (0 \u0026lt; current) number ~= current; } dfs(0, 10); number = number.sort.uniq.array; writeln(number[K-1]); } D - Set Menu 問題文 こういうのは大抵片方を固定するとよいと相場が決まっています。 実際、この問題においてA[i]を一つ固定すると、必ず和がPを超えるかどうかで境界線を引くことができます。 これを二分探索します。 いちいちBの総和をとっているとO(M^2)が乗ってくるので、累積和で1ケースO(1)に落とします。 import std; void main () { int N, M, P; readln.read(N, M, P); int[] A = readln.split.to!(int[]); int[] B = readln.split.to!(int[]); solve(N, M, P, A, B); } void solve (int N, int M, int P, int[] A, int[] B) { // Aを一つ決めたときに境界線を探す。 long ans = 0; B.sort; long[] cum; cum.reserve(M+1); cum ~= 0; foreach (b; B) { cum ~= cum[$-1]+b; } long f (int idx) { if (idx \u0026lt; 0) return cast(long) -int.max; if (M \u0026lt;= idx) return cast(long) int.max; return B[idx]; } foreach (a; A) { // 二分探索: a+f(ok) \u0026lt;= P, P \u0026lt; a+f(ng) // ただし、f(x\u0026lt;0)=-inf, f(M\u0026lt;=x)=inf int ok = -1, ng = M; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (a+f(mid) \u0026lt;= P) { ok = mid; } else { ng = mid; } } if (ok == -1) { ans += 1L*P*M; } else { ans += 1L*(ok+1)*a+cum[ok+1]; ans += 1L*P*(M-ok-1); } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 一発で通せて本当に良かった。 E - Complete Binary Tree 問題文 制約は載せていませんが、Tが105で、そのほか1018です。 まず、この木がどうなっているのかを図に書いてチェックします。 すると、これは完全二分木になっていることが確かめられます。 さて、制約がクソでかなので、グラフ上で実際にチェックしてやるのは無理です。 完全二分木の何かしらの性質を使います。 しばらく悩んで、例えばX=1で固定だったらどうだろうという発想に至りました。 この時、割と簡単に解けそうだなという感じです。具体的には、最左のノードと最右のノードの番号を持っておいて、(left, rightとします。) left = 2*left; right = 2*right+1; を深さ分だけ続けていけばよさそうです。 途中でN \u0026lt; leftなら解は0で、そうでなければmin(N, right)-left+1になりそうな感じです。 式で書くと分かりにくいですが、実際はずっと15要素の二分木とにらめっこしていました。 というわけで、自分を根とする部分木に対してなら問題が解けました。 頂点1以外は必ず親を持つので、この部分木に対する問題を解くサブルーチンを適切に親ノードを選んで実行する感じで解きました。 import std; void main () { int T = readln.chomp.to!int; foreach (_; 0..T) { long N, X, K; readln.read(N, X, K); long ans = solve(N, X, K); writeln(ans); } } long solve (long N, long X, long K) { // 自分を根とする部分木の数え上げはできそう /* return: 自分を根とする部分木において、自分との距離がdistであるようなものの数を数え上げる。多分logくらい */ long count (long root, long dist) { enforce(0 \u0026lt;= dist); if (N \u0026lt; root) return 0; if (dist == 0) return 1L; long left = root, right = root; while (0 \u0026lt; dist) { left = 2*left; right = 2*right+1; dist--; if (N \u0026lt; left) return 0; } return min(N, right)-left+1; } bool[long] memo; long ans = 0; ans += count(X, K); memo[X] = true; X /= 2; K--; if (K \u0026lt; 0) return ans; while (1 \u0026lt;= X) { if (K == 0) { ans++; break; } memo[X] = true; if ((2*X) !in memo) { ans += count(2*X, K-1); memo[2*X] = true; } if ((2*X+1) !in memo) { ans += count(2*X+1, K-1); memo[2*X+1] = true; } X /= 2; K--; } return ans; } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } これがACをとったコードですが、どのように動くかを具体的に見てみようと思います。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 バックスラッシュが円マークになってしまうのでpreに位置関係を書きました。 一例として、X=6の動作を示します。 以下、countは指定した頂点を根とする部分木に対して答えを返す関数になります。 countにX=6とKを渡します。 X=6をメモっておき、X/=2、K--とします(一つ上の階に上がる) 2Xと2X+1のうち、メモに入っていない方、およびK-1をcountに渡します。また、Xもメモっておきます。 これを1 \u0026lt;= Xである間(根にたどり着くまで)繰り返します。K=0になったりしたときには適切に処理します。 という感じです。これでもれなく探索できます。 計算量はcountが1回につきO(log(N))程度で、Xから1になるまで上に登っていくので、大体クエリ1回あたりO(log^2(N))くらいです。多分。 最初の実装では、countに渡した2Xまたは2X+1のノードが存在しない時にバグっていたようで、なかなか気づかなくて大変でした。 最後何とか気づいてギリギリ通りました。 おそらくもっと良い解法があるので、復習します。 F以降はほぼ見てないです。 感想 Eが解けてよかったー これからもできる範囲で精進頑張ります。"
  },
  {
    url: "/post/hugo-setting/",
    title: "InTheDayDreamをhugoに移行するためにやったことたち",
    date: "2023-09-15T00:00:00Z",
    body: "InTheDayDreamをhugoに移行するためにやったことたち 手動ブログ運営はしんどい！ さて、皆様はhatenablogなどのサービスを全く介さずに、単にインターネット上の置き場所にWebページを展開したことがありますでしょうか？ 私がしばらく運営している当ブログは、github pagesを利用した完全な手動運用のサイトです。 まあこれが辛いんです結構 具体的に何がしんどいのかと言うと、ページ公開に伴う面倒な作業がとにかく多いんですね。 例えば一つ公開したいページがあるとき、色んな所にリンクを貼り付ける必要があります。 また、すべてのCSSや、各ページのヘッダ(htmlの\u0026lt;head\u0026gt;タグの中身)とかも全部用意しなければいけません。 これがやりたいという人はいいですけど、結構面倒くさくて記事更新のモチベーションがゴリゴリ減らされるわけです。 私は現在競技プログラミングに取り組んでいて、新しい知見を得ることが結構ありますが、わざわざ一つの問題に対して記事を建てるなんて面倒くさくてやりたくないわけです。 これはかなりのデメリットです。 私はフロントエンドエンジニアでもなんでもなく、gitの使い方すらガバガバな初心者ですから、大抵の実装はその場しのぎで後からいじるとかはやりたくないわけです。 現在私のブログはもう触りたくないけどなーみたいなゴミがたくさん転がっているひどい現状です。 しかも、折角書いた記事も全然再利用性がないなーと感じています。 私の理想を言うなら、できるだけmarkdownなどでプレーンテキストデータに近い形で記事をおいておきたいわけです。これにスタイルシートとかを当てたり、他のフォーマットに変換するのは割と容易ですし。 というわけで、このあたりの面倒くさい作業をhugoに丸投げしちゃおうと言う感じです。 hugoとは？ The world’s fastest framework for building websites Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. 以下google翻訳 ウェブサイトを構築するための世界最速のフレームワーク Hugo は、最も人気のあるオープンソースの静的サイト ジェネレーターの 1 つです。 Hugo の驚くべきスピードと柔軟性により、Web サイトの構築が再び楽しくなります。 hugo公式サイトより だそうです。すごく簡単に言うと、WordPressなどのようなCMSと違い、設計図のようなものから静的Webサイトを構築するソフトウェアです。 似たようなソフトウェアにjekyllとかがあります。 実は、以前jekyllをワチャワチャしてみようと思ったのですが、その時はよくわからずに諦めてしまったことがあります。 Jekyllなんか知らんけど動かない \u0026mdash; In (@UU9782wsEdANDhp) March 26, 2023 これはjekyllがプログラミング言語rubyとかなり密接につながっていることが原因の一つです。 jekyllはちょっと動かしてみたいなーってだけでなんだか色々インストールだの何だのを要求されます。 私はプログラミングのことなんか全然わかりませんから、普通にキレてやめました。 一方、hugoはあまりややこしいことをしなければgo言語の処理系を用意する必要すらないということで、割と良さそうだなと思って試しています。 もちろんソースからビルドとかしたいなら処理系が必要ですが、各プラットフォーム向けにバイナリが配布されているようなので、それでなんとかします。 let\u0026rsquo;s try! とりあえずバイナリをここからひったくってきます。 Windowsの方などはhugo_extended_0.118.2_windows-amd64.zipっていうやつをパクってきたらいいと思います。(2023/09/15) Linuxなどの方は、ディストリビューションのパッケージとして公開してくれてるやつを引っ張ってきても良いと思います。 私はUbuntu 22.04.3 LTS (64bit)ですので、aptからパクってくることもできます。 sudo apt update sudo apt install hugo ただ、なんか微妙に古かったので、さっきのリンクからパッケージをパクってきて、それをaptに渡しました。 hugo_extended_0.118.2_linux-arm64.debをダウンロード sudo apt install path/to/hugo_extended_0.118.2_linux-arm64.deb インストールできない？俺もわからん hugo version # -\u0026gt; hugo v0.118.2-da7983ac4b94d97d776d7c2405040de97e95c03d+extended linux/amd64 BuildDate=2023-08-31T11:23:51Z VendorInfo=gohugoio だそうです。 使い方は次のリンクをさっと見ていきましょう。ちなみに私は細かい使い方とか難しいことは何も分かっていません。 公式サイト(英語) さくらのナレッジ 私は読んでないけど、なんかドンピシャなやつあった(qiita) こっちは読んだやつ(Zenn) 読んだやつパート2(Zenn) もっとちゃんと知りたい人はちゃんと公式サイトを浚いましょうね。 さて、サイトテーマを決めましょう。hugoは公式サイトで有志が作ったテーマをいっぱい公開してくれています。 ここで物色しましょう。 テーマってなんやねんと思う方もいると思います。 私の浅いイメージ的には、 hugo : ユーザーが特定のディレクトリに配置したファイルからいろんなデータなどを抜き出し、それを操作する統一的なインターフェースとかを提供する。(例えば、配置したmdファイルからテキストを抜き出して、{{content}}みたいな記法で他のファイルに挿入できるようにするとか) hugoテーマ : hugoが提供してくれる機能をいい感じにデコったりしてくれる。 みたいな感じなのかな？ なので、hugo側でデフォルトで提供されているものの、テーマがそれに対応していないこともあります。readmeとかを見てちゃんと決めましょう。リポジトリを見に行けば大抵デモページが用意されています。 私がやったこと さて、本題です。 ここからは、私がこのサイトを構築するためにやったことを色々書きます。 どちらかと言うと自分が忘れたときのためのものなので、大して参考にならんかもしれません。 正直に言うと、このセクションのためにこの記事を書き始めました。 テーマ選択 テーマはsimplogを選択します。 主な選定理由はタグやカテゴリなどの便利機能をサポートしつつ、シンプルで使いやすそうだからです。 さて、今まで構築していたリポジトリをローカルにコピーしておいて、破壊しましょう。 cp -r ./ path/to/archive/ rm * hugo new site . --force # 以下実際のログ Congratulations! Your new Hugo site was created in /home/in/dev/git/myblog. Just a few more steps... 1. Change the current directory to /home/in/dev/git/myblog. 2. Create or install a theme: - Create a new theme with the command \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; - Install a theme from https://themes.gohugo.io/ 3. Edit hugo.toml, setting the \u0026#34;theme\u0026#34; property to the theme name. 4. Create new content with the command \u0026#34;hugo new content \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 5. Start the embedded web server with the command \u0026#34;hugo server --buildDrafts\u0026#34;. See documentation at https://gohugo.io/. 次に、テーマをインストールします。よく分かってないですが、とりあえず書いてあるとおりに進めます。(なんだよsubmoduleって) git submodule add https://github.com/michimani/simplog.git ./themes/simplog # 以下実際のログ Cloning into \u0026#39;/home/in/dev/git/myblog/themes/simplog\u0026#39;... remote: Enumerating objects: 2538, done. remote: Counting objects: 100% (664/664), done. remote: Compressing objects: 100% (262/262), done. remote: Total 2538 (delta 288), reused 625 (delta 280), pack-reused 1874 Receiving objects: 100% (2538/2538), 3.09 MiB | 6.19 MiB/s, done. Resolving deltas: 100% (1201/1201), done. 全体の設定(hugo.toml) さて、驚くべきことに、これで大半の作業は終了です。 後は設定やテーマをいじりましょう。 まず、ルート直下にあるhugo.tomlを設定します。(hugoのバージョンによってはconfig.tomlがデフォだったりする) 私の設定を貼り付けておきますが、このあたりはテーマに依存する項目も多いですから、いろんな情報を見てみると良さそうです。 あと、一応注意喚起ですが、私は雰囲気で設定したので多分いくつかおかしいです。 baseURL = \u0026#39;http://inthebloom.github.io/\u0026#39; languageCode = \u0026#39;ja\u0026#39; DefaultContentLanguage = \u0026#34;ja\u0026#34; title = \u0026#34;InTheDayDream\u0026#34; description = \u0026#34;InTheBloom\u0026#39;s Website\u0026#34; author = \u0026#34;InTheBloom\u0026#34; theme = \u0026#34;simplog\u0026#34; paginate = 10 summarylength = 20 enableInlineShortcodes = true ignoreErrors = [\u0026#34;error-remote-getjson\u0026#34;] googleAnalytics = \u0026#34;\u0026#34; disqusShortname = \u0026#34;\u0026#34; [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true [menu] [[menu.main]] identifier = \u0026#34;home\u0026#34; name = \u0026#34;Home\u0026#34; url = \u0026#34;/\u0026#34; weight = 1 [[menu.main]] identifier = \u0026#34;tags\u0026#34; name = \u0026#34;Tags\u0026#34; url = \u0026#34;/tags/\u0026#34; weight = 2 [[menu.main]] identifier = \u0026#34;categories\u0026#34; name = \u0026#34;Categories\u0026#34; url = \u0026#34;/categories/\u0026#34; weight = 3 [[menu.main]] identifier = \u0026#34;archives\u0026#34; name = \u0026#34;Archives\u0026#34; url = \u0026#34;/archives/\u0026#34; weight = 4 [[menu.main]] identifier = \u0026#34;about\u0026#34; name = \u0026#34;About\u0026#34; url = \u0026#34;/about/\u0026#34; weight = 5 [taxonomies] category = \u0026#34;categories\u0026#34; tag = \u0026#34;tags\u0026#34; archive = \u0026#34;archives\u0026#34; [services] [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true [params] subtitle = \u0026#34;\u0026#34; colorTheme = \u0026#34;default\u0026#34; description = \u0026#34;\u0026#34; twitter = \u0026#34;UU9782wsEdANDhp\u0026#34; customCSS = \u0026#34;/css/custom.css\u0026#34; adobeFontsKitId = \u0026#34;\u0026#34; headerImagePath = \u0026#34;\u0026#34; [params.enabled] comment = true summary = true toc = true ポイントとしては、mdファイル中の生のhtmlを反映するようにunsafe機能を有効にしてあります。また、カスタムcssを有効にしてあります。カスタムcssは/static/以下が検索されてるっぽい？ カスタムcss(static/css/custom.css) cssは気に入らないものをオーバーライドしましょう。 ブラウザの調査機能などを使うと比較的簡単にどれを変えればよいかわかります。 img { width: auto; max-width: 100%; height: auto; border: 1px solid black; } #content h2 { padding-bottom: 0.5em; border-bottom: 1px solid gray; margin-top: 3em; } #main-menu-nav-items { grid-template-columns: repeat(5, 20%); } .block-separater { margin-top: 50px; } #content-footer { margin-top: 70px; } テンプレートのオーバーライド(layouts/) テーマに用意されているテンプレートもいじりましょう。 themes/以下のlayoutsではなく、ルート以下のlayoutsに同様のファイルを用意してあげることで、差異があったら優先的に使ってくれます。 cp -r themes/simplog/layouts/* ./layouts/ KaTeXの設定 これを利用する。 要はCDNからKaTeXを読み込んで、JSでロード時に変換しているっぽい？ 詳しいことはたくさん記事が存在するから各自でやりましょう。 まず諸々の設定を入れ込んだpartialを作成しよう。 touch layouts/partials/math.html 中身はこれ \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { // customised options // • auto-render specific keys, e.g.: delimiters: [ {left: \u0026#39;$$\u0026#39;, right: \u0026#39;$$\u0026#39;, display: true}, {left: \u0026#39;$\u0026#39;, right: \u0026#39;$\u0026#39;, display: false}, // {left: \u0026#39;\\\\(\u0026#39;, right: \u0026#39;\\\\)\u0026#39;, display: false}, // {left: \u0026#39;\\\\[\u0026#39;, right: \u0026#39;\\\\]\u0026#39;, display: true} ], // • rendering keys, e.g.: throwOnError : false }); }); \u0026lt;/script\u0026gt; 各ページで読み込むための設定をしよう。 フロントマター(各記事先頭の設定)や、hugo.tomlで記述したパラメータを参照してオンオフを切り替えるようにした。 layouts/partials/header.htmlあたりにでも埋め込もう。 \u0026lt;!-- KaTeX Settings --\u0026gt; {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34;}} {{ end }} これでページ先頭にmath: trueなどと書けばKaTeXを使ってくれる。 余談ではあるが、markdownとKaTeXを同時に運用するのは相性的にあまり良くない。というのも、markdownパーサーがKaTeX記法と衝突することがあり、この場合htmlのロード後に発動するKaTeXが必ず負ける。 いろんなケースがあるので、問題が発生したらその都度解決策を考える必要があり、かなり面倒くさい。 マジで誰かなんとかしてくれ Table Of Contentsを強調する 記事の先頭にTOC(Table Of Contents)を設置してくれる機能がある。しかし、simplogのデフォルトはあまりにもわかりにくいと感じるので、改造する。 TOCはlayouts/_default/single.htmlをいじれば良さそう。 これが元 \u0026lt;!--TOC--\u0026gt; {{ if eq .Site.Params.Enabled.Toc true }} {{.TableOfContents}} {{ end }} 改造後 \u0026lt;!--TOC--\u0026gt; {{ if and .Site.Params.Enabled.Toc (not (eq .Params.Toc false)) }} \u0026lt;div style=\u0026#34;padding: 0em 1em; margin-bottom: 5em; margin-top: 0.7em;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;font-size: 1.3em;\u0026#34;\u0026gt;Table Of Contents\u0026lt;/p\u0026gt; {{.TableOfContents}} \u0026lt;/div\u0026gt; {{ end }} ついでに各記事内でTOCを制御できるようにした。先頭メタデータでtoc: true/falseで制御できる。 記事タイトルをh1にする 何故か最大の見出しがh2にされていて、自作cssが適用されちゃうのが嫌なのでh1に差し替える。 いじるファイルは同様にlayouts/_default/single.html あと、ついでに公開日のところをいじる。 before \u0026lt;!--Title--\u0026gt; \u0026lt;h2\u0026gt;{{.Title}}\u0026lt;/h2\u0026gt; {{ if or (not .Params.hideDate) (eq .Params.hideDate false) }} \u0026lt;span class=\u0026#34;sub\u0026#34;\u0026gt;{{.Date.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; {{ end }} after \u0026lt;!--Title--\u0026gt; \u0026lt;h1\u0026gt;{{.Title}}\u0026lt;/h1\u0026gt; {{ if or (not .Params.hideDate) (eq .Params.hideDate false) }} \u0026lt;span class=\u0026#34;sub\u0026#34;\u0026gt;Published on {{.Date.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;span class=\u0026#34;sub\u0026#34;\u0026gt;Last Modified {{.Lastmod.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/span\u0026gt; {{ end }} 何気にパラメータlastmodが追加された。 先頭メタデータ内で、lastmod: 2006-01-01みたいな感じで指定してあげると良さそう なお、lastmodが設定されていないときはデフォルトでdateに合わせてくれた。気が利くなぁ ogpの画像の参照先をいじる ogpというのは、SNSなどにリンクを貼ったときにいい感じにプレビュー画像みたいなのを表示してくれるやつです。 デフォルトでは相対パスで検索しているようなので、ここを絶対パスを使うようにしてみます。 layouts/partials/head.htmlをいじります。 before \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ $site.BaseURL }}{{ . }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ $site.BaseURL }}{{ . }}\u0026#34;\u0026gt; after \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ . }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ . }}\u0026#34;\u0026gt; これで、メタデータでogimage: path/to/imageで指定できます。ただし絶対パスが必要になるので、外部のURLを指定すべきです。 ついでにデフォルトのogpimageを設定しておきましょう。{{ $site.BaseURL }}/images/featured_image.jpgという設定になっているようなので、この場所、名前で適当に作って配置します。 \u0026hellip;と思ったが、メタモンが発生してやる気がなくなったのでやめた。 faviconを用意する ブラウザなどでサイト名の横に表示されるちっちゃい画像のことをファビコンと呼ぶ。 これを用意する。 \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;180x180\u0026#34; href=\u0026#34;{{ relURL \u0026#34;images/apple-touch-icon.png\u0026#34; }}?c={{$cacheHashBase}}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; sizes=\u0026#34;32x32\u0026#34; href=\u0026#34;{{ relURL \u0026#34;images/favicon.png\u0026#34; }}?c={{$cacheHashBase}}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; sizes=\u0026#34;16x16\u0026#34; href=\u0026#34;{{ relURL \u0026#34;images/favicon-16x16.png\u0026#34; }}?c={{$cacheHashBase}}\u0026#34;\u0026gt; layouts/partials/head.htmlにこのような記述があった。この名前とサイズで用意しよう。 なんかよくわからないが/static/images/*.pngに用意したら反映された。 aboutページを用意する contents/about.mdを用意すると動きました。 細かいことには触れません。 大体完成！ 後はルートディレクトリでhugo serverを実行するとhttp://localhost:1313にアクセスすると見れます。 ビルドするときはhugoを実行すればpublic/に静的サイトが作成されます。 適当にpushしときましょう。 メタデータのテンプレートはこんなかんじかな？ --- title: title date: yyyy-mm-dd # lastmod: yyyy-mm-dd # ogimage: https://path/to/ogimage.img tags: - categories: - archives: - # math: true # toc: false --- 追記 注意このセクションに書いてあることとそれまでのセクションで書いてあることが重複していたり、矛盾している場合、こちらがより正しい。 実用的にはほとんど何もしなくてもいい感じにしてくれるほうが良いなと思った。 記事作成でメタ情報の追加が面倒くさそうだなと思ったので、分類をタグのみに絞ることにした。 まず、hugo.tomlの内容を修正する。 具体的には、次の内容を消す # [taxonomies]にある category = \u0026#34;categories\u0026#34; # [menu]にある [[menu.main]] identifier = \u0026#34;categories\u0026#34; name = \u0026#34;Categories\u0026#34; url = \u0026#34;/Categories/\u0026#34; weight = 4 すると、上のメニューバーが一枠開くので、CSSを修正する。 /static/css/custom.cssを次のように修正する。 /* #main-menu-nav-itemsにある */ /* 次を消す */ grid-template-columns: repeat(5, 20%); /* 次を追加 */ grid-template-columns: repeat(4, 25%); これでタクソノミーを減らすことができた。hugo的にはカテゴリとタグを特別使い分けてなさそう(知らんけど)ので、許されるんじゃないかな 全文検索をパクる まくまくhugoノートを見ていたら、全文検索を実装できるらしい。 この機能があれば過去記事とかから情報を検索できてすごく便利だなと思ったので、導入することにした。 ほとんど上のコードをパクり、/layouts/shortcodes/search.htmlとしてファイルを作成し、search.mdというファイルでショートコードを取り込むことにした。 内容は省略するとして、search.mdの内容を載せておく。 --- title: サイト内全文検索 hidedate: true toc: false _build: {list: never} --- サイト内の文章からインクリメント検索が可能です。 下の入力欄に入力することで検索ができます。 本ページは検索の対象外になっています。 \u0026lt;!-- searchのショートコードを入れる(ここに入れるとここでも無限再帰になってしまう。) --\u0026gt; _build: {list: never}というのをすると、一覧系のページに表示されなくなるらしい。これをしないとビルドのときに無限再帰になってしまう。 さて、これで上のメニューバーに検索を入れたくなった。 CSSを再度修正し、先程消したカテゴリの分を作る。 grid-template-columns: repeat(5, 20%); [[menu.main]] identifier = \u0026#34;search\u0026#34; name = \u0026#34;Search\u0026#34; url = \u0026#34;/search/\u0026#34; weight = 4 出来上がりは検索ページで確認できる。 また、詳細なファイルの内容はgithubのリポジトリにおいてある。 それはそれとして、さっき直したものをまた直すとは計画性のないアホである。 関連タグの表示を調整する 便利な機能として、関連タグの記事を下の自動リンクしてくれる機能があるが、その見た目があまり良くなかった。 ので、改造する。 /layouts/partials/related-tag-posts.htmlを次のように修正する。 \u0026lt;!-- 次を削除 --\u0026gt; \u0026lt;h4\u0026gt;Other posts tagged by \u0026#34;{{ $t }}\u0026#34;\u0026lt;/h3\u0026gt; \u0026lt;!-- 次を追加 --\u0026gt; \u0026lt;h4 style=\u0026#34;font-size: 1.3em;\u0026#34;\u0026gt;Other posts tagged by \u0026#34;{{ $t }}\u0026#34;\u0026lt;/h4\u0026gt; これ修正して気づいたが、オリジナルのコード閉じタグ間違ってない？ それと同時にCSSに次のものを追加する。 .related-tag-category-list { margin-top: 5em; } これで幅と可読性がいい感じになった。 過去記事の移植 今日(9月23日)、まだ完了していませんが、pandocでhtmlをmarkdownに変換して手作業で移植しています。つらたん。 (デプロイ後に発覚)faviconの謎の不具合 なんかlayouts/partials/head.htmlのfaviconのhrefの後ろにc=?\u0026lt;謎の文字列\u0026gt;みたいな謎の処理が入っているが、何故かgithub pages上でうまく動かなかった。 よって、これを削除した。 どういう影響があるのか知らない。 2023-09-23追記: 多分キャッシュ関連の何かだと思うんだけど、調べてもよくわからなかった。まあ動かなかったのは事実なのでfaviconくらい別にいいでしょの顔 ただ不思議なのは、cssとかもこれをやる設定になっているように見えること。なぜかfaviconだけうまく動かない。 win機でpullしたときに発覚したこと (これはhugoの記事として適切ではないかもしれません。) 最初にsimplogをgit submoduleしてとってきましたが、他のPCでこのリポジトリをクローンした場合、自動的にsubmoduleまでとってきてくれるわけではないようです。 これを参考にして、次のコマンドを打ったらうまくいきました。 git submodule init git submodule update フロントマターのテンプレート 最後に改訂版フロントマターのテンプレートを載せておく。 --- title: hogehoge # description: hogehoge date: yyyy-mm-dd # hidedate: true # lastmod: yyyy-mm-dd # ogimage: https://hoge/fuga/piyo.img tags: - hoge archives: - yyyy - yyyy-mm # math: true # toc: false # build: {list: never} --- 終わりに なんだかんだ1週間以上色々やってた。 疲れました。 これでいろんな記事を作りやすくなった。嬉しい。"
  },
  {
    url: "/post/katex/",
    title: "KaTeX導入してみる",
    date: "2023-06-23T00:00:00Z",
    body: "KaTeX導入してみる KaTeXを使ってみる $\\LaTeX{}$風の数式を表示できるJavaScriptライブラリ(らしい)である$\\KaTeX{}$を導入してみました。 本稿では、$\\KaTeX$の紹介と、自分がどうやって導入したかを説明します。 注意！ 筆者は$\\KaTeX{}$及び$\\LaTeX{}$に全く詳しくありません。 内容がガバガバかもしれないです。 使い方 ここに丁寧に書いてあるので、こっちを参考にしてください。 私は手元で動かしたい人向けにリポジトリから窃盗する手順だけ紹介します。 リポジトリはこちらです。 アクセスするとこんな画面になるはずです。 右下の方のReleasesの中のlatestがついてるやつをクリックしましょう。 こんな画面になるはずです。(私が作成してるときはv0.16.7でした。) tarballかzipをダウンロードして解凍しましょう。 こんなファイル群が出てくるはずです。 これらをhtmlファイル内で読み込めば使用できます。 下は実際にこのページで使用されている設定です。 (上で貼ったページのものをちょっぴり差し替えただけです。ファイルパスは自分の環境に合わせて変える必要があります。) \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;../katex/katex.css\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;../katex/katex.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;../katex/contrib/auto-render.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { delimiters: [ {left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true}, {left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false}, ] }); }); \u0026lt;/script\u0026gt; 数式のフォントサイズが気に入らなかったら、head内に次を足してください。(数字はお好みで) \u0026lt;style\u0026gt; .katex { font-size: 1em !important; } \u0026lt;/style\u0026gt; もしくはdivとかの中だけフォントサイズをいじるっていう方法もあります。 KaTeXテンプレート $\\KaTeX{}$を使うときは、インライン数式なら$で囲みます。 行単位なら$$で囲みます。 そうしないとうまく動かないです。 基本の使い方は$\\LaTeX{}$と同じなので、$\\LaTeX{}$記法はググると良いです。 よく使いそうな数式を紹介します。 行番号あり数式 $$ \\begin{equation} \\int_0^{2\\pi{}} \\sin{}x dx = 0 \\end{equation} $$ $$ \\begin{equation} \\int_0^{2\\pi{}} \\sin{}x dx = 0 \\end{equation} $$ 複数行に渡る数式(行番号一つ) $$ \\begin{equation} \\begin{split} \\sum_{k=0}^{n} {}_n \\mathrm{C}_k \u0026amp;= {}_n \\mathrm{C}_0 + {}_n \\mathrm{C}_1 + \\dots \\\\ \u0026amp;= 2^n \\end{split} \\end{equation} $$ $$ \\begin{equation} \\begin{split} \\sum_{k=0}^{n} {}_n \\mathrm{C}_k \u0026amp;= {}_n \\mathrm{C}_0 + {}_n \\mathrm{C}_1 + \\dots \\\\ \u0026amp;= 2^n \\end{split} \\end{equation} $$ デカ括弧 $$ T = 2\\pi{} \\sqrt{ \\frac{h}{g} \\left( 1+\\frac{2r^2}{5h^2} \\right) } \\left( 1+\\frac{\\theta{}^2}{16} \\right) $$ $$ T = 2\\pi{} \\sqrt{ \\frac{h}{g} \\left( 1+\\frac{2r^2}{5h^2} \\right) } \\left( 1+\\frac{\\theta{}^2}{16} \\right) $$ なお、絶対値やその他の括弧も基本上の例に従う。 インラインデカ数式 通常 $\\frac{a}{b}$ $\\sum_a^b$ $\\int_a^b$ デカ $\\dfrac{a}{b}$ $\\displaystyle\\sum_a^b$ $\\sum\\limits_a^b$ $\\displaystyle\\int_a^b$ $\\int\\limits_a^b$ 通常 $\\frac{a}{b}$ $\\sum_a^b$ $\\int_a^b$ デカ $\\dfrac{a}{b}$ $\\displaystyle\\sum_a^b$ $\\sum\\limits_a^b$ $\\displaystyle\\int_a^b$ $\\int\\limits_a^b$ これはinline表示をdisplayモードに矯正するコマンドです。一番適したものを使いましょう。 単位をつけるために微妙に間あけるやつ $1.0\\,\\mathrm{m}$ $1.0\\,\\mathrm{m}$ 数式環境下での立体は基本的に\\mathrm{}を使っておけば良い。 $\\KaTeX{}$が対応してるかなどは知らないが、 物理単位などによっては組み込みやパッケージ等でより良いものが用意されていることがあるので、 それらを調べてから使うとなお良い。 終わりに あくまでテキストベースなの良いですよね。($\\TeX{}$記法が再利用性が高いかは置いておくとして) ただ、思ったより色々と大変でした。 特に、markdownのパースのせいで$\\KaTeX{}$が崩されたりするのはかなり罠だと思います。 個人的な使い方としては、htmlに変換した後厳重にチェックした後放流するって感じになりそうです。"
  },
  {
    url: "/post/abc293/",
    title: "ABC293参加記録",
    date: "2023-03-17T00:00:00Z",
    body: "ABC293参加記録 ABC293参加してきました。(今更感) もっとエントリ更新に力を入れると言っておきながらABC292の分をサボってしまいました。ABC293からすでに6日くらい経過していますが、一応有言実行ということで参加記録です。(すまんかった) 総評 今回の戦績です。 A, Bの2完でした。パフォーマンス375、レート変動553→535(-18)でした。 結果だけを見ると正直結構やらかしてしまったなという感じですが、ほとんど理解していないアルゴリズムが問われているので当然の帰結だと思います。あと、これで3週連続冷えなのでじわじわレートが下がっています。 問題など 今回は解けてはいないけどC問題まで紹介します。 A - Swap Odd and Even 問題文はこちらです。 操作によって文字列長が変化しない上、制約も優しいので普通にシュミレートすれば解けます。C言語等を使っている人はバッファオーバーランに気をつけましょう。この問題の制約下では文字列長が偶数になることがわかっているのでループ変数に2を加えていく方針でACできます。バッファオーバーランに気をつけるなら、操作に使う変数とループ変数を分けるのが良いでしょう。 ACコード B - Call the ID Number 問題文はこちらです。 こちらも基本的には言われたとおりにシュミレートすれば解ける問題になっています。ただし、A問題と比べて複雑になっているので注意深く問題分を読むべきだと思います。 「すでに番号を呼ばれた人」は割り当てられた番号を読み上げることができないので、これをシュミレートするために以下のような実装が考えられます。 人iが呼ぶ番号Aiを配列に格納する。(配列のi番目に人iの情報を入れる) 配列を最初から順に見ていって、「その要素番目」にある要素を-1(インデックスとして無効な値なら何でも良い)で上書きする。 最後にもう一度最初から見ていって、要素が-1になっていない人がまだ呼ばれていない人で、これはすでに昇順になっています。 配列が強すぎる ACコード(前半はソート関数郡です。(必要なかった)) C - Make Takahashi Happy 問題文はこちらです。 経路上に存在する数字がかぶるかどうかを判定するためには、すべての経路を具体的に知っていなければいけません。すなわち、重複順列の全列挙です。そこで、いくつか方法があります。 私の取った方法はbit全探索です。0と1を「右に進む」「下に進む」に対応させることで重複順列をすべて列挙することができます。ビット数はw + h - 2になります。たぶん知らないとできません。 具体的には、最下位ビットの加算を行うたびに全ビットを見ていって、「下に進む」を表しているビットの総数がh - 1に到達したときに求めたい組み合わせの一つになります。高校数学を履修した人にとっては馴染み深い考え方かもしれません。(経路の数を求める問題で出てくるはずです。) pythonやc++であれば、順列の列挙をするライブラリが利用できるはずなので、使い方を知っていればACしやすいと思います。C言語にそんなものはありません。(血涙) ACコード 完走した感想 今回のコンテストはちょうど対策が薄かったところばっかり出てきて中々苦しかったです。特に、組み合わせの列挙は近いうちの目標だったのですが、面倒くさくて放置していました。 D問題はグラフに関する問題が出ていました。まじでグラフをなんとかしないと茶色から落ちそうなのでがんばります。(C言語は動的配列のサポートが薄く、隣接リストを微妙に作りにくいからずっと面倒臭がって放置しています。) 全然関係ないけど200AC超えました。 それではまた次のエントリで"
  },
  {
    url: "/post/abc291/",
    title: "ABC291参加記録 ~ DPお前もう船降りろ ~",
    date: "2023-02-26T00:00:00Z",
    body: "ABC291参加記録 ~ DPお前もう船降りろ ~ はじめに 今週もAtCoder Beginners Contest 291に参加してきましたので、軽く参加記録です。 戦績 今回の戦績は以下の通りです。 A, B, Cの3完で、パフォーマンス439でした。レート変動は571→557です。 D問題ゆ゛る゛さ゛ん゛(大迫真) 問題とか 出た問題紹介します。 A - camel Case 大文字が出現する位置を答える問題です。私の解法では、asciiにおいて小文字を数値表現したときに90を上回ることを利用して判定するというものです。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { char s[101]; scanf(\u0026#34;%s\u0026#34;, s); for (int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if (90 \u0026gt;= s[i]) { printf(\u0026#34;%i\u0026#34;, i + 1); } } return 0; } B - Trimmed Mean バラバラに渡される数値の上からと下からN個を抜いて平均を取るという問題です。おそらく出題意図としては、O(N^2)でもいいからソートを実装してみてというものだと思います。 何らかの手段でソートをかけて、真ん中の3N個のデータについて平均を取ることでACをとれます。私はC言語の標準関数(qsort())を使わずに、自作関数でやってみました。 ACコードはやたらと長いので、実際の提出を載せます。 提出 C - LRUD Instructions 2 二次元座標平面のグリッド上を動き回る人が、二回以上同じ座標に来ることがあるかを判定する問題です。 正直結構悩みました。一番先に思いついたのは、訪れた座標をキーにして、連想配列に入れることです。pythonなどの組み込みのデータ構造がリッチな言語なら多分この方法でやっていました。 残念なことに、現状C言語で私がすぐに利用できる連想配列はないため、他の方法を取りました。 しばらく唸っていると、同じ座標を訪れるということは、訪れた座標をすべて記録しておき、ソートをかけることですぐに判定できるのではないかという天啓が訪れます。早速実装しましたが... 座標のxとyでソートをかけると、片方のソート結果までぐちゃぐちゃにされることを忘れていました。対策として、一旦xでソートをかけてから、xが同じ奴らに対してyソートをかけるように修正したら通りました。というわけで以下AC提出です。(やたら長いのでこちらも提出で) 提出 D - Flip Cards 2^Nの組み合わせの中から条件を満たすものの数を考える問題です。制約から明らかに全探索したら間に合いません。(原理的にはbit全探索すれば解けますが)というわけで何らかの簡略化を行う必要が出てきます。 組み合わせ + 全探索だと不可能 ← これ大体DP説 というわけでDPの線を疑いながら考えました。結果... 典型dpの攻略は春休み中の課題の一つです。がんばります... 解説に「配るDP」とか書いてあってビビっちゃいました。くやしいので解けたら別記事建てるかもしれません。 終わりに 参加記録は以上です。ここまで読んでいただきありがとうございました。 レートはモチベーションの一つではありますが、レートによってモチベーションが下げられるのはもったいない気がするので、今回の失敗はなかったことにしときます。春休み中に緑行けるといいなぁって思っています。それでは次のエントリで。"
  },
  {
    url: "/post/abc290/",
    title: "ABC290参加記録",
    date: "2023-02-21T00:00:00Z",
    body: "ABC290参加記録 ABC290参加した。 お久しぶりです。最近AtCoderコンテストの参加記録をサボりがちなので、流石にエントリを生成します。 今週行われたToyota Programming Contest 2023 Spring Qual B（AtCoder Beginner Contest 290）は、どうやらオンサイトのコンテストに向けての予選を兼ねているそうで、希望者は好成績を出すことができれば3/18日に行われる決勝イベントに招待されるそうです。なんかすごいですね。 まあ私はそんな実力には程遠いので、いつもどおり参加してきました。 成績とか 軽く今週の戦績を振り返っておきます。今回はA,B,Cの3完でパフォーマンス611, レート変動511→523でした。 微増ですがまあ勝ちは勝ちなので() あと前回の参加記録からしばらく時間が立っているので、いつの間にか入茶しています。(多分色変記事は書きません) 問題と解法 サラッと流します。今までの記事では結構このパートに力を使っていたんですが、比較的難しい問題などは前回の記事のようなスタイルで記事を立てようかなと思っているので、あまり深入りはしないことにします。 A - Contest Result 問題文はこちら すぬけくんの解いた問題番号は配点のあとに渡されるので、一旦配点はすべて記録しておく必要があります。✙最強のデータ構造✙である配列を用いれば一発です。ただしアクセスするインデックスは一つずれますから気をつけましょう。 C言語的なことを言うとしたら、制約からすぬけくんの総得点はintで大丈夫だし、何なら配点はcharで収まります。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int n, m; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;m); int a[n]; for (int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;a[i]); } int ans = 0; for (int i = 0; m \u0026gt; i; i++) { int tmp; scanf(\u0026#34;%i\u0026#34;, \u0026amp;tmp); ans += a[tmp - 1]; } printf(\u0026#34;%i\u0026#34;, ans); return 0; } B - Qual B 問題文はこちら 予選コンテストにちなんだ問題でしょうか？意外とAtCoderの問題って遊び心のあるものが多いような気がします。 さて、予選を突破するための条件は、「決勝希望者であり、希望者のの中で上位K人である」ことなので、単に上からoのついている人をK人分だけoにして、あとはxにするとオーケーです。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int n, k; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;k); char s[n]; scanf(\u0026#34;%s\u0026#34;, s); int sum = k; int count = 0; for (int i = 0; n \u0026gt; i; i++) { if (sum == 0) { break; } if (s[i] == \u0026#39;o\u0026#39;) { printf(\u0026#34;o\u0026#34;); sum--; } else { printf(\u0026#34;x\u0026#34;); } count++; } for (int i = count; n \u0026gt; count; count++) { printf(\u0026#34;x\u0026#34;); } return 0; } C - Max MEX 問題文はこちらです。 MEXってなんだよ(正論) MEXというものをほとんど聞いたことがなかったので「MEX 数学」でgoogle検索してみましたが、あまりヒットしなかったのでそこまで有名なものでもないようです。 さて、このMEX演算は自明な性質として、「数Xを生成したければ、最低でもX個の元が必要である」というものがあります。本問題ではK要素を抜き出してくるという操作を行うため、どんなに頑張ってもMEX(B)の最大値はKになります。 最大値がそれより小さくなるケースは、「0~K-1に至る途中の数のどれかが一つでも欠けている」というものになります。 以上より、数列Aに0~K-1までの数字がすべて含まれているときに答えはKになり、それ以外のときは「欠けている」最小の数字が答えになります。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int n, k; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;k); char check[k + 1]; for (int i = 0; k + 1 \u0026gt; i; check[i++] = 0) {} for (int i = 0; n \u0026gt; i; i++) { int tmp; scanf(\u0026#34;%i\u0026#34;, \u0026amp;tmp); if (k \u0026gt; tmp) { check[tmp] = 1; } } for (int i = 0; k + 1 \u0026gt; i; i++) { if (check[i] == 0) { printf(\u0026#34;%i\u0026#34;, i); break; } } return 0; } 余談ですが、ARC156にもMEX関連の問題が出ていましたね(全く解けませんでした) D - Marking 結構引っかかった問題なので、(もしやある気があれば)別記事をたてます。 終わりに 参加記録はこれでおしまいです。読んでいただきありがとうございました。 いつかの参加記事でも言及しましたが、最近はAtCoder Problemsが提供しているBoot camp for Beginnersに取り組んでいて、Easyの100問を解ききることができました。また、それに伴ってLongest Streakも50日を達成しました。ヤッター 個人的におすすめなので、みなさんもやってみてはいかがでしょうか？ それと今後の方針としましては、記事更新をもうちょっと頑張りたいな〜とか考えてます。それではまた次の記事で"
  },
  {
    url: "/post/abc284/",
    title: "ABC284参加記録",
    date: "2023-01-07T00:00:00Z",
    body: "ABC284参加記録 今週もABCのお時間になりました。 みなさん，あけましておめでとうございます。本日2023年1月7日は記念すべき新年最初のAtCoder Beginners Contestでした。今週も参加してきたのでいつも通り参加記録です。 早速余談ですが，皆様は正月休みを有意義に使えましたか？私は久しぶりに帰省して，運動不足解消にと鍋蓋山に登りました。 鍋蓋山の道中にある林\r登頂成功。これ元旦です。いいでしょ？\r冬ということもあって，道中も結構寒い時がありました。普通に服着ててこれなので，中学高校の持久走で言われた「走ってたら寒くないから」とか言うクッソ無責任な言葉を思い出したりしてました。 長距離深夜バスにて東京に再召喚...(実家に帰りたい)\rまた，我らがUECは1月5日から授業なので，年明けてすぐ帰りました。なお新年初授業は来てる人少なかった模様 閑話休題。それでは本編行きましょう 今回の結果 今回の提出はこんな感じでした。 今回はA, B, Dの三完でした。めちゃくちゃWAが多いのは気にしないでください。傷つきます。 なお，今回は初めてコンテスト中にD問題を解くことができました！ うれしい！でもお前C解けないじゃん 今回のコンテストによるレーティング変動は以下の通りでした。 遂に茶色までの折り返しを超えることができました！ やはりD問題が解けたのが大きかったようです。Cが解けなかったのに今までで最高のパフォーマンス(732でした。)を出すことができました。 各問題に対する解法など いつも通りに私の考えたことなどを書いていきます。 A - Sequence of Strings 問題文は以下の通りでした。 文字列をN個受け取って，逆順で出力する問題でした。 一旦文字列をすべて保持して，あとから出力していけばオーケーです。ほかの言語についてはよくわかりませんが，C言語ならとりあえずいっつも理解が浅いせいで事故るからできるだけ避けたいけど二次元配列を使うと比較的アッサリ解けます。 具体的に言うと，char s[n][11]みたいなものを宣言して，scanf関数で\u0026amp;s[i][0]から受け取ればいいです。以下はAC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n][11]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[i][0]); } for(int i = n - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%s\\n\u0026#34;, s[i]); } return 0; } ちなみに，この問題の制約下では各文字列は10文字以下です。したがって，配列は終端文字'\\0'を含めて11以上で宣言しなければいけません。私は普通に忘れててWA食らいました。 B - Multi Test Cases 問題文は以下の通りでした。 複数のテストケースに対して判定していくというちょっと変わった問題ですね。私がAtCoderに参加し始めてから初めて見るタイプでした。 幸い判定することは偶奇判定なので，2で割った余りを見ていけばOKです。ポイントを挙げるとするなら，答えはテストケースの順番に出力する必要があるので，入力を受け取るごとに出力をしていく感じで実装するとスマートです。以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int t; scanf(\u0026#34;%i\u0026#34;, \u0026amp;t); for(int i = 0; t \u0026gt; i; i++) { int n; int ans = 0; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); for(int i = 0; n \u0026gt; i; i++) { int temp; scanf(\u0026#34;%i\u0026#34;, \u0026amp;temp); if(temp % 2 == 1) { ans++; } } printf(\u0026#34;%i\\n\u0026#34;, ans); } return 0; } 完全に余談ですが，最近変数のスコープの管理が少しだけうまくなったような気がします。 D - Happy New Year 2023 問題文は以下の通りでした。 一言でいうなら素因数分解をする問題です。ただし，今回の問題では対象となる数が2つの素数p, qによってp2qと表せることが分かっています。あと，この問題でもB問題と同じく複数のケースの判定を行う問題でした。 この問題を最も単純なアイデアから膨らませて考えていきます。 最も簡単な解き方は，単純にすべて試し割りしてみることです。「ある自然数は，それ以下の素数の積としてただ1通りに表すことができる」という事実を利用しています。要は素因数分解の一意性ってことです。換言すると，「ある数Nは，2からNまでのいずれかの素数で割っていくといずれ1になる」ということです。 例を挙げましょう。例えば2023は17×17×7，63は3×3×7に分解することができます。このことを利用すると以下のような実装が可能です。 for(int i = 2; n \u0026gt;= i; i++) { if(n % i == 0) { // nを割ることができる数を発見 while(n % i == 0) { // 同じ数が複数回掛け算されている可能性もある n /= i; } } } これをいい感じに今回の問題に当てはめると「原理的には」解くことができます。しかし，*実際には解くことができません。*競技プログラミングをやる方ならお分かりかと思いますが，今回の制約におけるNが9 × 1018以下という部分が引っ掛かります。つまり，無駄な計算が多すぎて実行時間に間に合いません。さて，どのような工夫が可能でしょうか？ 私がこの問題を解くにあたって，まず足掛かりにしたのは「ある数Nは，Nの平方根より大きな素因数を多くても一つしか持たない」という事実です。残念ながらこの知識は当意即妙的に知らなかった状態からパッと思いつくのは難しいかなと(私は)思います。しかし，素数を扱うときに強力な武器になりえるので知らなかった人は憶えておくとよいかもしれません。よく考えると当たり前のことで，もしNの平方根より大きな素因数を2つもっていたとすると，その2数の積がすでにNを越えてしまうので，明らかに矛盾するからです。 この事実を使うと何が良いのでしょうか？それは，探索範囲が小さくできるからです。前述の事実から次のことが言えます。 NがNの平方根以下の素因数しか持たないとき，もちろんNの平方根までの探索で，すべての素因数を見つけることができる。 NがNの平方根より大きな素因数を持つ時，Nの平方根までの探索で見つけた素数でNを割ることで，残りの素因数を見つけることができる。 以上より，さっきまではNまで探索していたのに対して，Nの平方根までの探索でよいことを示すことができました。より具体的な方法を挙げると，Nの平方根まで「Nを割ることができる数」を見つけたらその都度見つけた数で限界まで割っていきます。探索がNの平方根まで終わったら，これまで割られてきたNを確認します。もしこの数が1になっていなければ，それは素数ということが確定しています。 この方法で問題を解くことができるでしょうか？残念ながら，おそらくまだ間に合いません。それはNの平方根が最大で109のオーダーに達するからです。 このアイデアは無駄だったのでしょうか？いや，まだあきらめるのは早いです。制約を見直してみましょう。今回はNは(重複を許して)3つの素因数を持ちます。先ほどの考え方を応用すると，Nの三乗根までの探索で少なくとも一つの素因数を見つけることが可能ということがいえます。これは，もしそれ以上の素因数を3つ以上持っていると先ほど示したものと同様の矛盾が生じるからです。 この時，探索範囲は最大で106のオーダーまで減少します。AtCoderでは，およそループを108くらいまで回せるそうなので，よほど定数倍を悪化させるような処理を書かなければおそらく通るでしょう。 基本的にはこのアイデアで通ると思います。が，私の実装ではまだ注意点があります。それは，三乗根までの探索ですべての素因数が確定するパターンと確定しないパターンに分かれるからです。 問題で言うところの素因数p(つまり，Nに二つ含まれているもの)を見つけることができれば，残りの素因数はNをpで割ることで見つけることができますが，もしqしか見つけられなかった場合，Nをqで割ることにより得られる数はp2となり，これをpに「ほぐす」作業が必要となります。私はこの処理を二分探索にて実装しました。 以下私のACコードです。 #include \u0026lt;stdio.h\u0026gt; int disassembly(long long int *a, long long int *b, long long int *n, int *map) { // 素因数がすべてまたは2乗じゃないほうだけ見つかる int flag; for(int i = 2; 3000000 \u0026gt; i; i++) { if(map[i] != 0) { if(*n % map[i] == 0) { *n /= map[i]; if(*n % map[i] == 0) { // このケースは確定 *a = map[i]; *n /= map[i]; *b = *n; flag = 1; break; } else { // このケースはまだわからない *b = map[i]; flag = 0; break; } } } } if(flag == 1) { return 0; } else { return -1; } } void Sqrt(long long int *a, long long int *n) { long long int left, center, right; left = 0; if(*n \u0026gt; 3000000000) { right = 3000000000; } else { right = *n; } for(; right - left \u0026gt; 10;) { center = (right + left) / 2; if(center * center \u0026gt; *n) { right = center; } else { left = center; } } for(; *n != left * left; left++) {} *a = left; } int main(void) { int t; scanf(\u0026#34;%i\u0026#34;, \u0026amp;t); int map[3000000]; // エラトステネス for(int i = 0; 3000000 \u0026gt; i; i++) { map[i] = i; } for(int i = 2; 1734 \u0026gt; i; i++) { for(int j = 2 * i; 3000000 \u0026gt; j; j += j) { map[j] = 0; } } for(int i = 0; t \u0026gt; i; i++) { long long int n; scanf(\u0026#34;%lli\u0026#34;, \u0026amp;n); long long int a, b; // 素因数 if(disassembly(\u0026amp;a, \u0026amp;b, \u0026amp;n, map) == 0) { printf(\u0026#34;%lli %lli\\n\u0026#34;, a, b); } else { Sqrt(\u0026amp;a, \u0026amp;n); printf(\u0026#34;%lli %lli\\n\u0026#34;, a, b); } } return 0; } クソ長コードですまんかった。ポイントとしては，まず素数のリストを事前にエラトステネスの篩を用いて事前計算しておくことで多少の軽量化を図っています。あとは二分探索でオーバーフローしないようにしています。いずれも制約ありきなので一般的に使えるコードではないです。 余談ですが，最近こんな風にvoidを返す関数にポインターの引数を与えることで，面倒くさい処理を外部委託するのにハマっています。それにしてもint *aみたいなやつを与えたときに*aって書くの面倒くさいですね。 C - Count Connected Components 問題文は以下の通りです。 無理でした。はい。 この問題に出てくる「グラフ」というのは，よくある「y = xのグラフ」のようなものではなくて，離散数学における「頂点と線をいくつか組み合わせた図形」のようなものらしいです。 例えば，以下のようなものがグラフです。(出典: AtCoder Beginners Contest284問題ページより) この問題の題意は多分「辺と頂点の情報が与えられるので，独立しているパーツの数を答えなさい」です。しかし，グラフの定義やそこから導かれる性質がよくわかっていなかったため，有効な解法がよくわかりませんでした。先にある程度グラフについて知らないと厳しそうです。 グラフ，完全に理解した。\rということで，今後の課題ということにさせてください。 終わりに 今回の参加記録は以上です。ここまで読んでいただきありがとうございました。 余談ですが，AtCoder Problemsにて今回のC問題のdifficultyを確認してきたのですが，なんと灰色の真ん中くらいでした。...うせやろ？ どうやらグラフの探索は簡単めの典型のようです。次出たときには解けるようになりたいといいたいところですが，グラフを勉強するってどうすればいいんでしょうか...解説によると幅優先探索とかで解けるらしいです。 なんだよそれ あと，最近はAtCoder Problems上のBoot camp for Beginnersを少しずつ進めています。ついでにLongest Streak(ACを出した日の継続日)を伸ばそうと頑張っています。もしやっていない人がいたらおすすめです。 それでは次の記事でお会いしましょう。皆様にとって2023年がいい年になりますように！"
  },
  {
    url: "/post/abc283/",
    title: "ABC283参加記録！",
    date: "2022-12-26T00:00:00Z",
    body: "ABC283参加記録！ ABC283参加してきた！ こんにちは。最近近所のスーパーが扱っている冷凍パスタのメーカーが変わって一瞬焦ったInです。(でもちゃんとおいしかったのでセーフ) アドベントカレンダーを執筆していた影響で遅れてしまいましたが，今週もちゃんとABCに参加してきましたので，その参加記録を生やしておきます。 今週の成績発表のコーナー まずは今週の成績です。前回爆死したのが記憶に新しいですが，今回はこんな感じでした。 大体16分でCまで通して，そのあとD問題に敗北しました。全体で3完です。 このためだけに10分くらいで作った雑コラ。\rなお，今回のコンテストによるレート変動は以下の通りでした。 茶色まで折り返し地点といった感じでなかなかいいんじゃないでしょうか？今回は結構早解きに成功したので，3完ですがそこそこの順位になりました。ペナルティも食らってないし 各問題と解法 いつも通り自分が解いた問題の説明を載せていきたいと思います。まずはA問題です。 A - Power 問題文は以下の通りでした。 AのB乗を出力するだけのシンプルな問題です。 ご存じの方も多いかもしれませんが一応書いておきますと，ABというのはBが自然数の場合は素朴に定義されており， AB=A×A×\u0026hellip;×A (AがB個掛け算されている) というものです。 この問題の制約下では，ABの最小値はA=B=1の時1で，最大値はA=B=9の時387420489となります。これはintの範囲内に収まります。また，計算回数も9回程度に収まることが分かるので，定義通り計算して出力したらOKであることが分かります。以下にAC通ったコードを載せます。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int a, b; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;a, \u0026amp;b); int ans = 1; for(int i = 0; b \u0026gt; i; i++) { ans *= a; } printf(\u0026#34;%i\u0026#34;, ans); return 0; } このA問題はここ最近の中では簡単な問題だと思います。というかほとんどの言語が組み込みで冪乗計算の機能を備えているので，簡単に解けた人が多いんじゃないかと思います。 B - First Query Problem 問題文は以下の通りでした。 この問題はAtCoderによくあるタイプのクエリを処理する奴ですね。この手の問題は工夫したら真面目にクエリを処理しなくてもいい場合があります。したがって，まずは条件をよく見ることが大切です。 問題文を見ると，クエリの件数の制約や，行う必要のある操作の制約がかなり緩いことが分かります。まず第一引数が1であるようなクエリは，受け取った数列を配列などに保持するだけでO(1)で行うことができます。また，第一引数が2であるようなクエリに対しても同様です。一つしか値を操作しないので軽いですね。操作回数も105が上限となっており，愚直に処理しても十分間に合いそうです。 もしかしたら何らかの最適化があるのかもしれませんが，私は書いてある通りに実装して通りました。以下コードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n, q; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); int a[n]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;a[i]); } scanf(\u0026#34;%i\u0026#34;, \u0026amp;q); int temp; //クエリ種類 int k; // インデックス int num; // すり替え数字 for(int i = 0; q \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;temp); scanf(\u0026#34;%i\u0026#34;, \u0026amp;k); if(temp == 1) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;num); a[k - 1] = num; } else { printf(\u0026#34;%i\\n\u0026#34;, a[k - 1]); } } return 0; } クエリの種類によって与えられる引数の数が変わるのに注意です。私の実装ではシンプルにif文で分岐してあります。あと完全に余談なのですが，うえのコードでは実行時で確定していない変数を用いて配列を宣言するというC言語(C99以降?)の機能を使っているのですが，便利だけど罪悪感があります(笑) C - Cash Register 問題文は以下の通りでした。 与えられた数字をレジの機械で打ち込むときに必要なストローク数を調べるという問題でした。ほとんどの人がまずは制約に目が行くのではないでしょうか？制約は整数が10100000らしいです。デカ過ぎんだろ... デカさのイメージ図\rということで、明らかに「非常に簡単な処理」でどうにかなる、もしくは規則性などに注目して簡略化する必要があることが推察できます。そこで、問題文から具体的に考えてみます。 詳細は省きますが、具体例をいくつか考えることで「数字のキーを押す」ということと「現在表示されている数字の末尾に押した数字を追加する」ということが(一回目の入力を除いて)完全に一対一に対応していることに気づきます。すなわち、「0が二つ並んでいる」という状態を除くと、追加される数字に関係なく「キーを押す回数」=「数字の桁数」ということがわかります。 したがって、入力を文字列として受け取り、前述した「0が二つ並んでいる」状況のときのみを別処理になるようにして、あとは桁数をカウントするだけで良いです。 文字列として扱う理由は値が大きすぎてC言語組み込みのあらゆる整数型に収まらないからというのと、単純に各桁の数値を確認するだけなら配列としてアクセスしたほうが有利だからです。例えば整数型として格納できたとすると、各桁を取り出すためには割り算や剰余演算くらいしか手がないです。剰余を取る操作などは明らかに配列へのアクセスより遅く、今回の条件ではあまり意味がありません。以下はACコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[100002] = {0}; scanf(\u0026#34;%s\u0026#34;, s); int ans = 0; for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if(s[i] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;0\u0026#39;) { ans++; i++; } else { ans++; } } printf(\u0026#34;%i\u0026#34;, ans); return 0; } まず配列を100002以上で宣言します。これは、10100000=10...0(0が100000個並んでいる)で100001ブロック消費して、さらに文字列として処理しているので終端文字\\0の分が必要だからです。 前述の連続した0の処理は、二つ並んだものを見つけたら配列の参照カウントをインクリメントする処理に分岐させるようにしています。これで一回で二文字打ったということと等価になります。 見ての通り計算量的には各桁を見て回るだけなのでO(1)の処理を桁数だけ行うことになります。与えられた数字の桁数は最大で100001なので、余裕で間に合います。 D - Scope 問題文は以下の通りでした。 問題文が長くて問われていることを理解するだけでも結構大変な問題ですね。最終的にコンテスト後にACすることができたので，思考の過程を載せておきたいと思います。 問題文が複雑なので，まず問われていることを整理しました。この問題で問われていることは，細部を無視するとざっとこんな感じです。 (、)、「英小文字」のみからなる「ある条件」を満たす良い文字列が与えられる。 文字列の先頭からある操作をしていく。この時、文字列の最後まで操作を行うことができるかどうかを判定する。 (以下の議論では上の条件でぼかした「ある条件」と「ある操作」については説明しません。ご了承ください。)具体例を見ながらどういう判定法をするといいのかを考えました。例えば，具体例としてコンテストのページに乗っている入力例を以下に提示します。 この例などを見ながら考えると，良い文字列を)から遡って構成するには，(と)の数を釣り合わせればいいことに気が付くと思います。 例えば上記の入力例をとって説明しましょう。まず最初に出会う)は4文字目です。そこから遡って見返していくと，ほかの)に出会う前に(と出会うことが分かります。この場合，(と)の数が等しい最小の範囲を見つけることができました。 次に出会う)は最後の文字です。ここからさかのぼってみていくと，(に出会う前に)と出会ってしまうことが分かります。したがって，その他の)に出会わなければ2つの(が見つかった場所までが条件を満たす範囲になるはずです。もしこれが本当に正しいのか気になる人は，ほかの良い文字列のパターンなどに適用して確認してみてください。 このような操作を思いつくのは結構大変かもしれません。(実際，私はコンテスト中は間違った方針で進めてしまっていました。)個人的には，まずは「良い数列」の様々なパターンなどを書き出してみて，実際に自分がこの判定をするときにどのような部分に着目するかなどを考えるといいかもしれません。厳密に正しいという証明を出すのは難しくても，発見的手法が威力を発揮する場面は多いと思います。 それでは見つけ出した方法を愚直に実装してみましょう。私は()の数をカウントするのではなく，一番深いネストの()を終えたら()を違う文字で置き換えてしまうという方法をとりました。この操作によって，常に最初に見つかった(で止めればよくなります。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[300001] = {0}; scanf(\u0026#34;%s\u0026#34;, s); char ascii[123] = {0}; // アルファベット小文字はa-\u0026gt;97からz-\u0026gt;122だからそれぞれのインデックスに対応させる。1がたってたら使用済み for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if(s[i] == \u0026#39;(\u0026#39;) { continue; } else if(s[i] == \u0026#39;)\u0026#39;) { s[i] = 0; for(int j = 0; ; j++) { if(s[i - j] == \u0026#39;(\u0026#39;) { s[i - j] = 0; break; } else if(s[i - j] == 0){ continue; } else { ascii[s[i - j]] = 0; } } } else { if(ascii[s[i]] == 1) { printf(\u0026#34;No\\n\u0026#34;); return 0; } else { ascii[s[i]] = 1; } } } printf(\u0026#34;Yes\\n\u0026#34;); return 0; } こんな感じの実装になりました。英小文字カウンターは，asciiコード表でa~zが97~122に割り当てられているのを利用して，そのまま配列にアクセスするキーとして利用しています。途中でブレークすることなく最後までループを回せたらそれはYesの文字列だったという風に判定しています。 ...はい，このコード実はTLEを食らいました。 あれだけ自信満々に解説しておいてなんですが，これでは通らないようです。今の方針を維持したままもう少し工夫できるところがないか考えてみましょう。 具体例を見ながら条件をよく考察すると，上記のコードでは必要ない処理をかなり含んでいることが分かります。まずは以下の例を見てください。 文字列(((a(bcd)cde))ef)を考える。 まずabcdと書かれたボールが箱に入れられる。(箱の中: abcd) )に出会って，bcdが取り出される。(箱の中: a) cdeと書かれたボールが箱に入れられる。(箱の中: acde) abcdeが取り出される。(箱の中: なし) abcdeが取り出される。(二回目)(箱の中: なし) ボールefが箱に入れられる。(箱の中: ef) abcdefが取り出される。(箱の中: なし) 高橋君が操作を終えることができると分かる 注目していただきたいのは，ボールを取り出すフェーズです。よく見ると一度取り出した部分は，その後考える必要がないことが分かります。直観に反すると思うので，もう少し定性的に考えてみます。現在考えている階層より深いネストの()の中にある小文字は，以下の2パターンに分岐します。((abc)abe)を見ながら考えてみるといいと思います。 現在の階層にあるものとと同じ小文字 -\u0026gt; 「現在の階層」の)に出会えば，より深い部分に行く前にボールは取り出される。(上の例のabが該当する) 現在の階層に無い小文字 -\u0026gt; 「現在の階層」に至る前に取り出され，それ以降箱に入れられること自体がない。(上の例でcが該当する) 以上から，例えば((abc)abe)は，一回目のボール取り出しをした後は( abe)として扱っても良いということになります。 これを繰り返すことで，一回見た部分を今後見ないという改善策が見つかります。これを実装しましょう。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { char *s = (char *)calloc(300001, sizeof(char)); scanf(\u0026#34;%s\u0026#34;, s); int len = 0; for(; s[len] != \u0026#39;\\0\u0026#39;; len++) {} char ascii[123] = {0}; // アルファベット小文字はa-\u0026gt;97からz-\u0026gt;122だからそれぞれのインデックスに対応させる。1がたってたら使用済み char *s1 = NULL; for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if(s[i] == \u0026#39;(\u0026#39;) { continue; } else if(s[i] == \u0026#39;)\u0026#39;) { int j; for(j = 1; ; j++) { if(s[i - j] == \u0026#39;(\u0026#39;) { break; } else { ascii[s[i - j]] = 0; } } s1 = (char *)calloc(len - j, sizeof(char)); // 新しい配列の宣言+代入 for(int k = 0; i - j \u0026gt; k; k++) { s1[k] = s[k]; } for(int k = i + 1, k1 = i - j; len \u0026gt; k; k++, k1++) { s1[k1] = s[k]; } len = len - j - 1; i = i - j - 1; free(s); s = s1; s1 = NULL; } else { if(ascii[s[i]] == 1) { printf(\u0026#34;No\\n\u0026#34;); return 0; } else { ascii[s[i]] = 1; } } } printf(\u0026#34;Yes\\n\u0026#34;); return 0; } これでAC通りました。うれしい。 かなりごちゃごちゃしてしまいましたが，このコードの要点は， 最もネストの深い()を見つけて，ボール解放を行う。 新しく配列を宣言して，その部分のみを除いた文字列を作る。 これを繰り返しているだけです。C言語以外なら多分もっと簡潔に書けると思います。 ちなみにこれは全然最適な方法ではないらしく，今回のコンテストでC言語を用いてD問題を通した中で最も実行時間がかかっていました。余裕があればほかの人のコードも解析しようかな。 終わりに 今回の記事は書くのに過去一番時間がかかりました。ひとえにD問題が強敵だったからです。とんでもねえな 実はいまだにコンテスト中にD問題を通したことがありません。そろそろ通させてくださいマジで。ちなみにレーティングが今回で199まで上がったので，茶色までの折り返しに到達しました。何とか茶色に到達できるように今後も頑張っていけたらなと思います。 完全に私事ですが，このくらいの規模の記事になると流石にタグ含めすべてを手打ちするの結構大変になってきました。もうちょっと何とかしたいです。 それではここまで読んでいただきありがとうございました。よいお年を。"
  },
  {
    url: "/post/abc282/",
    title: "ABC282参加記録",
    date: "2022-12-18T00:00:00Z",
    body: "ABC282参加記録 \r今週もABC参加してきた こんにちは，冷凍うどんを食べようとしたら鍋の口が小っちゃくて入らなかったInです。 毎週ABCに参加し続けて，今回のABC282で5回目になりました。今週も結果報告と自分の忘備録を兼ねて記事を残しておきます。 結果報告のコーナー まずはいつも通り結果報告からです。今回の提出状況はこのような感じでした。 まずB問題で問題文の読み間違えが発生して無駄に悩んだ挙句，C問題で3WAを出して爆死しました。はい。結果的にはABCの三完でした。何とか途中で修正できてよかったです。ちなみにD以降は私にはもうちんぷんかんぷんでした。 今回のコンテストによるレーティング変動は，以下の通りでした。ジャン！ コラ～～～～！！！！！！！ ...ということで爆死でした。パフォーマンスは210で，今までで2番目に低い値を記録してしまいました。絶望感漂う中，記事を書いていきたいと思います。 もう終わりだよこの国 問題と解法 どんなふうに問題を解いたかを紹介します。 A問題 問題文は以下の通りでした。 与えられた整数Kの分だけ英大文字を出力する問題です。制約からZよりあとに関しては考えなくてもいいことが分かります。したがって，ASCIIコードを利用してprintf関数で標準出力に出力していけばオーケーです。 もう少し具体的に言うと，ASCIIコード表によると，英大文字は65番にAから始まって，90番にZまで順番に割り当てられています。したがって，ループ毎に1ずつ増やしていけばオーケーです。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int k; scanf(\u0026#34;%i\u0026#34;, \u0026amp;k); for(int i = 0; k \u0026gt; i; i++) { printf(\u0026#34;%c\u0026#34;, 65 + i); } return 0; } 最近のABCは毎回ASCIIコード表を見ながらやってる気がします。次B問題です。 B問題 問題文は以下の通りです。 N人の人が，コンテストに出題される各問題を解けるかどうかのデータが渡されます。参加者から2人を選んで，コンテストの問題をすべて解けるペアを作るとするとき，作ることができるペアの数を調べる問題です。 この時，作ることができるペアとは，「同時に作ることができるペア」ではないことに注意する必要があります。私はこれを勝手に同時に作ることができるペアの数のことだと勘違いして，永遠に悩んでいました。 また，この問題にはもう一つ注意する必要のある点があります。それは，ペアには順序を考えないことです。具体的には，ある一人を選んで，その人が一緒に組むことで全問正解できるようなペアをすべて列挙していくコードで解こうとすると，気を付けないとA-BのペアとB-Aのペアを区別してカウントしてしまうということが起こります。私はこの方針で解きましたが，前述の問題は，二重forループの二重目のループ変数を，一重目のループ変数で初期化することで対処しました。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n, m; // nが人，mが問題 scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;m); char s[n][31]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[i][0]); } int ans = 0; char flag = 0; for(int i = 0; n \u0026gt; i; i++) { for(int j = i; n \u0026gt; j; j++) { if(i == j) { continue; //同じ番号同士は考えない } for(int k = 0; m \u0026gt; k; k++) { if(s[i][k] == \u0026#39;x\u0026#39; \u0026amp;\u0026amp; s[j][k] == \u0026#39;x\u0026#39;) { //ダメだった flag = 1; break; } } if(flag == 0) { ans++; // 可能ペア発見 } else { flag = 0; //戻す } } } printf(\u0026#34;%i\u0026#34;, ans); return 0; } 少し見にくいかもしれません。すみません。途中3重forループがありますが，最初の二つが人を選ぶところと対応しており，三つめが問題をすべて解けるかの判定になっています。 C問題 最後にC問題です。問題文は以下の通りです。 \u0026quot;に挟まれていない部分にのみ違う処理を施して，文字列を得る問題です。 正直，この問題はC問題の中では簡単なほうかなと思います。(簡単というのは，方針が思い浮かびやすいという意味です。)しかし，私はこの問題で大コケしてしまい，*順位が死にました。*結構ガチでショックです。 解法としては，文字列を配列で受け取り，\u0026quot;を発見したら，次の\u0026quot;までそのまま出力するようにするとオッケーです。この分岐の処理をいかに簡単にするかがキモだと思います。 まずは私がWAを出したクソコードを載せます。反面教師です。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n]; scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[0]); for(int i = 0; n \u0026gt; i; i++) { if(s[i] == \u0026#39;\u0026#34;\u0026#39;) { printf(\u0026#34;%c\u0026#34;, s[i]); for(int j = i + 1; s[j] != \u0026#39;\u0026#34;\u0026#39;; j++) { if(s[j] == \u0026#39;,\u0026#39;) { printf(\u0026#34;%c\u0026#34;, \u0026#39;.\u0026#39;); } else { printf(\u0026#34;%c\u0026#34;, s[j]); } i++; } i++; printf(\u0026#34;%c\u0026#34;, s[i]); } else { printf(\u0026#34;%c\u0026#34;, s[i]); } } return 0; } まずはクソコードその一です。言うまでもなくこのコードの抱える一番の問題点は，とにかくごちゃごちゃしている点です。このコードはprintf関数を5回も使っており，いかに事前にどうやって組むかを考えていなかったかがバレバレです。また，もう一つの重大な欠点は問題の要求と逆の処理をしていることです。問題文の読み違えには気を付けよう！(公開ブログでゆうさくを貼れるほど度胸は無かった) お次に，これをもう少し修正したけどダメだったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n]; scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[0]); for(int i = 0; n \u0026gt; i; i++) { if(s[i] == \u0026#39;\u0026#34;\u0026#39;) { printf(\u0026#34;%c\u0026#34;, s[i]); i++; for(; s[i] != \u0026#39;\u0026#34;\u0026#39;; i++) { printf(\u0026#34;%c\u0026#34;, s[i]); } printf(\u0026#34;%c\u0026#34;, s[i]); i++; } if(s[i] == \u0026#39;,\u0026#39;) { printf(\u0026#34;%c\u0026#34;, \u0026#39;.\u0026#39;); } else { printf(\u0026#34;%c\u0026#34;, s[i]); } } return 0; } このコードは，問題ページにあるテストケースは無事に突破しました。しかし，いまだ重大な問題を抱えています。それは*極端な入力に対してバッファーオーバーランが起こりえます。*これはヤバい(確信) このコードは，最初に\u0026quot;が来たかどうかを判定して，来ていたら次の\u0026quot;までそのまま出力し続けるようにしてあります。これだけ聞くとまともそうですが，一番ダメなのはインクリメントを管理しきれていない点です。ループの途中に分岐点を作っていたりする関係上，コード中のあちこちでインクリメントが発生するせいでバグを追いきれませんでした。 例えば入力が\u0026quot;\u0026quot;\u0026quot;\u0026quot;だったりすると，余分なインクリメントが発生してバッファの外側に突き抜けます。そして次の\u0026quot;が見つかるまで止まることはありません。うーんこの 最後にAC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n]; scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[0]); for(int i = 0; n \u0026gt; i; i++) { if(s[i] == \u0026#39;\u0026#34;\u0026#39;) { printf(\u0026#34;%c\u0026#34;, s[i]); i++; for(; s[i] != \u0026#39;\u0026#34;\u0026#39;; i++) { printf(\u0026#34;%c\u0026#34;, s[i]); } printf(\u0026#34;%c\u0026#34;, s[i]); continue; } if(s[i] == \u0026#39;,\u0026#39;) { printf(\u0026#34;%c\u0026#34;, \u0026#39;.\u0026#39;); } else { printf(\u0026#34;%c\u0026#34;, s[i]); } } return 0; } このコードはさっきのコードにcontinue処理を挟むことで(一時的なものですが)さっき挙げた不正なインクリメントを防止しています。 教訓: インクリメントはわかりやすい場所で管理しよう。continueやbreakをちゃんと使おう。 完走した感想 今回のコンテストはかなり残念な感じになってしまいました。しかしとりあえずC問題まででも解けて良かったです。結構実装の技術的な点でコケることが多いなと感じているので，もっと問題数を解いてデバッグなどに慣れたいです。また，D問題以降は数学的知識や競プロ的な技術がかなり問われる問題かなと(一見)思いました。したがって，大学での数学の勉強などはしっかり頑張りたいです。(願望) 今回の結果はかなり来るものがあるけど，今日体調悪かったから多少はね？ ここまで読んでいただき，ありがとうございました。また次の記事でお会いしましょう。ちなみに一週間後のUECアドベントカレンダーに登録したはいいもののまだ一文字も書いていません(絶望)じゃあね。"
  },
  {
    url: "/post/abc281/",
    title: "ABC281に参加してきた。",
    date: "2022-12-10T00:00:00Z",
    body: "ABC281に参加してきた。 今週もABCに参加してきたよ こんにちは。あいも変わらず今週もABCに参加してきました。その結果報告の記事です。 今回の戦績発表 まずは今回の戦績です。以下は今回の私の提出です。 今回は珍しくWAを出さずにコンテストを終えることができました。D問題は解けなかったので，実質コンテスト参加時間は30分でした笑 ちなみにレーティングは今回で+62でした。着々と上がっている感じが結構うれしいし，モチベーションになっているような気がします。 解法など 今回の記事も，自分がどうやって解いたかを残しておきます。 A問題 以下は問題文です。 今回のA問題は最近の中では簡単なほうかな？っていうのが率直な意見です。この問題はforなどのループ構造を書ければ回答できそうですね。具体的には，受け取った数字分のループを回して，その中で変数をデクリメントしながら出力すればオーケーですね。以下は私の提出です。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); for(int i = n; i \u0026gt;= 0; i--) { printf(\u0026#34;%i\\n\u0026#34;, i); } return 0; } c言語ではfor文でインデックス変数が利用できるので，比較的簡単に記述することができます。 B問題 まずは問題文です。 文字列の照合問題ですね。正直この手の問題は結構苦手とするところですが，，，今回は何とか解けました。 方針としては，まず与えられた文字列をscanf関数で文字列型として読み取って，ASCIIコードで照合していきました。具体的に言うと，まず「先頭の文字が一文字の英大文字」という条件は，受け取った文字列が入っている配列の一つ目の要素が，「数値として」65以上かつ90以下という条件により判別することができます。このようなことを繰り返して判別していきます。以下はACが通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[11] = {0}; //全部ゼロで初期化する scanf(\u0026#34;%s\u0026#34;, s); if(!(s[0] \u0026gt;= 65 \u0026amp;\u0026amp; 90 \u0026gt;= s[0])) { // 頭大文字チェック printf(\u0026#34;No\\n\u0026#34;); return 0; } if(s[1] == 48) { printf(\u0026#34;No\\n\u0026#34;); return 0; } for(int i = 1; 7 \u0026lt; i; i++) { if(!(s[i] \u0026gt;= 48 \u0026amp;\u0026amp; 57 \u0026gt;= s[i])) { printf(\u0026#34;No\\n\u0026#34;); return 0; } } if(!(s[7] \u0026gt;= 65 \u0026amp;\u0026amp; 90 \u0026gt;= s[7])) { // ラスト大文字チェック printf(\u0026#34;No\\n\u0026#34;); return 0; } if(s[8] != 0) { // きっちり8文字かチェック printf(\u0026#34;No\\n\u0026#34;); return 0; } printf(\u0026#34;Yes\\n\u0026#34;); return 0; } コメントで「きっちり8文字かチェック」と書かれている部分について少しだけ補足します。今回の問題の制約では，ASCIIコードにおいて十進数表示で0になるような文字が入力されることがないので，この条件により確実に仕分けることができます。しかし，一般的な場合に関してはそうとは限らないので，注意が必要です。(今回0という条件にしたのはたまたま配列を0で初期化しようと思ったからというだけで特に深い理由はありません。) C言語でこういう文字列処理をするのはかなり面倒くさいですね。。。もっといい方法があるのかもしれませんが。 C問題 以下問題文です。 循環するプレイリストにおいて，与えられた時間が経過したときに何曲目が流れているかを考える問題ですね。 この問題を考える上でまず大切なのが，プレイリストの総再生時間よりも再生時間が大きくなるようなパターンが存在することです。この時，プレイリストの総再生時間分だけ経過したら一番最初の状態に戻るので，再生時間を総再生時間で割った余りを考えることで問題を簡単にすることができます。(なお，総再生時間が再生時間よりも大きいような場合には，再生時間がそのまま余りとなります。したがって，とりあえず剰余を考えるという方法でも大丈夫です。) この後，その余りを，一つ一つの楽曲再生時間の和が超えたタイミングが答えの曲の位置になります。これはほぼ自明ですね。 以下は提出コードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; long long int t; long long int sum = 0; // 全曲の総再生時間 scanf(\u0026#34;%i %lli\u0026#34;, \u0026amp;n, \u0026amp;t); int a[n]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;a[i]); sum = sum + a[i]; } if(t \u0026gt; sum) { t = t % sum; } sum = 0; //sumリセット int num; for(int i = 0; ;i++) { sum = sum + a[i]; if(sum \u0026gt; t) { num = i + 1; sum = sum - a[i]; break; } } printf(\u0026#34;%i %lli\\n\u0026#34;, num, t - sum); return 0; } やっていることはほとんど上で書いたことそのままです。ただし，for文のインデックス変数が(というより配列の要素が)0からスタートする一方，曲の順番は1からスタートするので気を付けましょう。 D問題 D問題は，解けなかったよ。。。(n回目) とりあえず問題の紹介だけはします。以下問題文です。 つまりは，Aの元から任意にK個を選んできて，それらを足したものの集合を考えるときに，与えたDの倍数であるようなもので最大のものを探すというものです。 この問題の恐ろしいところは，Aの元から任意にK個を選ぶ組み合わせの数が非常に大きくなることがあるという点です。この問題において最悪ケースを考えると， Aの要素が100個 Kが50(詳細は省きます) となるときです。この時の組み合わせの数はなんと100,891,344,545,564,193,334,812,497,256になります。どう考えても愚直にやるのは無理です。 しかし現在の私ではこの問題に対する有効な解法はわかりませんでした。なのでC問題を解き終わってからコンテスト終了まで机の前でｳﾝｳﾝうなってました。う～ん，アホ！w なお，コンテスト終了後に公開される解説によると，この問題は動的計画法なるもので解くことができるらしいです。知らんが？ というわけでボロボロでした。精進します。 終わりに 今回の参加記は以上です。だんだんレートが上がっているとは言えども，専門的なアルゴリズムの知識なんてないのでこういう問題にぼこぼこにされる日々です。しかし，思ってる以上に競プロを通じて数学などに触れることは新鮮で楽しいと思っています。今のところは。ということでこれからも頑張っていけたらなと思います。 DPなんかねえよ(K重forループをおもむろに書き始める) というわけで，ここまで読んでいただきありがとうございました。また次の記事でお会いしましょう。"
  },
  {
    url: "/post/abc280/",
    title: "ABC280に参加してきました！",
    date: "2022-12-04T00:00:00Z",
    body: "ABC280に参加してきました！ 今回もABCに参加してきました。 どうもこんにちは。大学の課題が結構やばいことになっているInです。今回もABCに参加してきましたので，その参加記事になっております。別に競技プログラミングのためだけにこのブログ(?)を開設したわけじゃないのに，現状では競技プログラミングの記事しかないことを憂いております。(やる気やらなんやらの問題で筆が進まないんですよね) 閑話休題。それでは今週の参加感想記事です。 結果発表のコーナー 今週の提出結果です。 なんと今回は運よくCまで解くことができました。(ドンドンパフパフ) 今回の成績は，4888/8672で，パフォーマンス375でした。そこそこよろしいんじゃないでしょうか？(そこ，灰パフォでイキるなとか言わない！)レーティング変動は今回プラス34で現在104です。入茶が楽しみです。 解法やらなんやらの振り返り 今週もいつものごとく問題をどのように解いたのかを忘備録として記録しておきます。まずはA問題です。 *Oh...*今週のA問題はなんだか見た目がいかついですね。正直A問題でつまずいて死ぬパターンかと思いました。 さて，見た目はいかついですが，この問題はよく見てみるとそんなに難しいことを言っていないことが分かります。 要するに#.##...#←こんな感じの文字列(文字列一つにつきW個の文字)がH回入力されるので，#の数を数えてくださいねということです。先週の文字列祭りに比べたらだいぶんましですね。方針としては，HもWも少ないのが制約からわかるので，シンプルに文字列として標準入力から読み取って，一文字づつ見ていく感じで処理しました。以下コードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int h, w; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;h, \u0026amp;w); char word[11]; int count = 0; for(int i = 0; h \u0026gt; i; i++) { scanf(\u0026#34;%s\u0026#34;, word); for(int j = 0; w \u0026gt; j; j++) { if(word[j] == \u0026#39;#\u0026#39;) { count++; } else if(word[j] == \u0026#39;0\u0026#39;) { break; } } } printf(\u0026#34;%i\\n\u0026#34;, count); return 0; } そこそこシンプルに書くことができました。ある程度標準入出力の使い方には慣れてきたんじゃないかなと思います。 さて，次はB問題です。以下問題文です。 記号と数字がわちゃわちゃしていて結構ウッってなる人多いかもしれません。僕もそうでした。 しかし，一回紙に書くとかなりシンプルに整理されることが分かります。 実際，Sk+1=Sk+Ak+1が成立しますから，逆に見るとAk=Sk-Sk-1(ただしS0=0) という関係式が成り立つことが分かります。したがって，二つのSから一つのAを錬成しながら出力していく方針で解けます。いやー数学って偉大ですね。以下通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); int s1, s2; s1 = 0; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;s2); printf(\u0026#34;%i \u0026#34;, s2 - s1); s1 = s2; } return 0; } なんとA問題よりも短くなってしまいました。個人的には実装含めての難易度だと今回Bのほうが簡単だと思いました。 あと余談なんですが，誰が読んでも誤解を与えないという点では競プロのような問題文の書き方は適切だとは思いますが，記号を大量に使用するのは可読性っていう点だとどうなのかなってちょっと思ったりします。まあ例がついているので支障はそんなにないですが。 次はC問題です。以下問題文です。 英小文字のみからなる文字列を比較する問題のようです。文字列TはSにもう一つだけ文字を追加して作られているもののようですね。今回のC問題はなんかやたらとシンプルで助かりました。 方針としては，まず二つの配列を用意して文字列として読み取り，次にSとTを頭から見ていって，初めて一致しなくなった場所が答えという感じで行きました。配列としてみるときはインデックスが一つずれるので注意です。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[500001]; char t[500002]; scanf(\u0026#34;%s\u0026#34;, s); scanf(\u0026#34;%s\u0026#34;, t); for(int i = 0; ; i++) { if(s[i] != t[i]) { printf(\u0026#34;%i\\n\u0026#34;, i + 1); break; } } return 0; } こんな感じで実装しました。手元のマシンだとstaticではない配列の宣言で要素500000とかあまりやらないので結構ジャッジサーバーは融通効くなって印象です。 ちなみに余談ですが，この問題多くの人が引っ掛かったポイントがあったようで，(自分も1WA食らいました。)それは，「Sの最後に付け足すパターン」の見落としです。このミスは初心者から上位勢までみんな食らっててちょっと面白かったです。おそらく多くの人が引っ掛かった理由は，普通は\\0(終端文字)が出現したら読み取りのループをブレークするのですが，この問題に関しては必ずTがSから構成される文字列であることが保証されているので，そんな気遣いをしなくてもOKだったっていう感じだと思われます。 D問題は，，解けなかったよ 今回Cの提出まで結構スムーズに行けたので，「お！ワンチャンあるか？」と思っていましたが，D問題結局解けませんでした。。。 Dの問題文は以下の通りでした。 この問題，見た目は結構シンプルなんですが，かなり厄介で手を動かすだけだと無理でした。 というのも，直接階乗を計算するのが無理なんですよね。 Cでの整数型の最大値unsigned long long intの最大が，18446744073709551615となっており，20桁まで入るんですが，実は20!の時点で18桁の整数になります。 階乗はおそロシア。なので，ほかの部分に注目して行かなくてはいけないんですけど，効率的な方法を見つけられなかったのと，実装力の低さのせいでスパゲッティコードを錬成してタイムアップしました。ただ，数学的に解を見つけられそうなので解けたら別記事として投稿したいなとは思っています。 終わりに ABCを始めてから3週間ほどたちますが，少しは成長したのかなと思います。課題で忙しい時もありますが，ドンドンAtCoder Beginer's Selectionや競プロ典型90問などにも取り組んでいけたらいいなと思います。(アルゴ式も)目指せ茶コーダー！ 余談ですが，このサイトに投稿されている記事は，markdownからの変換とかではなくすべてhtmlを手打ちしているので，手書きhtmlかなり慣れてきたような気もします。いいことなのかは知らん。 今回も読んでいただきありがとうございました。次の記事で会いましょう。 P.S. UEC Advent Calendar1とUEC Advent Calendar2が開催中ですので，興味があったら皆さんも読みましょう。(私も24日に寄稿(?)予定です。)"
  },
  {
    url: "/post/abc279/",
    title: "ABC279参加してきた！",
    date: "2022-11-27T00:00:00Z",
    body: "ABC279参加してきた！ はじめに 今回ABC279に参加してきましたので，その記録です。 今回の成績 まずは今回の成績からです。以下画像です。 AとBしか，解けませんでした！！！！(キース団長並感) いや，文字列扱う問題多くないですか？？？？？？私は文字列を操作する練習を全然してなかったのでB問題で死ぬほど苦労しました... 今回はあまり語るようなことがないので，サクッと解法紹介と今回の反省のパートに行きたいと思います。 解法 (注意: 筆者はc言語使ってます。)まずはA問題からです。以下問題文です。 これは文字列を扱う練習みたいな問題ですね。「下に尖った部分」というのはvは1箇所，wは2箇所なので，文字列を最初から見ていって，「vの個数」× 1と「wの個数」× 2を足したものをprintf関数で標準出力で出したらオッケーですね。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char a[100]; scanf(\u0026#34;%s\u0026#34;, a); int score = 0; int i = 0; while(a[i] != \u0026#39;\\0\u0026#39;) { if(a[i] == \u0026#39;v\u0026#39;) { score = score + 1; } else if(a[i] == \u0026#39;w\u0026#39;) { score = score + 2; } i++; } printf(\u0026#34;%i\\n\u0026#34;, score); return 0; } 関係ない話ですが，問題の名前が「wwwvvvvvv」だったり問題文に平気で「尖っている部分」とか書いてあるのが地味にじわじわ来る問題ですね。 お次はB問題です。以下問題です。 この問題は全探索で解きました。簡単に流れを説明すると，まず最初に文字列Tの最初の文字を文字列Sの先頭から探します。見つかったら一文字ずつ後続も一致しているか確認して，もしTが'\\0'(終端文字)になるまでずっと一致していたら，Sは条件を満たしていたということが分かるので，適当にフラグを立ててループを抜けます。ここで後続に一致しないものが存在した場合は，また先頭文字が一致するか順に確認していきます。このサイクルをSが終端文字になるまで続けてもフラグがたたなかった場合は，条件を満たさないということが分かります。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char S[101]; char T[101]; //比較する方 scanf(\u0026#34;%s\u0026#34;, S); scanf(\u0026#34;%s\u0026#34;, T); int flag = 0; for(int i = 0; S[i] != \u0026#39;\\0\u0026#39;; i++) { if(T[0] == S[i]) { int k = i; int j = 0; for(; S[k] == T[j] \u0026amp;\u0026amp; T[j] != \u0026#39;\\0\u0026#39;;) { k++; j++; } if(T[j] == \u0026#39;\\0\u0026#39;) { flag = 1; } } } if(flag == 1) { printf(\u0026#34;Yes\\n\u0026#34;); } else { printf(\u0026#34;No\\n\u0026#34;); } return 0; } *この問題を通すのに本当に苦労しました。。。*実はこの問題を通すだけで今回1時間8分，WAを6回も出したことで私の順位がボロボロになりました。泣きそうです。 この問題では文字列を扱うときは必然と'\\0'の検出が必要になるのですが，それを「whileの条件式で簡単にかけるやろw」とか思ってたらマジで痛い目見ました。とにかくループ用の変数がわちゃわちゃしてしまって，ループを抜けるときの条件式がぐちゃぐちゃになってしまったのが痛すぎました。。。泣きそうです(2回目) もうwhileなんて使わない(知らんけど) ちなみに，この問題でつまずいた理由はおそらく配列の余った要素がすべて0であることを見逃していたことだと思います。アホですか？ ラスト，ACは取れなかったもののC問題を紹介しておきます。以下問題です。 この問題は正直知識不足でした。せっかくですので私の行おうとした解法を説明します。 与えられた図形SとTが「列の並べ替え」によって一致すればよいということですので，受け取ったデータをリアルタイムに処理することはできなさそうです。したがって，いったん配列に保持することにしました。この問題では行番号と列番号の情報が重要ですので，二次元配列を用意して代入しました。そして，「並べ替え」によって同じものが作れるということは，「Sのある列」を持ってくると，常に必ず一つ以上「Tのある列」が一致しているという言い換えが可能です。これなら全探索により実装可能だと判断したので，この方針で行きました。実はこの探索方法，ほとんどB問題と同じです。一番ACに近かったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int H, W; //Hは行数，Wは列数 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;H, \u0026amp;W); char buffer; int flag = 0; int delflag = 0; int ans = 0; char S[H][W]; char T[H][W]; for(int i = 0; H \u0026gt; i; i++) { for(int j = 0; W \u0026gt; j; j++) { scanf(\u0026#34; %c\u0026#34;, \u0026amp;buffer); S[i][j] = buffer; } } for(int i = 0; H \u0026gt; i; i++) { for(int j = 0; W \u0026gt; j; j++) { scanf(\u0026#34; %c\u0026#34;, \u0026amp;buffer); T[i][j] = buffer; } } for(int i = 0; W \u0026gt; i; i++) { for(int j = 0; W \u0026gt; j; j++) { if(S[0][i] == T[0][j]) { for(int k = 0; H \u0026gt; k; k++) { if(S[k][i] != T[k][j]) { flag = 1; break; } } if(flag != 1) { for(int l = 0; H \u0026gt; l; l++) { T[l][j] = 0; } delflag = 1; break; } flag = 0; } } if(delflag != 1) { printf(\u0026#34;No\\n\u0026#34;); return 0; } } for(int i = 0; W \u0026gt; i; i++) { if(T[0][i] != 0) { ans = 1; break; } } if(ans == 1) { printf(\u0026#34;No\\n\u0026#34;); } else { printf(\u0026#34;Yes\\n\u0026#34;); } return 0; } このコードで最終的にTLEが2ケースでした。考え方自体は正解を出せるコードみたいです。 公式解説では，私のとった手順と似たようなものでしたが，最後の同じ列が存在するかの判定を「文字列のソート」にて実現していました。私は文字列の扱いに関してほとんど何もわかっていなかったので，選択肢にすらあがらなかったです。次頑張ります。 余談ですが，終了後に私のコードを見た並走者が，あまりのforループの深さにびっくりしていました。こんな頭の悪い全探索しか書けないの正直ね。。 *True Programer* only use for statement and if statement.(逆張り) 終わりに 正直にいうと，今回の結果は非常に悔しかったです。もっとほかの問題に時間をかけられると思っていたし，レーティングもあまり気にしていないとはいえ重要な指標の一つでしょう。「この悔しさをバネに～」みたいな文言めちゃくちゃ嫌いなんですが，今はそんな気分です。来週のABCに向けてできるだけ準備したいと思います。 今回解けなかったC問題はもう少し取り組んでみようと思います。もし解けたら追記します。 長文読んでいただきありがとうございました。"
  },
  {
    url: "/about/",
    title: "About",
    date: "0001-01-01T00:00:00Z",
    body: "About About Me 電気通信大学に在学中。 最近は競技プログラミングをよくやっています。 ハンドルネームはInかInTheBloomを使っていることが多いです。 サイトの方針 常識的に問題ないと思う範囲で書きたいことを書こうかなと思っています。 google analyticsなどのアクセス解析は特に利用していません。 私が作ったコンテンツに関しては自由に利用してもらって大丈夫です。(そんなやついるのか？) 連絡先 Twitter(X) gmail (nato.rider.smm2 [at] gmail.com) など 最後に 当サイトはgithub pages、hugo、simplogのおかげで作成できました。ありがとう！"
  },
];

function search(query) {
  const result = searchData(query);
  const html = createHtml(result);
  showResult(html);
  showResultCount(result.length, data.length);
}

function searchData(query) {
  
  
  const result = [];

  query = query.trim();
  if (query.length < 1) {
    return result;
  }
  const re = new RegExp(query, 'i');
  for (let i = 0; i < data.length; ++i) {
    const pos = data[i].body.search(re);
    if (pos != -1) {
      result.push([i, pos, pos + query.length]);
    }
  }
  return result;
}

function createHtml(result) {
  const htmls = [];
  for (let i = 0; i < result.length; ++i) {
    const dataIndex = result[i][0];
    const startPos = result[i][1];
    const endPos = result[i][2];
    const url = data[dataIndex].url;
    const title = data[dataIndex].title;
    const body = data[dataIndex].body;
    htmls.push(createEntry(url, title, body, startPos, endPos));
  }
  return htmls.join('');
}

function createEntry(url, title, body, startPos, endPos) {
  return '<div class="item">' +
      '<a class="item_title" href="' + url + '">' + title + '</a>' +
      '<div class="item_excerpt">' + excerpt(body, startPos, endPos) + '</div>' +
      '</div>';
}

function excerpt(body, startPos, endPos) {
  return [
    body.substring(startPos - 30, startPos),
    '<b>', body.substring(startPos, endPos), '</b>',
    body.substring(endPos, endPos + 200)
  ].join('');
}

function showResult(html) {
  const el = document.getElementById('result');
  el.innerHTML = html;
}

function showResultCount(count, total) {
  const el = document.getElementById('resultCount');
  el.innerHTML = '<b>' + count + '</b> 件見つかりました（' + total + '件中）';
}
</script>

</body>







<hr class="block-separater">










<div class="content-footer-item neighbor">
	
	
</div>














<script src="/js/single.js"></script>





	</div><div id="content-footer" class="sub">
  
  <div class="credit">
    Power by <a href="https://gohugo.io">Hugo</a> /
    Theme <a href="https://github.com/michimani/simplog/">simplog</a> by <a href="https://github.com/michimani/">michimani</a>
  </div>
</div></body>

</html>