<!DOCTYPE html>
<html lang="ja">
<head>





<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>サイト内全文検索 - InTheDayDream</title>
<meta name="description" content="">

<meta name="author" content="">

<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
<link rel="alternate" href="/index.xml?c=93bcfa7a4367e382b6ad29505ba71bab8b405724" type="application/rss+xml" title="RSS" />
<meta property="og:title" content="サイト内全文検索 - InTheDayDream">
</meta>
<meta property="og:url" content="http://inthebloom.github.io/search/">
<meta property="og:type" content="article">
<meta property="og:site_name" content="InTheDayDream">
<meta property="og:description" content="">

<meta property="og:image" content="http://inthebloom.github.io//images/featured_image.jpg">

<meta name="twitter:card" content="summary_large_image" /></meta>
<meta name="twitter:site" content="@UU9782wsEdANDhp"></meta>
<meta name="twitter:creator" content="@UU9782wsEdANDhp"></meta>
<meta name="twitter:title" content="サイト内全文検索 - InTheDayDream"></meta>
<meta name="twitter:url" content="http://inthebloom.github.io/search/"></meta>
<meta name="twitter:description" content=""></meta>

<meta property="og:image" content="http://inthebloom.github.io//images/featured_image.jpg">


<link rel="stylesheet" href="/css/main.css?c=93bcfa7a4367e382b6ad29505ba71bab8b405724">
<link rel="stylesheet" href="/css/color.css?c=93bcfa7a4367e382b6ad29505ba71bab8b405724">


<link rel="stylesheet" href="/css/custom.css?c=93bcfa7a4367e382b6ad29505ba71bab8b405724">



</head>

<body class="theme-default">






<div id="content-header" class="title">
  
  <a class="site-title" href="/">InTheDayDream</a>
  
  <span class="site-sub-title"></span>

  

  <div id="main-menu-nav">
    <div id="main-menu-nav-items">
      
        <div class="nav-item"><a href="/">Home</a></div>
      
        <div class="nav-item"><a href="/tags/">Tags</a></div>
      
        <div class="nav-item"><a href="/archives/">Archives</a></div>
      
        <div class="nav-item"><a href="/about/">About</a></div>
      
        <div class="nav-item"><a href="/search/">Search</a></div>
      
    </div>
  </div>
</div>
<div id="content" class="main">




<h1>サイト内全文検索</h1>








<p>サイト内の文章からインクリメント検索が可能です。
下の入力欄に入力することで検索ができます。</p>
<p>本ページは検索の対象外になっています。</p>

<head>
  <meta charset="UTF-8">
  <style>
    body {
      background: #fafafa;
    }
    input {
      color: deeppink;
      font-size: 1.2em;
      font-weight: bolder;
    }
    input::-webkit-input-placeholder {
      color: pink;
    }
    #result {
      margin: 1em;
    }
    .item_title {
      text-decoration: none;
      color: #36f;
      font-weight: bolder;
    }
    .item_excerpt {
      background: white;
      margin: 0.5em 2em 1em;
      padding: 0.5em;
      border: dashed 1px lightgray;
      font-size: smaller;
    }
    .item_excerpt b {
      background: pink;
    }
  </style>
</head>
<body>

<input onkeyup="search(this.value)" size="15" autocomplete="off" autofocus placeholder="検索ワード" />
<span id="inputWord"></span> <span id="resultCount"></span>
<div id="result"></div>

<script>

const data = [
  {
    url: "/post/abc167e/",
    title: "ABC167E - Colorful Blocks",
    date: "2024-01-03T00:00:00Z",
    body: "ABC167E - Colorful Blocks 問題概要 問題へのリンク $N$個の横一列に並んだブロック列に色を塗る。 色は整数で表され、$1$から$M$までの$M$種類ある。 必ずしもすべての色を使う必要はない。 隣り合うブロックが同じ色である箇所が$K$以下の色の塗り方の総数を$998244353$で割ったあまりを求めよ。 制約 $1 \\leq N, M \\leq 2 \\times 10^5$ $0 \\leq K \\leq N-1$ 考察 dp解を考えてみよう。 $dp[i][j] = (iブロック目まで塗って、隣り合うブロックが同じ色である場所がj個であるような塗り方の総数)$ とすれば、初期値 $dp[1][0] = M$ 更新 $dp[i+1][j] = (M-1) * dp[i][j]$ $dp[i+1][j+1] = dp[i][j]$ とすることで、$O(NK)$で解くことができる。 import std; void main () { int N, M, K; readln.read(N, M, K); solve(N, M, K); } void solve (int N, int M, int K) { const long MOD = 998244353; long[][] dp = new long[][](N+1, K+1); foreach (d; dp) d[] = 0; dp[1][0] = M; foreach (i; 1..N) { for (int j = 0; j \u0026lt;= K; j++) { dp[i+1][j] += (M-1) * dp[i][j] % MOD; dp[i+1][j] %= MOD; if (j \u0026lt; K) { dp[i+1][j+1] += dp[i][j]; dp[i+1][j+1] %= MOD; } } } long ans = 0; foreach (d; dp[N]) { ans += d; ans %= MOD; } writeln(ans); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } しかし、これでは間に合わない。 どうにか他の方法を考えよう。 こういうときは、他にうまいdpがあることは(この難易度帯では)少なく、 うまく数学で解くことが多い。 まず、隣り合う数を固定して(以下、$x$で考える)考える。 前から順番に色を塗っていくと考えると、$i$番目のブロックを塗る時、 $i-1$番目のブロックと色が同じ時、隣り合う同じ色の場所の数は増える。(場合の数は$1$倍) $i-1$番目のブロックと色が違う時、隣り合う同じ色の場所の数は変わらない。(場合の数は$M-1$倍) が$2$以上の$i$に対して常に成立することがわかる。 すなわち、最後まで塗った結果隣り合う色が同じ場所が$x$となるような塗り方は、 パターン1を$x$回、パターン2を$N-1-x$回経たようなものに限定されることになる。 また、$i=1$のときは何色で塗っても「一つ前」がいないので変わらなく、$M$通りになる。 どこでパターン2を引くかの自由度を考えると、これは$\\binom{N-1}{N-1-x}$通りであるから、最終的に場合の数は 上で議論したものにこれをかけた値、つまり $$ M \\times 1^{x} \\times (M-1)^{N-1-x} \\times \\binom{N-1}{N-1-x} = M \\times (M-1)^{N-1-x} \\times \\binom{N-1}{N-1-x} $$ 通りであり、解はこれを$0 \\leq x \\leq K$の範囲で合計したものになる。 適切な前計算の元、一つ固定した$x$に対して$O(\\log N)$で求められるため、問題を$O(N \\log N)$で解くことが出来た。 実装例 import std; void main () { int N, M, K; readln.read(N, M, K); solve(N, M, K); } void solve (int N, int M, int K) { /* 前から順番に色を塗っていくことを考える。 1通りの現状維持(同じ色+1) or M-1通りの色変え(同じ色維持) をN-1回迫られるという考え方で行く。 */ const long MOD = 998244353; long[] fact = new long[](N+1); long[] factInv = new long[](N+1); fact[0] = factInv[0] = 1; foreach (i; 1..N+1) { fact[i] = i*fact[i-1] % MOD; factInv[i] = modInv(fact[i], MOD); } long comb (int n, int k) { if (n \u0026lt; k) return 0; long res = fact[n] * factInv[k] % MOD; res *= factInv[n-k]; return res % MOD; } long ans = 0; for (int i = 0; i \u0026lt;= K; i++) { /* i組の隣が同じ色のペアが存在する */ long add = M*comb(N-1, N-1-i) % MOD; add *= modPow(M-1, N-1-i, MOD); add %= MOD; ans += add; ans %= MOD; } writeln(ans); } 長いので、ModPowやModInvなど一部関数は省略している。 感想 久しぶりに問題を見返したら全く解けなくて驚愕した。 折角なので復習の意味も込めて解法を理解し直してみた。 この手の問題ではやはり 変数をできるだけ固定して考えてみる 単純化したバージョンの問題を考えてみる(2Dから1Dに落としてみるなど) などの基本テクニックを忘れないことももちろん、 前から決めていくことにして考える(うまく行けば、今回のdp解のように部分問題の構造が見つかることも) 問題の操作を俯瞰的に見る 途中の「状態」を持たなくて良い方法を考える など色々あると思う。 今回の解法はどこで一つ前と違う色を入れても変わらず場合の数が$M-1$倍になることが重要なポイントであった。 いや、やっぱりこんなの誰が解けるんだ？でも1ヶ月前の自分は解けてるんだよな。。。 結局思考を再現できそうにない気がする。助けてくれ。"
  },
  {
    url: "/",
    title: "InTheDayDream",
    date: "2024-01-03T00:00:00Z",
    body: "InTheDayDream"
  },
  {
    url: "/post/",
    title: "Posts",
    date: "2024-01-03T00:00:00Z",
    body: "Posts"
  },
  {
    url: "/post/2023-final/",
    title: "2023年お疲れ様でした。",
    date: "2023-12-31T00:00:00Z",
    body: "2023年お疲れ様でした。 2023年12月31日 今年も大晦日と呼ばれるこの日がやってきました。 折角この場があるので、何か書きます。 それぞれの章は独立しており、関連性はありません。 なので突拍子もないことが書いてあるかもしれません。 ご了承くださいな。 競技プログラミングと自分 振り返りとこれからの目標 2022年末に競技プログラミングに出会い、そこからそこそこ力を入れてやってきました。 毎日必ず触れるようにしようと決めて、ずっとstreakが切れないように問題を解き続けてきました。 2023年が始まった時点でのレーティングが199で、現在が1258まで到達することが出来ました。 これで満足かと言われると、そんなことは無いです。2024年も頑張って取り組んでいきたいなと思っています。 目標は ICPC予選突破(して、合法的に美味しいもの食べに行きたい) レーティング1600達成 の2つです。 初心を忘れることのないようにしたいものです。 最近の自分 最近は1200以上はキープできるけど、それ以上を目指すにはかなり力不足を感じています。 客観的に分析すると、このランク帯の適正難易度が出にくいというのが原因かなという感じです。 緑くらいの難易度と、青以上の難易度は割と出題割合が高いものの、水ちょい上くらいの問題というのはあまり見かけないイメージです。 文句を言わずに青レベルを解けるようになるのが一番早そうな感じがします。 皆さんは、(これを見てる人はたいてい青以上だったりすると思うのですが、)「こんな解法思いつくわけ無いだろ」とか思ったりしませんか？ 私が問題を解いてて一番精神的ダメージを受けるのは、自分で再現できる自信がまったくないような頭の良い解法に出くわしたときです。 練習量がどうだとかそういうものをあざ笑うかのような問題にぶち当たり、何回もやめたくなったことがあります。 それでも「そのまま覚えてしまうのも練習の内」と言い聞かせて続けてきました。 しかしそんな愚かな考えは、初見で普通に解ける人の存在によって打ち砕かれ、自分はなぜ生きているんだろうと感じることすらあります。 基本的には楽しいんですが、やはり辛いときもありますよね。競技プログラミングは。 で、結局どうすれば良いのかとかの疑問に対する答えはまだ出ていません。自分は今でも問題が解けなくて大ダメージを受けることもあるし、なんでこんなに頭が悪いのだろうと思うこともあります。 しかし、その分をstreakの更新や「少なくともこの問題の解法は覚えてしまったから俺の勝ち」みたいな違う方向での喜びに変更するようにしています。 来年のこの時期に「そんなこともあったなぁ」と言えるくらい強くなっていたらどんなに良いだろうと思います。 思ったこと もしかしたら自分は今までまともに「真剣に取り組む」ということをしてこなかったのかもしれません。 スポーツに熱中して、真剣に取り組んだことがある人は多いんじゃないかと思います。 かくいう自分は中高で運動部の部活動をしてきたり、小さい頃からスキーをしていたりしました。 しかし、競技プログラミングをはじめて、そのどれもあまりやる気を出せていなかったんじゃないかと今になって感じます。 それらと競技プログラミングの最大の違いが、やってて楽しいと思う時間の長さです。 それとともに、逆に、やってて楽しいことじゃないと真剣に向き合えないんじゃないかなとも思います。 かの渡辺明は次のように言いました。(ソースが怪しいのでほんまかは知らん) 初めて竜王になったころ、僕はこう思っていました。 「自分が竜王になれたのは、誰よりも努力したからだ。誰だって努力すればプロになってタイトルくらい取れる。他の人たちは、全然努力をしていない」 自分よりも弱い人たちに対して、心の中で「真面目にやらなかった人」とレッテルを貼って馬鹿にしていたんです。 だけど、息子に将棋を教えるようになって、自分の間違いに気付きました。昔の自分に簡単にできたことが、息子は全然できないんです。 実は、子供に将棋を教えるという経験がそれまで一度もなかったので、本当に驚きました。「え？なんでこんなことが分からないの？」って。 それでやっと理解しました。「あぁ、自分には将棋の才能があったんだ」と。 もちろん、たくさん努力もしましたよ。だけど、それだけではなかった。 将棋の神様が与えてくれた才能があったからここまで来れたということが、ようやく分かったんです。 誰でも努力を続ければ、将棋は確実に上達していくと思います。そして、トッププロはみんな努力しています。 それは事実です。だけど、上達スピードは人それぞれ。 一生努力を続けてもプロレベルになれない人もいるということに、僕はこのとき初めて気付きました。 みんな努力していないと決め付けて馬鹿にしていた昔の自分は、我ながら最低の人間です。 得意なことだから努力したくなるし、楽しいのではないでしょうか。 そういう仮定をすると、私は競技プログラミングに出会えて幸運だったのかもしれません。 ギャラリー 大晦日小話 イベント、好きですか？ イベントというのは、ハレの日みたいなものだと考えてもらえばよいです。 学園祭でもいいし、年中行事の日でもいいし、コミケでもいいです。 ちなみに私はイベント嫌いです。 嫌いな理由はいくつかありますが、大まかに 「いつも通り」が崩されること ワイワイしてないやつが「仲間はずれ」とみなされること 自分の中の逆張り心が「今はスカしておくべき」だと言ってくること などがあります。 こういう日は心がざわついて、何をしても楽しくも無いという地獄です。 どうでしょう？共感できますか？ ちなみに今日、12月31日も自分にとって少しハズレの日です。 世間は〇〇納めだなんだと言いますし、みんな揃いも揃って浮ついています。 ですが、今年の大晦日は少し心穏やかに過ごせました。 私はいま実家(兵庫県神戸市)に帰省しており、市の中心街である元町や三宮にでかけてきました。 しかし、思った以上に街は「いつもどおり」をキープしており、年末感は少なかったです。 電車が少し空いていたり、干支に因んだ服が売っていたりしたくらいです。 残りの時間も昼寝をしたり、競技プログラミングをしたりして、テレビなどから少し距離を取ることにより良い年末を過ごせたような気がします。 来年はより良い年になるといいな。 教訓: ボッチで体調を崩すのはやめようね！ またもや体調が崩壊... とりあえず寝ます。 \u0026mdash; In (@UU9782wsEdANDhp) December 21, 2023 事件は2023年12月21日に始まった\u0026hellip; この日、当然のように2限の授業を寝坊し、4限に出席していました。 すると、なんだか知らんけどめちゃくちゃ鼻水が出るし、なんか気持ち悪くて吐きそうになってきました。 5限も授業がありましたが、これ出たら死ぬんじゃないかと思ってブチ切り、帰って寝ました。 起きても全然体調が回復していなく、このツイートをして1問だけ通して寝ました。 ここから地獄が始まります。 ちょっとマシになってきた... 24時間くらい横になった後は頭が痛くても眠れないということを知った。 ABCどうしようかな。 \u0026mdash; In (@UU9782wsEdANDhp) December 23, 2023 さて、いきなり2日飛びましたが、この間のすべての時間寝ていました。 寒気と頭痛で1時間おきくらいに目が覚めるので、本当に最悪でした。 こいつABC出ようか悩んでいますが、かなり体調悪いですよ。 さて、結局この後ABCに出て、-22を食らうという最悪なことが発生したのはまた別のお話。 実はこの翌日に用事があり、どうしても朝起きて昼間で活動しなくてはいけなかったのです。 そんな状態でよる12時くらいまで競プロをやってしまったため、翌日はまじで最悪でした。 ずっと目が痛くてディスプレイを見てられないし、寒気がするから異常に厚着をしてなんとか耐えていました。 結局最終的に限界を迎えたようで、途中で鼻血が出る始末でした。 この辺りで体調は未だ悪いのに、家事が一切出来ないため部屋が荒れだします。 具体的に一番最悪だったのは、汗がいっぱい出るから着替えるのですが、着る服がなくなってくることです。 体調的に無理だと思って、月曜日の授業は出ずに部屋にこもりました。 まあ色々あり、現在はだいぶ体調が良くなってきたのですが、頼れる人間がいない状態で体調を崩すとこの世の終わりみたいな自体に簡単に陥るので、皆さんは体調を崩さないように気をつけましょうね。 おわりに 色々書きたいことをかいた。後悔はしてない。 みなさまにとって2024年が実りあるものになりますように。"
  },
  {
    url: "/post/abc290e/",
    title: "ABC290E - Make it Palindrome",
    date: "2023-12-31T00:00:00Z",
    body: "ABC290E - Make it Palindrome 問題概要 問題へのリンク 文字列$X$に対して、$f(X) = $($X$を回分にするために変更する必要のある要素の個数の最小値)と定める。 長さ$N$の数列$A$が与えられるので、$A$のすべての連続部分列の集合$X$として、 $\\sum_{x \\in X} f(x)$を求めよ。 制約 $1 \\leq N \\leq 2 \\times 10^5$ $1 \\leq A_i \\leq N$ 解法 すべての連続部分列は$O(N^2)$個ある。 なぜなら、連続部分列を1つ決めることは端点を2つ決めることと等価であるからであり、 端点を2つ決める組み合わせの数は$\\binom{N}{2}$通りであるからである。 一つの連続部分列は長さ$O(N)$であるため、全探索は$O(N^3)$となり、当然間に合わない。 そこで、主客転倒してみよう。(言葉の使い方があってるか不安) ある$(A_i, A_j)$ペアに着目した時、これらが一致する必要のあるような連続部分列は何通り取れるのかを考える。 次に、具体例を挙げる。 2つのOが$A_i$と$A_j$だと考えれば良い。 ____O____O___ まず、これらが端点の連続部分列を取れば良い。連続部分列の端点をXで示す。 ____X____X___ 他にもこういうとり方もできる。 ___XO____OX__ これでも良い。 __X_O____O_X_ というわけで、問題の答えは「$\\min{} (i, N-j+1)$通り取れる」となる。(1-indexed) O(N)は通るので、左側の項を列挙することにする。 すなわち、任意の$(A_i, A_j)$に対して考えたいが、 とりあえず$A_i$は固定して、$i$より大きな$j$に対する$A_j$の寄与を考えるというわけだ。 1つ左端$A_i$をとった時、「各項が何回一致する必要があるか」は、次のようになる。 ___O______ 4444321 というわけで、とりあえず$O(N^2)$解を得ることが出来た。 $A_i$と$A_j$が一致するならスキップ、そうでないなら$\\min{} (i+1, N-j)$(0-indexed)を足し込んでいく感じで解ける。 実装例は次のような感じ。 long ans = 0; foreach (i; 0..N) { foreach (j; i+1..N) { if (A[i] != A[j]) { ans += min(i+1, N-j); } } } 当然まだ通らないので、これを高速化しよう。 問題を解くには、「ある区間に何個分$x$があるのか？」みたいなのを管理できれば良さそうである。 これをセグメントツリーで管理する。 ただし、右端の「4321」みたいになってるところがキモいので、これと「4444」みたいに一定値になってる部分を分けてセグメントツリー2本で管理することにする。 わかりにくいと思うので、もう少し言語化する。 セグメントツリーの最下段を$N$要素確保して、最下段の$i$番目の値を「今見てる区間に$i$は何個あるか？」を管理することにする。 こうすれば、(総和)-(区間の左端の値が何個あるか)を計算することで 「固定した左端の要素を変更する必要のあるような連続部分列のとり方」を数え上げられるという仕組みになっている。 まだイメージがわかない人は実装例を見てほしい\u0026hellip;と言いたかったのだが、実装が厳しすぎておよそ人の読めるようなものではなくなってしまった。 どうしてもインデックスが合わなくて、偶奇で分けて、プリントと$O(N^2)$と合わせながら頑張って実装した。 もっとスマートなやり方はいくらでも紹介されてるので、そちらを参照したほうが良いだろう。(自分もそうする。) 提出 努力の証拠ということで一応貼り付けておく。 解法自体はすぐわかったものの、問題とは3日以上向き合った気がする。 多分$O(N \\log N)$ import std; void main () { /* 主客転倒して、A[i]がどこと何回一致判定されるかを考える。 すると、min(右側の幅, 左側の幅)を考えれば良いことがわかり、セグ木2本持っておくとよい。 */ int N = readln.chomp.to!int; int[] A = readln.split.to!(int[]); A[] -= 1; long ans; if (N % 2 == 0) { ans = solveEVEN(N, A); } else { ans = solveODD(N, A); } writeln(ans); } long solveEVEN (int N, int[] A) { auto M = new SegmentTree!(long, (long a, long b) =\u0026gt; a+b, () =\u0026gt; 0L)(N); auto R = new SegmentTree!(long, (long a, long b) =\u0026gt; a+b, () =\u0026gt; 0L)(N); long ans = 0; for (int i = N-1; N/2 \u0026lt;= i; i--) { R.set(A[i], R.get(A[i]) + N-i); } /* 右に進む */ for (int i = N/2-1, j = 0; i \u0026lt; N-1; i++, j++) { ans += R.prod(0, N) - R.get(A[i]); R.set(A[i+1], R.get(A[i+1]) - (N/2-j)); } /* セット */ foreach (i; 0..N) R.set(i, 0); for (int i = N-1; N/2+1 \u0026lt;= i; i--) { R.set(A[i], R.get(A[i]) + N-i); } M.set(A[N/2], M.get(A[N/2]) + 1); M.set(A[N/2-1], M.get(A[N/2-1]) + 1); for (int i = N/2-2, j = 0; 0 \u0026lt;= i; i--, j++) { ans += (i+1) * (M.prod(0, N) - M.get(A[i])); ans += R.prod(0, N) - R.get(A[i]); R.set(A[N/2+1+j], R.get(A[N/2+1+j]) - (i+1)); M.set(A[N/2+1+j], M.get(A[N/2+1+j]) + 1); M.set(A[i], M.get(A[i]) + 1); } return ans; } long solveODD (int N, int[] A) { auto M = new SegmentTree!(long, (long a, long b) =\u0026gt; a+b, () =\u0026gt; 0L)(N); auto R = new SegmentTree!(long, (long a, long b) =\u0026gt; a+b, () =\u0026gt; 0L)(N); long ans = 0; for (int i = N-1; N/2 \u0026lt; i; i--) { R.set(A[i], R.get(A[i]) + N-i); } /* 右に進む */ for (int i = N/2, j = 0; i \u0026lt; N-1; i++, j++) { ans += R.prod(0, N) - R.get(A[i]); R.set(A[i+1], R.get(A[i+1]) - (N/2-j)); } /* セット */ foreach (i; 0..N) R.set(i, 0); for (int i = N-1; N/2 \u0026lt; i; i--) { R.set(A[i], R.get(A[i]) + N-i); } M.set(A[N/2], M.get(A[N/2]) + 1); for (int i = N/2-1, j = 0; 0 \u0026lt;= i; i--, j++) { ans += (i+1) * (M.prod(0, N) - M.get(A[i])); ans += R.prod(0, N) - R.get(A[i]); R.set(A[N/2+1+j], R.get(A[N/2+1+j]) - (i+1)); M.set(A[N/2+1+j], M.get(A[N/2+1+j]) + 1); M.set(A[i], M.get(A[i]) + 1); } return ans; } 流石に長いのでセグメントツリーの実装は省略した。 感想 死ぬほど苦戦して、かなり自信を失った気がする。 次解くときはもっとスマートな解法でやりたいと思う。"
  },
  {
    url: "/post/abc221e/",
    title: "ABC221E - LEQ",
    date: "2023-12-16T00:00:00Z",
    body: "ABC221E - LEQ 問題概要 問題へのリンク 長さ$N$の整数列$A = (A_1, A_2, \\dots , A_N)$が与えらえる。 $A$の長さ$2$以上の部分列であって、次の条件を満たすものをの総数を$998244353$で割ったあまりを求めよ。 部分列の最初と最後の項を$A^\\prime{}_1, A^\\prime{}_k$とするとき、$A^\\prime{}_1 \\leq A^\\prime{}_k$が成立する。 制約 $2 \\leq N \\leq 3 \\times 10^5$ $1 \\leq A_i \\leq 10^9$ 考察 まず感じるのが、ちょっと変わった条件だなということ。 この条件下では、部分列を要求しておきながら、最初と最後しか条件に影響しない。 現段階で私は、部分列を扱うという時点である程度はdpの線を疑ったほうが良いと考えている。 なので、とりあえず典型的なdpに落とし込めないか(簡単な部分問題を見つけられるか)を試す。 こういう問題でdpを考えるときは、大抵の場合前から逐次的に項を部分列に追加するかどうかを見ていくdpになる。 なので、ある段階でそれまでの部分列を特徴づける値(高々2次元くらいが好ましい)がないかを探してみる。 が、いい感じのdpはなさそうである。 そういう時はもっと大枠の数学で数え上げられることがある。 例えば、「実はこの問題の解は重複順列と同じようなアイディアで解ける」というようなケースがこれに当たる。 そう思っていろいろ考えてみるが、やはり「最初の項」の情報を持っておかなければどうにもならないので、そんな都合のいいことはなさそうである。 だが、例えば始点を完全に一つに定めたとする。これなら解ける。 始点を$A_x$、終点を$A_y$とする。 この間の$y-x-1$項は、どのように採用しても部分列は条件を満たす。 すなわち、$2^{y-x-1}$通りになる。これを$x \u0026lt; y$なるすべての$y$について足し合わせれば$O(N)$くらいで解ける。 しかし、この問題においてはどの項も初項になる可能性があり、結局$O(N^2)$となるため間に合わない。 ここで自力考察は力尽きてしまった。 解法(解説AC) 実は、最後の始点固定が当たりの方針で、これをうまく利用すると解くことができる。 (どちらでもよいが)簡単のため、終点を固定して考える。終点を$A_j$とするとき、条件を満たす部分列の個数はいくつになるだろうか？ 答えは、$i \u0026lt; j$かつ$A_i \\leq A_j$なるすべての$i$に対して、$2^{j-i-1}$の和、つまり、数式で表わすと、 $$ \\sum_{\\substack{i \u0026lt; j \\\\ A_i \\leq A_j}} 2^{j-i-1} $$ である。これを次のように変形する。 $$ \\begin{split} \\sum_{\\substack{i \u0026lt; j \\\\ A_i \\leq A_j}} 2^{j-i-1} \u0026amp;= \\sum_{\\substack{i \u0026lt; j \\\\ A_i \\leq A_j}} \\frac{2^{j}}{2^{i+1}} \\\\ \u0026amp;= 2^{j} \\sum_{\\substack{i \u0026lt; j \\\\ A_i \\leq A_j}} \\frac{1}{2^{i+1}} \\end{split} $$ なんと、数式の裏に隠れて気づきにくいが、$2^{j}$を外に出すことができる。 この形に持ってきたら、なんとなく方針が見えてくる。 要は、$i \u0026lt; j$なる$i$で、条件を満たすものの総和を高速に求められたら良いということになる。 そしてこれは、座標圧縮とセグメントツリー(やBITなど)で達成できる。 具体的な方法の説明をしよう。 座標圧縮によって、元の数列$A$を$[0, N-1]$の元へ写す。 こうすることで、セグメントツリーの$x$個目の要素が元の数列の$x$番目に大きな要素と対応する。 ここに、$A$の前の項から順番に適切な場所へ$1/2^{i+1}$の値を足しこんでいく。 終点が$A_x$であるときの解を求めるには、$A_x$の圧縮先を$x$とするとき、セグメントツリーの$[0, x]$の合計値に$2^{x}$をかけることで得られる。 以上より、全体$O(N \\log N)$で解を求めることができる。 実装例 import std; void main () { int N = readln.chomp.to!int; int[] A = readln.split.to!(int[]); solve(N, A); } void solve (int N, int[] A) { /* 解説AC: 先に部分列の頭と尻尾を決め打ちする。 この時、i \u0026lt; j かつ A_i \u0026lt;= A_jである。 このような部分列は2^{j-i-1}個存在し、すべて条件を満たす。 2^{j-i-1} = 2^{j} / 2^{i+1}であるから、 jを一つ固定して考える。尻尾がA_jであって、条件を満たす部分列は2^{j} / sum(1 \u0026lt;= i \u0026lt; j かつ A_i \u0026lt;= A_j) 2^{i+1}通り。 これは座圧 + 動的区間和取得ができればO(log N) 具体的には、Aを座圧して列Bを作り、前からj-1までで1/2^{i+1}の計算結果を列のしかるべきところに入れる。 すべてのjに対して同じことを行うと、O(N log N)に落ちる */ const long MOD = 998244353; /* 座圧 */ auto B = A.dup; B = B.sort.uniq.array; int[int] comp; int f (int x) { /* A -\u0026gt; B */ return comp[x]; } int fInv (int x) { /* B -\u0026gt; A */ return B[x]; } foreach (i, b; B) comp[b] = cast(int) i; auto RSQ = new SegmentTree!(long, (long a, long b) =\u0026gt; ((a+b)%MOD), () =\u0026gt; 0L)(B.length); long ans = 0; long po = 2; long deno = modInv(2, MOD); long inv = deno*deno % MOD; foreach (i, a; A) { ans += po * RSQ.prod(0, f(a)+1) % MOD; ans %= MOD; long NewVal = RSQ.get(f(a)) + inv; NewVal %= MOD; RSQ.set(f(a), NewVal); po *= 2; po %= MOD; inv *= deno; inv %= MOD; } writeln(ans); } セグメントツリーの実装は長いので省略した。 感想 いいところまでたどり着けていたので、自力でACとりたかった気持ちもあるが、それ以上に解法に感動した。 この解法は$O(N \\log N)$で転倒数を求めるアルゴリズムとほぼ同じだと思った。 しかし、そこに帰着するまでの考察もそこそこ非自明だと感じる。 やはり水色diffはかなり苦しい。 得られる教訓としては、やはり変数固定は大事であるということと、式におこすことに成功したら変数分離を試みるべきという事だろうか。 $j$(尻尾のインデックス)を分離できるというのは負の指数を分数形に直すまで全然気が付かなかった。 また、考察の最初にdpの線を考えていたが、今になって考えてみると、 この問題で問われる部分列は、明らかに最後にとった項やこれまで取った項から計算できる何かで特徴づけされているのではない。 先頭の項のみによって特徴づけられているということからdpの線を外すべきだったなと思う。 なぜなら、ある項で終了できる部分列かどうかというのは最初の項を見ないと判断できないため、どうしても$O(N)$個くらいの情報を持っておかないといけないはずだからである。"
  },
  {
    url: "/post/split-into-continuous-subsequences/",
    title: "列をいくつかの連続部分列へ分解する小技",
    date: "2023-12-13T00:00:00Z",
    body: "列をいくつかの連続部分列へ分解する小技 問題 数列$A$の連続部分列を、$i, j \\in [1, N]$かつ$i \\leq j$なる$i, j$を選択し、 $A$の$i$項目から$j$項目までを順番を変えずに取り出したものとし、$B_{i, j}$と表記することとする。 長さ$N$の数列$A = (A_1, A_2, \\dots, A_N)$が与えられる。 数列$A$から取り出した$1$個以上の連続部分列の列$C$であって、次の条件を満たすものをすべて列挙せよ。 $C$の要素を前から順番を変えずに結合して得られる数列は、$A$に一致する。 但し、$2$つの連続部分列の列が異なるとは、ある要素が存在して、片方にのみ含まれることとする。 制約 $1 \\leq N \\leq 15$ 問題の説明 ややこしく書いたが、要は重ならない/余らないようにいくつかの連続部分列に分解しろという問題である。 まず、連続部分列への分割は$2^{N-1}$通り存在することを説明する。 まず、$A_i$と$A_{i+1}$の間に全部で$N-1$個の「切れ目」があると考える。 最終的に$k$個の連続部分列に分解する時、これらの切れ目を$k-1$個選択することで達成される。 この組み合わせ数は$\\binom{N-1}{k-1}$通りである。 $1 \\leq k \\leq N$に対する総和を取ればよいため、全体の組み合わせ数は、 $$ \\sum_{k=0}^{N-1}\\binom{N-1}{k} = 2^{N-1} $$ 通りになる。 なお、この変形を含めた二項係数の公式は高校数学の美しい物語を参照すると良い。 次の章で、これらすべてを実際に列挙する方法を説明する。 解法 本問題は、bit全探索を用いて時間計算量$O(N2^N)$で解くことができる。 まず、元の数列$A$をint[]で、1つの有効な分割をint[][]で管理することにする。 int[] A = readln.split.to!(int[]); // 標準入力から入力 int[][] ans = new int[][](N, 0); // 二次元配列を宣言し、メモリ確保 また、$A_i$と$A_{i+1}$の「切れ目」をint[]で管理する。 int[] cut = new int[](N-1); ここで、cut[i]が表すのは$A_i$と$A_{i+1}$の間の「切れ目」であることに注意せよ。 bit全探索を用いて、どの「切れ目」を採用するかを探索する。 for (int bit = 0; bit \u0026lt; (1\u0026lt;\u0026lt;(N-1)); bit++) { cut[] = 0; // cutのすべての要素に0を代入 for (int i = 1; i \u0026lt; N; i++) if (0 \u0026lt; (bit\u0026amp;(1\u0026lt;\u0026lt;i))) cut[i] = -1; // -1の代入された切れ目を使う } 例えば、$N=5$の時、cutを適切な場所でprintすると次の出力を得る。 [0, 0, 0, 0] [-1, 0, 0, 0] [0, -1, 0, 0] [-1, -1, 0, 0] [0, 0, -1, 0] [-1, 0, -1, 0] [0, -1, -1, 0] [-1, -1, -1, 0] [0, 0, 0, -1] [-1, 0, 0, -1] [0, -1, 0, -1] [-1, -1, 0, -1] [0, 0, -1, -1] [-1, 0, -1, -1] [0, -1, -1, -1] [-1, -1, -1, -1] あとは、cutの情報を利用しながらansへ格納していけば良い。 具体的には、次のアルゴリズムで達成できる。 cur = 0、idx = 0とする。 cur \u0026lt; N-1 \u0026amp;\u0026amp; cut[cur] == -1が真の時、手順3へ。そうでなければ手順4へ行く。 ans[idx]にA[cur]を追加し、idx += 1とする。手順5へ行く。 ans[idx]にA[cur]を追加する。手順5へ行く。 cur += 1とする。cur == Nであれば終了。手順2へ行く。 実装例 import std; void main () { int[] A = [1, 2, 3, 4, 5]; int[][] ans = new int[][](A.length, 0); int[] cut = new int[](A.length-1); /* bit全探索 */ for (int bit = 0; bit \u0026lt; (1\u0026lt;\u0026lt;(A.length-1)); bit++) { cut[] = 0; // cutをリセット for (int i = 0; i \u0026lt; A.length-1; i++) if (0 \u0026lt; (bit\u0026amp;(1\u0026lt;\u0026lt;i))) cut[i] = -1; /* ansへ割り振る */ foreach (ref a; ans) a.length = 0; // ans[i]をリセット int cur = 0, idx = 0; while (true) { if (cur == A.length) break; if (cur \u0026lt; A.length-1 \u0026amp;\u0026amp; cut[cur] == -1) ans[idx++] ~= A[cur]; // ~=はpush_backのようなもの else ans[idx] ~= A[cur]; cur++; } /* 出力 */ write(\u0026#34;answer \u0026#34;, bit, \u0026#34; \u0026#34;); for (int i = 0; i \u0026lt;= idx; i++) { write(ans[i], i == idx ? \u0026#34;\\n\u0026#34; : \u0026#34; \u0026#34;); } } } answer 0 [1, 2, 3, 4, 5] answer 1 [1] [2, 3, 4, 5] answer 2 [1, 2] [3, 4, 5] answer 3 [1] [2] [3, 4, 5] answer 4 [1, 2, 3] [4, 5] answer 5 [1] [2, 3] [4, 5] answer 6 [1, 2] [3] [4, 5] answer 7 [1] [2] [3] [4, 5] answer 8 [1, 2, 3, 4] [5] answer 9 [1] [2, 3, 4] [5] answer 10 [1, 2] [3, 4] [5] answer 11 [1] [2] [3, 4] [5] answer 12 [1, 2, 3] [4] [5] answer 13 [1] [2, 3] [4] [5] answer 14 [1, 2] [3] [4] [5] answer 15 [1] [2] [3] [4] [5] 確かに分割が成功している。 使用例 ネタバレ注意であるが、AtCoderのこの問題で使うことができる。 提出例 終わりに これサッと実装しろと言われたら困る人も多いんじゃないかなと思ったので作りました。 役にたてば幸いです。"
  },
  {
    url: "/post/uec-advent2023/",
    title: "ミスりにくい二分探索 [UEC Advent Calendar 2023] 6日目",
    date: "2023-12-05T00:00:00Z",
    body: "ミスりにくい二分探索 [UEC Advent Calendar 2023] 6日目 まえがき この記事は、 電通大生による電通大生のためのUEC Advent Calendar 2023 の6日目担当です。 2時間ほど遅刻しました！すみません！ 5日目はトナカイさんによる、BASHであそぼでした。 私もⅠ類の友人がいますが、彼は毎回提出コマンドを手打ちしていた記憶があります。 自動化スクリプトをbashでササッと組めるのすごく憧れるんですが、いつもbashを勉強する面倒臭さが勝ってしまいます。 私もいつの日か退屈なことはpythonにやらせられるようになりたいです。 実はAdvent Calendarは公開後すぐに枠が埋まってしまったので、2枠目も存在します(なんで？)。 5日目の牛田ウシタさんの記事はまだ公開されていないようですが、こちらもぜひ読んでみてはいかがでしょうか！ 本記事を書いている間に更新されていました。 アドカレを書くためにいきなり22万吹き飛んでいて笑いました。 長期間の出来事が詳細に語られていて、臨場感がありました。私が文章書くと臨場感が死ぬので、すごいなぁ。。 私は関西に住んでいた経験があるため、いくつか知っているポイントがあったのが面白かったです。(京都のデカい階段、奈良の穴とか) それではそろそろ本題に行きましょう。 はじめに こんにちは、こんばんは、おはようございます。 6日目を担当する、Inと申します。 去年に引き続き、今年も参加させていただきました。 今年は去年のやつ よりも実りのある記事がかければ良いなと思っております。よろしくおねがいします。 二分探索とは 本記事では、競技プログラミングでよく使うかつ、割とバグらせやすいと思っているアルゴリズムである二分探索の 比較的バグらせにくい実装を紹介します。 なお、厳密性を欠いていたり、不正確な情報があるかもしれません。 もしまずい場所があれば指摘していただけると助かります。 まずは、本記事において「二分探索」が何を指すのかをはっきりさせておきましょう。 二分探索で出来る事 関数$f: \\mathbb{Z} \\rarr \\{0, 1 \\}$であって、次の性質を満たすものを考える。 $f(x)=0$を満たす$x \\in \\mathbb{Z}$が少なくとも一つ以上存在する。 $f(y)=1$を満たす$y \\in \\mathbb{Z}$が少なくとも一つ以上存在する。 次のどちらか片方のみが成立している。 $x \\leq y \\Rightarrow f(x) \\leq f(y)$ $x \\geq y \\Rightarrow f(x) \\leq f(y)$ $f(a)=0$、$f(b)=1$を既知として、任意の$\\mathbb{Z}$の元に対して$f$の値を時間計算量$\\alpha$で求められるとする。 この時、$f(x) \\neq f(x+1)$なる$x$を時間計算量$O(\\alpha \\log{|a-b|})$で求める。 状況はこんな感じです。 二分探索の動作原理はいたってシンプルです。 最初、$a$と$b$の中点$c$をとります。 具体的には、$c = \\lfloor \\frac{a+b}{2} \\rfloor$とします。 仮定より、関数$f$の値はある一点で$0$と$1$が切り替わり、それ以外の場所で変化しません。 ゆえに、もし$f(c)=0$であったとすると、必ず$a \\leq c \\leq x$であることがいえ、そうでない時は$x+1 \\leq c \\leq b$が言えます。 $f(c)$の値によって区間の端点$a$か$b$を$c$で置き換えます。これを繰り返します。 結果的に、$f(a)=0$と$f(b)=1$を保ったまま、$|b-a|=1$となるまで区間を縮めることができます。 時間計算量を考えましょう。 区間の端点を一度置き換えるごとに区間の長さはおよそ$\\frac{1}{2}$になります。 したがって、アルゴリズムが停止するまでに繰り返される回数は、 $$ \\begin{equation*} \\begin{split} \\frac{|b-a|}{2^x} \u0026amp;= 1 \\\\ |b-a| \u0026amp;= 2^x \\\\ \\end{split} \\end{equation*} $$ より、$x = \\log_2{|b-a|}$となり、$O(\\log{|b-a|})$回程度である事がわかります。 実装の詳細 競技プログラミング界隈で「めぐる式二分探索」と呼ばれる実装があります。 【めぐるのアルゴリズム講座】 二分探索（整数）の書き方 難しさ：４ pic.twitter.com/LGLbkS0D7l \u0026mdash; 因幡めぐる@競技プログラミング (@meguru_comp) February 9, 2016 これをベースにやっていきます。 まず、めぐる式二分探索とは、次のような実装です。 long ok = 0, ng = x; while (1 \u0026lt; abs(ok-ng)) { long mid = (ok+ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } この実装では、whileの条件式が1 \u0026lt; abs(ok-ng)になっています。 このおかげで、okとngの大小関係に気を配らなくてよくなります。 関数$f$の実装と二分探索のアルゴリズム部分を分けているのも特徴的です。 これによって、 初期値ok及びngの設定 関数$f$の内部実装 さえきちんとできていれば、あとはボイラープレートとして扱えるという利点があります。 基本はこれ一本ですべてうまくいきます。 ということで、ここからは関数$f$の設計と初期値の設定に注力しましょう。 関数$f$の設計 関数の設計は、二分探索で最も重要な部分です。 ここをミスったらどうやってもバグります。 関数の設計で気を付けることはただ一つです。 必ず$f(x)=0$及び$f(y)=1$なる$x$、$y$が存在するようにしてください。 当たり前だろ。と思った方、意外にも見落とすことがあるので、本当に気を付けたほうがいいです。 配列の探索や、ちょっと変則的な関数から$f$を作る場合、定義域が知らぬ間に制限されることがあります。 このような場合、定義域の外まで定義域を拡張して回避するテクニックがあります。あとで触れます。 初期値の設定 初期値の設定は、$f$をうまく構成できたことを確認してから行いましょう。 初期値の設定に落とし穴は少ないです。 okが区間のどちら側か？ $f$の中で計算するとき、ok、ngはオーバーフローしないか？ 本当に$f(\\mathrm{ok}) \\neq f(\\mathrm{ng})$が成立しているか？(もっと初期値を大きく/小さくとる必要があるか？) あたりを調べれば、経験上大体うまくいきます。 練習問題 いくつか練習問題を用意しました。 要は習うより慣れろってことです。 解説も用意してみました。ぜひ見てみてください。 Q1: 年齢あてゲーム 問題 あなたは相手に、「年齢は$x$歳以上ですか？」と何回でも質問できます。 なるべく少ない回数で年齢を当てましょう。 制約 $0 \\leq (相手の年齢) \\leq 10^{18}$ 解答 $$ \\begin{equation*} f(x) = \\begin{cases} 1 \u0026amp; \\text{if ($x$に対する質問の答えがYes),} \\\\ 0 \u0026amp; \\text{if ($x$に対する質問の答えがNo).} \\end{cases} \\end{equation*} $$ とすれば、$f$として満たすべき性質を満足します。 よって、次のような解答ができます。 bool f (long x) { return ask(x); // ask: long -\u0026gt; bool を暗黙に仮定 } long ok = 0, ng = 10L^^18+1; while (1 \u0026lt; abs(ok-ng)) { long mid = (ok+ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } writeln(\u0026#34;age = \u0026#34;, ok); 図にするとこうです。 ポイント: $f$の構成は簡単ですが、okを左端にすること、ngの初期値に注意が必要です。 Q2: LowerBound 問題 $N$要素の配列$A$が与えられる。ここで、$i \u0026lt; j \\Rightarrow A[i] \u0026lt; A[j]$が保証される。 $A$の要素であって、$x$以上のものの集合$B$を考える。すなわち、$B = \\{a \\in A | x \\leq a \\}$である。 $B$の最小要素を求めよ。$B = \\emptyset$である場合はその旨を報告せよ。 制約 $1 \\leq N \\leq 2 \\times 10^5$ $0 \\leq i \\leq N-1$に対して、$-10^9 \\leq A[i] \\leq 10^9$ $-10^9 \\leq x \\leq 10^9$ 解答 $$ \\begin{equation*} f(i) = \\begin{cases} 0 \u0026amp; \\text{if $i \u0026lt; 0$,} \\\\ 0 \u0026amp; \\text{if $A[i] \u0026lt; x$,} \\\\ 1 \u0026amp; \\text{if $x \\leq A[i]$,} \\\\ 1 \u0026amp; \\text{if $N \\leq i$.} \\\\ \\end{cases} \\end{equation*} $$ と定めれば、二分探索に使える関数になります。 範囲外参照をしている場合は右側にはみ出していれば$1$とし、左側にはみ出している場合は$0$としています。 この関数を用いて二分探索することで、$x \\leq A[i]$なる最小の$i$を見つけることができます。 $i = N$であれば$B = \\emptyset$を判定できます。 なぜ範囲外に対しても値を定義しているかというと、$A$の要素がすべて$x$未満であったり、すべて$x$以上であることがあり得るからです。 この工夫をしないと、変な場合分けをする必要が出てきます。 bool f (int i) { if (i \u0026lt; 0) return false; if (N \u0026lt;= i) return true; return x \u0026lt;= A[i]; } int ok = N, ng = -1; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } if (ok == N) { writeln(\u0026#34;B is empty\u0026#34;); } else { writeln(A[ok]); } 図にするとこんな感じです。 Q3 (Advanced Problem): ABC309C - Medicine 問題 高橋君は医者のすぬけ君から$N$種類の薬を処方されました。$i$種類目の薬は(処方された日を含めて)$a_i$日間、毎日$b_i$錠ずつ飲む必要があります。また、高橋君はこれ以外の薬を飲む必要がありません。 薬を処方された日を$1$日目とします。$1$日目以降で、初めて高橋君がその日に飲む必要がある薬が$K$錠以下になるのは何日目かを求めてください。 制約 $1 \\leq N \\leq 3 \\times 10^5$ $0 \\leq K \\leq 10^9$ $1 \\leq a_i, b_i \\leq 10^9$ 出典: AtCoder Beginner Contest 309 - C この問題は二分探索に帰着するまでに考察が必要です。 頭の体操のつもりで考えてみましょう！ (解けなくても心配しないでください。問題を楽しみましょう！) 解答 $x$日目に処方される薬の数は、 $$ \\sum_{\\substack{1 \\leq i \\leq N \\\\ x \\leq a_i}} b_i $$ で求めることができます。 プログラム的には、 long sum = 0; for (int i = 0; i \u0026lt; N; i++) { if (x \u0026lt;= A[i]) sum += B[i]; } という感じです。 制約から、この値は$x=1$の時最大値をとり、そこから広義単調減少することがわかります。 この性質から、この値が$K$以下になるか？を判定する関数$f$が二分探索の条件を満たしそうだと分かります。 また、$s(x)$を計算するのに$O(N)$しか必要としないため、これまた二分探索で解けそうな雰囲気があります。 結論から言うと、次の関数を用いることで二分探索可能になります。 $$ s(x) \\coloneqq \\sum_{\\substack{1 \\leq i \\leq N \\\\ x \\leq a_i}} b_i $$ とするとき、 $$ \\begin{equation*} f(x) = \\begin{cases} 0 \u0026amp; \\text{if $K \u0026lt; s(x)$,} \\\\ 1 \u0026amp; \\text{if $s(x) \\leq K$.} \\\\ \\end{cases} \\end{equation*} $$ 解答は以下の通りです。 import std; import core.stdc.stdio; void main () { /* 入力 */ int N, K; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;N, \u0026amp;K); int[] a = new int[](N); int[] b = new int[](N); for (int i = 0; i \u0026lt; N; i++) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i], \u0026amp;b[i]); /* sの定義 */ long s (int x) { long ret = 0; for (int i = 0; i \u0026lt; N; i++) if (x \u0026lt;= a[i]) ret += b[i]; return ret; } /* fの定義 */ bool f (int x) { return s(x) \u0026lt;= K; } int ok = 10^^9+1, ng = 0; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } writeln(ok); } 時間計算量は$O(N \\log{(\\max{a_i})})$になります。 また、この問題は二分探索以外の解法もあります。 Q4 (Advanced Problem): ABC312C - Invisible Hand 問題 りんご市場に$N$人の売り手と $M$人の買い手がいます。 $i$番目の売り手は、 $A_i$円以上でならりんごを売ってもよいと考えています。 $i$番目の買い手は、 $B_i$円以下でならりんごを買ってもよいと考えています。 次の条件を満たすような最小の整数 $X$を求めてください。 条件：りんごを $X$円で売ってもよいと考える売り手の人数が、りんごを $X$円で買ってもよいと考える買い手の人数以上である。 制約 $1 \\leq N, M \\leq 2 \\times 10^5$ $1 \\leq A_i, B_i \\leq 10^9$ 出典: AtCoder Beginner Contest 312 - C こちらもAtCoderから引っ張ってきました。 ちなみに私はこの問題の読解で詰まって本番で苦しみまくりました。 解答 りんごを$X$円で売ってよいと考える売り手の人数$P(X)$は、次のように求められます。 $$ P(X) = \\sum_{\\substack{1 \\leq i \\leq N \\\\\\\\ A_i \\leq X}} 1 $$ りんごを$X$円で買ってよいと考える買い手の人数$Q(X)$は、次のように求められます。 $$ Q(X) = \\sum_{\\substack{1 \\leq i \\leq M \\\\\\\\ X \\leq B_i}} 1 $$ 問題は、$Q(X) \\leq P(X)$を満たす最小の$X$を求めよというものです。 ここで、$P(X)$、$Q(X)$の性質を利用します。 $P(X)$は、$X$に対して広義単調増加し、$Q(X)$は広義単調減少することがわかります。 すなわち、不等式$Q(X) \\leq P(X)$はある値を境目に「それ以上なら常に成立」、「それ未満なら常に不成立」となることがわかります。 これらの考察から、二分探索できそうな感じがします。 実際に$P(X)$及び$Q(X)$を1回求めるのに$O(N)$時間しか必要としないため、うまくいきそうです！ 解答例を示します。 import std; import core.stdc.stdio; void main () { /* 入力を受け取る */ int N, M; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;N, \u0026amp;M); int[] A = new int[](N); int[] B = new int[](M); for (int i = 0; i \u0026lt; N; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;A[i]); for (int i = 0; i \u0026lt; M; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;B[i]); /* P(X) */ int P (int X) { int ret = 0; for (int i = 0; i \u0026lt; N; i++) if (A[i] \u0026lt;= X) ret++; return ret; } /* Q(X) */ int Q (int X) { int ret = 0; for (int i = 0; i \u0026lt; M; i++) if (X \u0026lt;= B[i]) ret++; return ret; } /* f(X) */ bool f (int X) { return Q(X) \u0026lt;= P(X); } int ok = 10^^9+1, ng = 0; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } writeln(ok); } 時間計算量は$O(N \\log{(\\max{(\\max{A}, \\max{B})})})$となります。 解きなおしてるときにまたWA出してしまった\u0026hellip; この問題苦手です。 終わりに これで記事はおしまいです。 ここまで読んでいただきありがとうございました。 二分探索は、(最近は比較的マシになってきましたが)私がずっっっっと苦手としているアルゴリズムで、いつか自分の理解をまとめたいと思っていました。 良い機会だと思って思い切って書いてみましたが、正直うまくまとめられなかった感を感じています。 もし本記事を読んで、「全然わからん！」と思った方がいれば、多分私の理解や説明が甘いせいです。すみません。 一方で、もし誰かの理解の助けになればうれしいです。 もし本記事に指摘、感想等いただけるなら、Twitterの方までお願いします。 明日(12月7日)はみのさんによる、「2023年度財政状況報告」と、あかあくさんによる「アニメオタクのためのサイトを作った」です。 興味深いタイトルですね。 更新が楽しみです。 それではよい二分探索ライフを！"
  },
  {
    url: "/post/abc330/",
    title: "ABC330参加記録",
    date: "2023-11-25T00:00:00Z",
    body: "ABC330参加記録 はじめに 本稿は、2023-11-25に行われたABC330の参加記録です。 眠れない夜にはコンテストの参加記録を書くのが良いと古事記にも書いてあった要出典ので更新します。 戦績 今回の提出記録は以下の通りです。 AからEまでの5問正解できました。パフォーマンスは1420で、レーティング変動は1200→1224(+24)でした。 所感 今回解ける問題を解いたという感じです。 何とか緑落ち回避できてよかった。 雑振り返り A - Counting Passes 問題へのリンク 配列を前からひとつづつ見ていけば良いです。 こういう感じのA問題楽でうれしいですよね。 import std; void main () { int N, L; readln.read(N, L); int[] A = readln.split.to!(int[]); int count = 0; foreach (a; A) if (L \u0026lt;= a) count++; writeln(count); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - Minimize Abs 1 問題へのリンク Bにしては問題文が難しいです。何を言っているのかわからなくて1分くらい固まっていました。 要するに、次のような感じです。 $1 \\leq i \\leq N$に対して次の問題を解け。 $L \\leq X_i \\leq R$を満たす$X_i$であって、$A_i$と最も近いものを求めよ。 これなら少しマシになった気がします。$A_i \\in [L, R]$であれば、一番近い値は当然$A_i$そのものになるので、$A_i$が答えになります。 そうでない時は、$L$か$R$しかありえません。場合分けして解答しましょう。 import std; void main () { int N, L, R; readln.read(N, L, R); int[] A = readln.split.to!(int[]); int[] ans = new int[](N); foreach (i, a; A) { if (L \u0026lt;= a \u0026amp;\u0026amp; a \u0026lt;= R) { ans[i] = a; } if (a \u0026lt; L) ans[i] = L; if (R \u0026lt; a) ans[i] = R; } foreach (i, a; ans) write(a, i == ans.length-1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - Minimize Abs 2 問題へのリンク とりあえず$x$は固定して考えましょう。$D - x^2 = D^\\prime$とおくと、$|y^2 - D^\\prime|$の最小化問題になります。ただし、$D^\\prime \\in [D-1, \\infty)$に留意しましょう。 うーん、絶対値記号が絶妙にキモいですね。多分外さなくてもいいはずですが、外しましょう。 $$\\begin{equation*} |y^2 + D^\\prime| = \\max (y^2 - D^\\prime, D^\\prime - y^2) \\end{equation*}$$ ムっ、この2項は単調性がありそうですね！ 1項目が最小になるときは、$D^\\prime \\leq y^2$を満たす最小の$y$で、2項目が最小になるときは、$y^2 \\leq D^\\prime$を満たす最大の$y$になるはずです。 これ、二分探索で求められそうですね。 というわけで、ある$x$を与えたときに、最適解になる$y$を高速に探索する方針がたったので、これで終わりです。 import std; void main () { long D = readln.chomp.to!long; solve(D); } void solve (long D) { // xは10^6程度まででよいので、それらに対してyを探索 long ans = long.max; long x = 1; while (true) { if (D \u0026lt; x*x) { break; } // このxに対してのyを求める -\u0026gt; 大体x^2+y^2 - D = 0 =\u0026gt; x^2 + y^2 = D となるような感じで long ok = 0, ng = 2*10^^6; while (1 \u0026lt; abs(ok-ng)) { long mid = (ok+ng) / 2; if (x*x+mid*mid \u0026lt;= D) { ok = mid; } else { ng = mid; } } long candi = min(D - x*x - ok*ok, x*x + ng*ng - D); ans = min(ans, candi); x++; } writeln(ans); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } $x$の上限が$\\sqrt{D}$で抑えられることを考えれば、全体$O(\\sqrt{D} \\log \\sqrt{D})$で抑えられているはずです。多分。 これは普通に難しいと思ったんですが、意外にdifficultyが低かったです。私の解よりもシンプルな全探索解が想定解法らしく(計算量も向こうの方が良い)ちょっと残念です。 D - Counting Ls 問題へのリンク まず、行と列を固定して考えます。 そもそもこのような組が取れるのは、固定した行と列の交点がoであるもののみであることが分かります。 そこから、行と列の好きな場所から1つずつoをとればもれなく数え上げられそうです。 被りがないことの正当性は、固定した行と列が一つでも異なれば、角に当たる部分のoは必ず異なるものが採用されることから従います。 漏れがないことの正当性は、信じる気持ちです(は？)。 というわけで、各行と列に何個oがあるかを保持しておけば、グリッド走査分の$O(N^2)$で計算できます。 本番での私は意味不明なことをしていたので、upsolveの方をあげておきます。 import std; void main () { int N = readln.chomp.to!int; string[] S = new string[](N); foreach (i; 0..N) S[i] = readln.chomp; solve(N, S); } void solve (int N, string[] S) { int[] vertical = new int[](N); // vertical[i] := 列iに何個\u0026#39;o\u0026#39;があるか int[] horizontal = new int[](N); // horizontal[i] := 行iに何個\u0026#39;o\u0026#39;があるか foreach (i; 0..N) foreach (j; 0..N) if (S[i][j] == \u0026#39;o\u0026#39;) horizontal[i]++; foreach (j; 0..N) foreach (i; 0..N) if (S[i][j] == \u0026#39;o\u0026#39;) vertical[j]++; long ans = 0; foreach (i; 0..N) foreach (j; 0..N) { if (S[i][j] == \u0026#39;o\u0026#39;) { ans += (horizontal[i]-1) * (vertical[j]-1); } } writeln(ans); } E - Mex and Update 問題へのリンク 一瞬セグメントツリーの香りを感じてビクッ！としましたが、落ち着いて考えます。 そもそもmex計算がややこしい点は、前の方の要素が全埋めされたときに、いきなり解が後ろの方に飛んでいくことがあり得るからです。 それなら、先に候補地を持っておけばよいじゃないという発想で解きました。 初期状態 mex候補は次のいずれかのみ。 $0$ $A_i+1$ 更新 新しくmex候補となるのは次のいずれかのみ。 $x_k+1$ $A_{i_k}$ というわけで、実は候補地点は更新時に$O(1)$個しか変化しないんですね。 あとは雑に優先度付きキューに突っ込んで、mexとして採用できるかどうかは連想配列で判定したら解けます。 import std; void main () { int N, Q; readln.read(N, Q); int[] A = readln.split.to!(int[]); solve(N, Q, A); } void solve (int N, int Q, int[] A) { // セグ木？ いや、実は候補が少ないパターンのやつだ // 新しく更新したとき、mex候補として一つ後ろをキューに積んでおけばよい int[int] mp; foreach (a; A) mp[a]++; BinaryHeap!(int[], \u0026#34;b\u0026lt;a\u0026#34;) PQ = []; foreach (a; A) if (a+1 !in mp) PQ.insert(a+1); PQ.insert(0); int[] ans = new int[](Q); foreach (j; 0..Q) { int i, x; readln.read(i, x); i--; mp[A[i]]--; mp[x]++; if (x+1 !in mp || mp[x+1] == 0) PQ.insert(x+1); if (A[i] !in mp || mp[A[i]] == 0) PQ.insert(A[i]); A[i] = x; while (true) { auto head = PQ.front; if (head !in mp || mp[head] == 0) { ans[j] = head; break; } PQ.removeFront; } } foreach (a; ans) writeln(a); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 最悪計算量の評価全くしてないけどなんか通りました。まあクエリが$2 \\times 10^5$程度しか来ないので、それはそうですね。 また、この問題はもっと賢い解き方が存在します。$N$要素数列のmexは定義から$[0, N]$の区間内に入ります。 なので、実は極端に大きな項は無視してもよかったわけです。 この議論より、$0$から$N$までの$N+1$要素の配列を持ってシミュレーションをすると解けます。 mexを見つけるのは順序付き集合で対数時間です。 import std; void main () { int N, Q; readln.read(N, Q); int[] A = readln.split.to!(int[]); solve(N, Q, A); } void solve (int N, int Q, int[] A) { int[] range = new int[](N+1); // [0, N]をシミュレーション auto rbt = new RedBlackTree!(int, \u0026#34;a\u0026lt;b\u0026#34;, false); foreach (a; A) if (a \u0026lt;= N) range[a]++; foreach (i, r; range) if (r == 0) rbt.insert(cast(int) i); int[] ans = new int[](Q); foreach (j; 0..Q) { int i, x; readln.read(i, x); i--; // 0-indexed if (A[i] \u0026lt;= N) { range[A[i]]--; if (range[A[i]] == 0) rbt.insert(A[i]); } A[i] = x; if (x \u0026lt;= N) { range[x]++; if (range[x] == 1) rbt.removeKey(x); } ans[j] = rbt.front; } foreach (a; ans) writeln(a); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } これ、とても賢いですね。mexは$[0, N]$というのは覚えておきたいです。 F - Minimize Bounding Square 問題へのリンク 難しい！正方形の1辺を二分探索するのかと思っていたけど、判定問題が全然解けない！ どうやら貪欲解も存在するらしく、まだまだ壁は高いなとおもいました。 終わりに 今回の参加記録はこれで終わりです。読んでいただきありがとうございました。 先週の参加記録を書けていなかったのが少し心残りです。 今週はいろいろと忙しくて、それをやるだけの心的余裕がありませんでした。 12月は緑以下オンサイトに行く予定です。もし行く人いたら仲良くしてください。そうでなければ多分ぼっちです。 昨日、MMA Contest 017がありましたが、実は私もテスターをさせていただきました。 走っていない人はぜひどうぞ。余裕があれば私も記事書きます(優先度低め)。 適当に近況も書いておきます。 この間のPG battleの景品が届きました。PG battleのステッカーが6枚も入っていてたまげたのですが、これあってますか？ 最近kindleに興味があります。 先日、面白そうな本を見つけたのですが、経験上、本として所有していても読む機会がなかなかないなと思い、電子書籍なら読むのか実験してみたいという感じです。 基本食事中とかスマホばっかり見てるので、そういう時間に見れるブログみたいな本が読みたいな。とか妄想してます。ちなまだデビューしてないです。 いろいろと書き散らしたいことは脳内にあるのですが、いかんせん競技プログラミングのエントリ以外最初の一歩が踏み出せないのが悩みです (そういうアイディアは形にしようとすると崩壊するのが常なので、まあそれはそうという感じかも)。 それではまた。"
  },
  {
    url: "/post/abc328/",
    title: "ABC328参加記録",
    date: "2023-11-12T00:00:00Z",
    body: "ABC328参加記録 はじめに 本稿は、2023-11-11に行われたABC328の参加記録です。 戦績 今回の提出は以下の通りでした。 AからEの5問正解できました。 今回のレーティング変動は以下の通りでした。 パフォーマンスは1281で、 レーティング変動は1241→1245(+4) でした。 所感 今回はDまでかなり早く解ましたがE問題で詰まってしまい、パフォーマンスがあまり伸びませんでした。 解けないとマズいという問題は解けたので、とりあえず良しとします。 今回のF問題がPotentialized UnionFindというものを利用すれば簡単に解けたらしく、 自分が解法にたどり着けなかったという点と、ちゃんと前もって学習できていなかったということに対してかなり悔しく感じてします。 今週のプロコンは、このデータ構造を理解してD言語による実装を与えることを目標にやろうかなと思います。 学ぶ機会をもらったと思って頑張ります。 問題振り返り A - Not Too Hard 問題へのリンク 最近のA問題の中でも結構簡単な方な気がします。配点をひとつづつ見ていって、X以下なら足しましょう。 import std; void main () { int N, X; readln.read(N, X); int[] S = readln.split.to!(int[]); int ans = 0; foreach (s; S) if (s \u0026lt;= X) ans += s; writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - 11/11 問題へのリンク 実装を考えるとき、有効な月/日を生成することと、ゾロ目になることを分けて考えるとやりやすいのかなと思います。 型変換(int -\u0026gt; string)を簡単にできる言語なら、次のような実装がよいかと思います。 import std; void main () { int N = readln.chomp.to!int; int[] D = readln.split.to!(int[]); int ans = 0; for (int i = 1; i \u0026lt;= N; i++) { for (int j = 1; j \u0026lt;= D[i-1]; j++) { auto S = i.to!string ~ j.to!string; bool ok = true; foreach (s; S) if (s != S[0]) ok = false; if (ok) ans++; } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } そうでない言語なら、判定部分を bool ok = true; int basis = i%10; while (0 \u0026lt; i) { if (i%10 != basis) ok = false; i /= 10; } while (0 \u0026lt; j) { if (j%10 != basis) ok = false; j /= 10; } という感じになるかなと思います。 C - Consecutive 問題へのリンク ナイーブに操作すると$r_i - l_i$が大きいクエリばかり飛んでくるときが最悪ケースで、$O(N^2)$です。 区間クエリを高速化する問題は、累積和を考えると良い場合があります。この問題はまさにそうで、 cum[i] := (S[j] == S[j+1]なら1、そうでないなら0 の 0\u0026lt;=j\u0026lt;=iの総和)と定めると、 前処理$O(N)$クエリ$O(1)$で答えることができます。 クエリをどうやって処理するべきかを一回考えると思いつきやすいような気がします。 (連続区間において条件を満たす場所を数える) -\u0026gt; (条件を満たす場所を1、満たさない場所を0と対応させて、Static Range Sum Queryに帰着) -\u0026gt; 累積和 という流れなのかなと思います。 2番目の考察(あるを1、ないを0に対応させること)がかなりad-hocな気がしますが、これはかなり頻出なので覚えるべきことなのかな？ ちなみに、2番目の考察はDynamic Kth Elementとか$O(N \\log N)$の転倒数にも現れるアイデアです。 import std; void main () { int N, Q; readln.read(N, Q); string S = readln.chomp; solve(N, Q, S); } void solve (int N, int Q, string S) { // imosをやる long[] cum = new long[](N); foreach (i; 0..S.length-1) if (S[i] == S[i+1]) cum[i]++; foreach (i; 1..N) cum[i] += cum[i-1]; foreach (_; 0..Q) { int l, r; readln.read(l, r); l--, r--; if (l == r) { writeln(0); continue; } if (0 \u0026lt; l) writeln(cum[r-1]-cum[l-1]); else writeln(cum[r-1]); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Take ABC 問題へのリンク ナイーブに操作すると削除の後に「詰める」操作が発生するので、$O(N^2)$になります。これを改善します。 「左から削除していく」という文言を見た時点で、括弧列の対応を見る問題との共通点を感じました。 \u0026quot;ABC\u0026quot;が\u0026quot;()\u0026quot;だったら有効括弧列を消す問題になるんじゃないかな？ 括弧列の問題 -\u0026gt; 文字列を先頭から見ていって(見たやつをスタックに積んでいって) \u0026quot;)\u0026quot;が出てきたらスタックの先頭が\u0026quot;(\u0026quot;かどうかチェックする。 この問題 -\u0026gt; 文字列を先頭から見ていって\u0026quot;C\u0026quot;が出てきたらスタックの先頭が\u0026quot;AB\u0026quot;かどうかチェックする。 みたいな感じで処理できます。一つの文字を高々2回までしか参照しないので、$O(N)$です。 import std; void main () { string S = readln.chomp; solve(S); } void solve (string S) { /* 前から見ていけばよろしい */ char[] ans; foreach (c; S) { ans ~= c; if (3 \u0026lt;= ans.length) { if (ans[$-3..$] == \u0026#34;ABC\u0026#34;) { ans = ans[0..$-3]; } } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } E - Modulo MST 問題へのリンク 全域木(Spanning Tree)とは、与えられた$G$の部分グラフ$G\u0026rsquo;$であって、$G$のすべての頂点$V(G)$を含み、かつ木であるようなものをいいます。 全域木であって、辺の重みの総和が最小であるものを最小全域木(MST)といいますが、本問では総和ではなく総和を$K$で割ったあまりをコストとしています。 最小全域木を求めるアルゴリズム(クラスカル法など)は役に立ちそうにないです。 制約を見ると、不自然に小さいです。また、あまりを含む最小化問題は感覚的に全探索しかなさそうな感じがします。 そこで、全探索を考えましょう。 「$G\u0026rsquo;$が全域木である」 ならば 「$G\u0026rsquo;$は$N-1$本の辺を持つ」 は真です。つまり、 $G$が全部で$M$本の辺を持つ時、 $\\dbinom{M}{N-1}$通りの辺の取り方を全部調べることができたら十分なことは明らかです。 (この組み合わせには全域木にならないケースも含まれる可能性がありますが、それはコスト更新の時に無視したらよいです。) 今回に関しては最大ケースで$\\dbinom{28}{7} = 1184040$になります。これで通せそうです。 import std; struct trio { int u, v; long w; } void main () { int N, M; long K; readln.read(N, M, K); trio[] edge = new trio[](M); foreach (i; 0..M) with(edge[i]) { readln.read(u, v, w); u--, v--; } solve(N, M, K, edge); } void solve (int N, int M, long K, trio[] edge) { /* Nが十分に小さいので、あり得る全域木を全探索すればよろしい */ /* ほげほげのコストを無視すれば、ありうる全域木は28C7 ~ 10^6通りのはず */ /* あほか？28C7列挙すればいいだろう */ int[][] graph = new int[][](N, 0); bool[] visited = new bool[](N); bool check (trio[] edge) { foreach (ref g; graph) g.length = 0; foreach (e; edge) { graph[e.u] ~= e.v; graph[e.v] ~= e.u; } visited[] = false; void dfs (int pos) { visited[pos] = true; foreach (to; graph[pos]) { if (!visited[to]) dfs(to); } } dfs(0); foreach (v; visited) if (!v) return false; return true; } long ans = long.max; foreach (e; enumComb(edge, N-1)) { if (check(e)) { long sum = 0; foreach (ee; e) (sum += ee.w) %= K; ans = min(ans, sum); } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } struct enumComb_(T) { import std.exception; import std.format; import std.range.primitives : ElementType, isRandomAccessRange; long N, K; long[] idx; bool isEmpty; enum bool isNumeric = __traits(isIntegral, T); static if (!isNumeric) { static assert(__traits(compiles, isRandomAccessRange!(T)) || is(T == E[n], E, size_t n) || is(T == E[], E), \u0026#34;T must be Integral type or RandomAccessRange. Now T = \u0026#34;, T.stringof); alias E = ElementType!(T); E[] res; T arr; } this (T N, long K) { static if (isNumeric) { auto msgN = format(\u0026#34;Line : %s, N must be greater than or equal to 0. your input = %s\u0026#34;, __LINE__, N); enforce(0 \u0026lt;= N, msgN); this.N = N; } else { this.N = N.length; arr = N; res = new E[](cast(uint) K); } auto msgK = format(\u0026#34;Line : %s, K must be greater than or equal to 0. your input = %s\u0026#34;, __LINE__, K); enforce(0 \u0026lt;= K, msgK); this.K = K; idx = new long[](cast(uint) K); init(); } void init () { foreach (i; 0..K) { idx[cast(uint) i] = i; } if (N \u0026lt; K) { isEmpty = true; } } bool empty() const { return isEmpty; } static if (isNumeric) { long[] front() { return idx; } } else { E[] front () { foreach (i, x; idx) { res[i] = arr[cast(uint) x]; } return res; } } void popFront() { long index; (){ foreach (i; 0..K) { if (idx[cast(uint) ($-i-1)] \u0026lt; N-i-1) { idx[cast(uint) ($-i-1)]++; index = K-i-1; return; } } // there is no choice :( isEmpty = true; }(); foreach (i; index+1..K) { idx[cast(uint)i] = idx[cast(uint)i-1] + 1; } } } auto enumComb(T) (T N, long K) { return enumComb_!(T)(N, K); } ちょうど$\\dbinom{N}{K}$を列挙するアルゴリズムを用意していたので、そんなに苦労せず実装できました。 1700msだったのであまりよくない実装をしていたっぽい\u0026hellip;？ F - Good Set Query 問題へのリンク 題意自体はつかめたのですが、いつものトポロジカル順に処理する奴ではうまく列$(X_1, X_2, \\dots, X_N)$ を決められないなーと思い、そこで行き詰りました。 どうやら重み付き(ポテンシャル付き)UnionFindなるデータ構造で解けるようです。 今週中に解法及びデータ構造を理解して、ACします。(時間があれば別記事たてます。) 終わりに 書きたいことは大体書いたので、あとは適当に近況でも書きます。 最近レーティングが1200あたりで収束している感じがあり、上に行くためにはもっとプロコンに力を入れないとなーと感じています。もっといろんな知識を仕入れたいです。 短期的な目標としては来年までに1300到達、もう少し長期的な目標は次のICPCまでに1600到達です。 無理かもしれませんが、Problemsの水色埋めを客観的に見た感じ到達可能にも感じます。 あと、思うこととして、レーティングとかの指標は本来過去の自分と比較すべきだと考えているのですが、 Twitterとかを追っていると意味のない焦りや嫉妬によって無駄なエネルギーが消耗している実感があります。本来こんな無駄なことをせずに研鑽すべきなんですがね。。。 過去の経験も含めて自分はSNS依存の傾向があるので、自制していきたいですね。 最近、品田遊著「名称未設定ファイル」Amazonリンク(アフィではないです)を読みました。 星新一が好きな人とかおすすめです。あと、普段本じゃなくてネットばっかり見てる私みたいな人にもおすすめです。 それではこのあたりにしておこうと思います。また次のエントリで。"
  },
  {
    url: "/post/abc100d/",
    title: "ABC100D - Patisserie ABC",
    date: "2023-11-06T00:00:00Z",
    body: "ABC100D - Patisserie ABC 問題概要 問題へのリンク $N$種類のケーキがある。$i$種類目のケーキは「綺麗さ」$x_i$、「おいしさ」$y_i$、「人気度」$z_i$を持っている。 このうち$M$種類のケーキを選んで食べる。ただし、同じ種類のケーキを2つとることはできない。 選んだ$M$種類のケーキに対して、スコアを $\\left| \\displaystyle\\sum_{i=1}^M x_i \\right| + \\left| \\displaystyle\\sum_{i=1}^M y_i \\right| + \\left| \\displaystyle\\sum_{i=1}^M z_i \\right|$ と定める。 スコアの最大値を求めよ。 制約 $1 \\leq N \\leq 1000$ $0 \\leq M \\leq N$ $1 \\leq i \\leq N$に対して、$-10^{10} \\leq x_i, y_i, z_i \\leq 10^{10}$ 考察 ナイーブに全探索を考えると、とりうるケーキの組み合わせの数は $\\displaystyle\\binom{N}{M}$通りになるが、$N = 1000, M = 500$において非常に大きくなるため現実的でない。 また、各$x_i, y_i, z_i$の値が大きいため部分和問題のようなdpはできない。 どうしようか？ 解法1 典型テクニック: 「絶対値関数はmax関数で外す」を用いる。 頑張って変形していく。 $$ \\begin{equation*} \\begin{split} \\left| \\displaystyle\\sum x_i \\right| + \\left| \\displaystyle\\sum y_i \\right| + \\left| \\displaystyle\\sum z_i \\right| \u0026= \\max \\left( \\displaystyle\\sum x_i, ~ -\\displaystyle\\sum x_i \\right) + \\max \\left( \\displaystyle\\sum y_i, ~ -\\displaystyle\\sum y_i \\right) + \\max \\left( \\displaystyle\\sum z_i, ~ -\\displaystyle\\sum z_i \\right) \\\\ \u0026= \\max \\left( \\displaystyle\\sum x_i + \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~ \\displaystyle\\sum x_i + \\displaystyle\\sum y_i - \\displaystyle\\sum z_i, ~ \\displaystyle\\sum x_i - \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~ \\displaystyle\\sum x_i - \\displaystyle\\sum y_i - \\displaystyle\\sum z_i, ~ -\\displaystyle\\sum x_i + \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~ -\\displaystyle\\sum x_i + \\displaystyle\\sum y_i - \\displaystyle\\sum z_i, ~ -\\displaystyle\\sum x_i - \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~ -\\displaystyle\\sum x_i - \\displaystyle\\sum y_i - \\displaystyle\\sum z_i \\right) \\\\ \u0026= \\max \\left( \\displaystyle\\sum (x_i + y_i + z_i), ~ \\displaystyle\\sum (x_i + y_i - z_i), ~ \\displaystyle\\sum (x_i - y_i + z_i), ~ \\displaystyle\\sum (x_i - y_i - z_i), ~ \\displaystyle\\sum (-x_i + y_i + z_i), ~ \\displaystyle\\sum (-x_i + y_i - z_i), ~ \\displaystyle\\sum (-x_i - y_i + z_i), ~ \\displaystyle\\sum (-x_i - y_i - z_i) \\right) \\end{split} \\end{equation*} $$ とてもすっきりした式になった。 よく見ると、最後のmax関数の中にある各項は$O(N\\log N)$で計算できることが分かる。 よって全体$O(N\\log N)$で解くことができる。 import std; alias trio = Tuple!(long, \u0026#34;x\u0026#34;, long, \u0026#34;y\u0026#34;, long, \u0026#34;z\u0026#34;); void main () { int N, M; readln.read(N, M); trio[] cake = new trio[](N); foreach (i; 0..N) { with (cake[i]) readln.read(x, y, z); } solve(N, M, cake); } void solve (int N, int M, trio[] cake) { /* 典型テク: 絶対値記号を外すやつ によって符号を変えた8通りの和で貪欲にとればよい。O(N log(N)) */ long[] val = new long[](N); int[] sign = new int[](3); long ans = -long.max; void calc () { foreach (i; 0..N) { val[i] = 0; foreach (j, c; cake[i]) { if (sign[j] == 0) val[i] += c; if (sign[j] == 1) val[i] -= c; } } val.sort!\u0026#34;a\u0026gt;b\u0026#34;; ans = max(ans, val[0..M].sum); } void dfs (int level) { if (level == 3) { /* 処理 */ calc(); return; } foreach (i; 0..2) { sign[level] = i; dfs(level+1); } } dfs(0); writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 解法2 はまやんさんの解説で紹介されているdpをすることもできる。 結論から言うと、最初検討した部分和問題ではなく $$ \\begin{equation*} dp[i][j] = (i項目までのうちj項をとったとき、あり得る最大値) \\end{equation*} $$ を考える。 このdpを考えるに至る考察は大体次のような感じになる。 $x_i, y_i, z_i$別々だとだるいので、まず$x_i$についてだけ考える。 絶対値をとるので、最適解は$\\sum x_i$が最大または最小になるときだと分かる。 →最大の値が採用されるときは普通にdpで解ける。 最小になるときが最適解になるときは総和が負になるはずなので、符号を反転させた状態でのdpも考える。 3軸に戻す。3軸すべてが最大をとるタイミングを採用できるように、8通りの符号でdpする。 詳しいアルゴリズムは実装例を参考にしてください。 import std; struct trio { long x, y, z; } void main () { int N, M; readln.read(N, M); trio[] cake = new trio[](N); foreach (i; 0..N) { with (cake[i]) readln.read(x, y, z); } solve(N, M, cake); } void solve (int N, int M, trio[] cake) { long[][] dp = new long[][](N+1, M+1); // dp[i][j] := (i項目までからj項選んだ時の最大値) long ans = 0; /* 符号8通りでdp */ for (int a = -1; a \u0026lt;= 1; a++) for (int b = -1; b \u0026lt;= 1; b++) for (int c = -1; c \u0026lt;= 1; c++) if (a*b*c != 0) { foreach (d; dp) d[] = -long.max; dp[0][0] = 0; foreach (i; 0..N) foreach (j; 0..M+1) { if (dp[i][j] == -long.max) continue; long diff = a*cake[i].x + b*cake[i].y + c*cake[i].z; // 採用 if (j+1 \u0026lt;= M) dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + diff); // 採用しない dp[i+1][j] = max(dp[i+1][j], dp[i][j]); } ans = max(ans, dp[N][M]); } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 発展 解法1は45度回転と呼ばれるテクニックとも関連がある。 45度回転とは2次元座標平面上においてマンハッタン距離を考えるときに有用になるテクニックである。 1問紹介しておこう。 ABC178E - Dist Max 問題文 2点$(a, b), ~ (c, d)$に対して2点間のマンハッタン距離を$|a - c|+|b - d|$と定める。 $N$点$(x_i, y_i)$が与えられる。2点間のマンハッタン距離としてあり得る最大の値を求めよ。 制約 $2 \\leq N \\leq 2\\times 10^5$ $1 \\leq x_i, y_i \\leq 10^9$ これを同様に処理してみる。 適当な二点についてマンハッタン距離を考えると、次のようになる。 $$ \\begin{equation*} \\begin{split} |x_i - x_j| + |y_i - y_j| \u0026= \\max (x_i - x_j, ~ x_j - x_i) + \\max (y_i - y_j, ~ y_j - y_i) \\\\\\\\ \u0026= \\max ((x_i - x_j)+(y_i - y_j), ~ (x_i - x_j)+(y_j - y_i), ~ (x_j - x_i)+(y_i - y_j), ~ (x_j - x_i)+(y_j - y_i)) \\\\\\\\ \u0026= \\max ((x_i + y_i)-(x_j + y_j), ~ (x_i - y_i)-(x_j - y_j), ~ -(x_i - y_i)+(x_j - y_j), ~ -(x_i + y_i)+(x_j + y_j)) \\\\\\\\ \u0026= \\max (|(x_i + y_i) - (x_j + y_j)|, ~ |(x_i - y_i) - (x_j - y_j)|) \\end{split} \\end{equation*} $$ を得る。 最後の式から、すべての点に対して$x_i + y_i$と$x_i - y_i$を計算して、 それぞれの差分の絶対値の最大値を見つければよい。 これは単にそれぞれの最大値と最小値を与える点を見つければよいため、全体$O(N)$で処理できる。 以上より、マンハッタン距離を代表とする絶対値記号は、max関数を用いて外すとうまく計算できる場合がある。 筆者は解法を理解していないが、yukicoder No.2520 L1 Explosionも45度回転を用いるらしい。 この問題は今後の課題としたい。 終わりに いつか取り上げたいと思っていたトピックに触れることができてよかった。 ただし、現状私はこの変換がなぜうまくいくのかという数学的背景を知らないため、 さらに勉強ないし応用の余地があると思う。 が、疲れたのでこのあたりにしておく。"
  },
  {
    url: "/post/abc327/",
    title: "ABC327参加記録",
    date: "2023-11-05T00:00:00Z",
    body: "ABC327参加記録 はじめに 本稿は、2023-11-04に行われたABC327の参加記録です。 戦績 今回の提出状況は次の通りです。 AからEまでの5問正解できました。 パフォーマンスは1513で、 レーティング変化は1207→1241(+34)でした。 所感 今回は割と早解きできた回だったかなという感じです。 5問目は割と非自明だと思ったのですがかなりたくさんの人が通していました。 とりあえず緑色に再び落下しなくてほっとしています。 問題雑振り返り A - ab 問題へのリンク Nが十分に小さいため、全部ナイーブに見ていくことで十分ACできます。 最初勘違いしていたため、サンプルに\u0026quot;ba\u0026quot;の順でYesが出るものがあってよかったです。 import std; void main () { int N = readln.chomp.to!int; string S = readln.chomp; foreach (i; 0..S.length-1) { if ((S[i] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; S[i+1] == \u0026#39;b\u0026#39;) || (S[i] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; S[i+1] == \u0026#39;a\u0026#39;)) { writeln(\u0026#34;Yes\u0026#34;); return; } } writeln(\u0026#34;No\u0026#34;); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - A^A 問題へのリンク $A^A$はかなり急激に大きくなるので、$A$を1から順番に$A^A$が$B$を超えるまで増やしていけばよさそうです。 実際、$10^{18} \u0026lt; 16^{16} = 18446744073709551616$なので、$A = 15$までを調べればよいです。 import std; void main () { long B = readln.chomp.to!long; for (long A = 1; ; A++) { if (B \u0026lt; A^^A) { writeln(-1); return; } if (B == A^^A) { writeln(A); break; } } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } ちなみに私の提出は通ってはいるものの、かなりまずいことをしています。 というのも、long.maxよりも$16^{16}$のほうが大きいためオーバーフローしています。 しかし、偶然オーバーフローを含めて$10^{18} \u0026lt; A^A$となるAが存在するようです。 ちゃんとACをとる場合はA=15で止めるか多倍長整数を使うと良いです。 C - Number Place 問題へのリンク 条件1と条件2は二重ループで簡単に判定できます。 条件3は少し複雑ですが、3×3領域を9回判定すると考えると比較的楽に判定をつくれます。 具体的には3×3領域のスタート地点(0, 0), (0, 3), (0, 6), \u0026hellip;, (6, 6)をループで列挙して、 判定自体はつかいまわします。 import std; void main () { int[][] A = new int[][](9, 0); foreach (i; 0..A.length) A[i] = readln.split.to!(int[]); solve(A); } void solve (int[][] A) { bool isOk = true; int[] mp = new int[](10); /* 条件1 */ foreach (i; 0..A.length) { mp[] = 0; foreach (j; 0..A[i].length) { mp[A[i][j]]++; } foreach (k; 1..10) { if (mp[k] != 1) isOk = false; } } /* 条件2 */ foreach (j; 0..A[0].length) { mp[] = 0; foreach (i; 0..A.length) mp[A[i][j]]++; foreach (k; 1..10) { if (mp[k] != 1) isOk = false; } } /* 条件3 */ int SY, SX; SY = 0; foreach (_; 0..3) { SX = 0; foreach (__; 0..3) { /* 処理 */ mp[] = 0; foreach (i; 0..3) foreach (j; 0..3) { int y = SY + i; int x = SX + j; mp[A[y][x]]++; } foreach (k; 1..10) { if (mp[k] != 1) isOk = false; } SX += 3; } SY += 3; } if (isOk) { writeln(\u0026#34;Yes\u0026#34;); } else { writeln(\u0026#34;No\u0026#34;); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Good Tuple Problem 問題へのリンク 二つの数列によってXの2項間に制約が課されていきます。 経験上、数列に制約を課していくような問題はグラフ表現に置き換えられないかを検討すると解けることがあります。 この問題はその方針さえ引ければかなり見えやすいと思います。 要はA[i]項目とB[i]項目が違えばよいので、 A[i]項目とB[i]項目の間に無向辺を張ったときに全体が二部グラフを成せばよいです。 二部グラフの判定にUnionFindを使えるらしいですが、よく理解していないので普通にdfsしました。 import std; void main () { int N, M; readln.read(N, M); int[] A = readln.split.to!(int[]); int[] B = readln.split.to!(int[]); solve(N, M, A, B); } void solve (int N, int M, int[] A, int[] B) { /* グラフ表現に落とし込んで解く */ /* 要は二部グラフなら良い */ A[] -= 1; B[] -= 1; int[][] graph = new int[][](N, 0); foreach (i; 0..M) { graph[A[i]] ~= B[i]; graph[B[i]] ~= A[i]; } int[] visited = new int[](N); visited[] = -1; bool isOk = true; void dfs (int pos) { foreach (to; graph[pos]) { if (visited[to] == -1) { if (visited[pos] == 0) visited[to] = 1; if (visited[pos] == 1) visited[to] = 0; dfs(to); } else { /* 矛盾がないか判定 */ if (visited[pos] == visited[to]) isOk = false; } } } foreach (i; 0..N) { if (visited[i] == -1) { visited[i] = 0; dfs(i); } } if (isOk) { writeln(\u0026#34;Yes\u0026#34;); } else { writeln(\u0026#34;No\u0026#34;); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } E - Maximize Rating 問題へのリンク 式をぐっとにらむところから考察スタートしました。 kがいろいろな値をとると面倒くさいので、とりあえず固定して考えます。 すると、$\\sum_{i=1}^{k} (0.9)^{k-i} Q_i$を最大化する問題になります。 が、変な係数がかかっているせいでQは貪欲にとれそうにありません。どうしましょう。 貪欲に取れない状況下で最適な部分集合を選ぶ問題というのは基本的に「全部見る」しかないはずです。 なので、この段階でdp濃厚だなーという感じです。(もちろん違う方針なときもあります。) ここで天啓が訪れます。 パフォーマンス$P_i$をx番目の項として採用する場合、 それまでにx-1個を採用した部分集合のみを考えればよいはずです。この方針で状態を圧縮します。 あとからとった項が前にとった項に直接寄与することがないので、次のdpができます。 $$ dp[i][j] = (Pを逆から見て、i項目までにj項とったときの\\sum (0.9)^{k-i} Q_iの最大値) $$ 遷移は /* 採用 */ dp[i+1][j+1] = dp[i+1][j+1], dp[i][j] + P[N-i-1]\\*pow(0.9, j)); /* 採用しない */ dp[i+1][j] = max(dp[i+1][j], dp[i][j]); となります。 このようなdpを私は勝手に「とる/とらないdp」と呼んでいるのですが、 圧縮後の値に部分集合の何項目に採用されたかという情報ものせられるのかと勉強になりました。 import std; void main () { int N = readln.chomp.to!int; int[] P = readln.split.to!(int[]); solve(N, P); } void solve (int N, int[] P) { /* いくつとるかを定めると、あとは最適なPの部分集合を見つける作業になる。 */ /* 最近のものほど重みが高い... -\u0026gt; 最適な部分集合は変わりうる。 */ /* 逆から考えれば、i項目まで見て、j個とって...とすると最適解をタプルに縮退できる。 */ /* dpをしましょう。 */ double[][] dp = new double[][](N+1, N+1); // dp[i][j] := 逆からi項目まで見て、j個とったとき、ありうる最大の分子 foreach (d; dp) d[] = -1; dp[0][0] = 0; foreach (i; 0..N) foreach (j; 0..N) { if (0 \u0026lt;= dp[i][j]) { // とる dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + P[$-i-1]*pow(0.9, j)); // とらない dp[i+1][j] = max(dp[i+1][j], dp[i][j]); } } double[] denominators = new double[](N+1); denominators[] = 0; denominators[1] = 1; foreach (i; 2..N+1) denominators[i] = denominators[i-1] + pow(0.9, i-1); double ans = -double.max; foreach (i; 0..N+1) foreach (j; 0..N+1) { if (0 \u0026lt; j) { ans = max(ans, dp[i][j]/denominators[j] - (1200/sqrt(j.to!double))); } } writefln(\u0026#34;%.10f\u0026#34;, ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } F問題以降 難しくてよくわからない。。。 F問題は考察の方針は非常に良かったようですが、解法を理解できるレベルに到達していないので本稿では触れません。 終わりに 最近$O(\\log N)$くらいの演算だからたくさん呼び出してもいいかーという 軽い気持ちでTLがぎりぎりになったりしていて、前計算の重要性を身に染みています。 前計算徹底いたします(ビッグモーター並感)。 近況も軽く書いておきます。 PG BATTLEで10位に入ることができて、商品をいただけるようです。やったね。 私の参加記録 PG BATTLE結果 PG BATTLE10位でしたーやったー 240点の中でトップらしい... あぶねーーー \u0026mdash; In (@UU9782wsEdANDhp) October 28, 2023 ちなみに商品は肉にしました。鍋にしたすぎ。 今年もUEC Advent Calendar 2023に参加します。プログラミングコンテストについて書く予定です。 皆さんも参加してみては？ アドベントカレンダー あと関係ないですが、最近自分の句読点の使い方の下手さにビビっています。 ほかの方が書いた文章や、プロの書いた文章に比べて明らかにリズムが悪い気がしています。 これを読んでいるあなたはどう思いますか？ まともな文章を書く訓練ってどうやってやるんでしょうね。 というわけでこのあたりにしておきます。また次の記事で～"
  },
  {
    url: "/post/abc190f/",
    title: "ABC190F - Shift and Inversions",
    date: "2023-11-01T00:00:00Z",
    body: "ABC190F - Shift and Inversions 問題概要 問題へのリンク $0$から$N-1$までの整数をちょうど一つづつ含む数列$A$が与えられる。 $k \\in \\mathbb{Z}$に対して、数列$B$を次のように定める。 $$ \\begin{equation*} B \\coloneqq \\{b_i\\}_{i=0}^{N-1}, ~ b_i = a_{i+k ~ \\mathrm{mod} ~ N} \\end{equation*} $$ $k = 0, 1, 2, \\dots , N-1$のそれぞれに対して、$B$の転倒数を求めよ。 制約 $2 \\leq N \\leq 2 \\times 10^5$ 考察 $k$を一つ変える操作は、変える前の数列を左シフトしたようなものになっている。 例えば、$A = (0, 1, 2, 3, 4)$であったとき、 $k=0$ : $B = (0, 1, 2, 3, 4)$ $k=1$ : $B = (1, 2, 3, 4, 0)$ $k=2$ : $B = (2, 3, 4, 0, 1)$ $k=3$ : $B = (3, 4, 0, 1, 2)$ $k=4$ : $B = (4, 0, 1, 2, 3)$ となる。 まずは転倒数について確認しておく。 転倒数とは、簡単に定義するなら、次の条件を満たす組$(i, j)$の個数である。 $i \u0026lt; j$ $B_i \u0026gt; B_j$ 言葉で言うなら、各要素に対しての「自分より左にいる、自分より大きなものの総数」の和である。 さて、操作によって転倒数がどう変化するかを考えよう。 操作は、「一番左の要素を一番右に持っていく」というものになっている。 これを行うと、全体の転倒数は次のように変化することがわかる。 動かした要素より小さい要素の数だけ転倒数が減る。 動かした要素より大きな要素の数だけ転倒数が増加する。 これは転倒数の定義からも簡単に確認できるだろう。 これで、操作1回によって転倒数がどれだけ変化するかはすぐ算出できることがわかった。 後は最初の数列の転倒数を求められればACできそうだ。 典型テク: 転倒数を$O(N \\log N)$で求める。 さて、数列$A$に対してナイーブに転倒数を求めるアルゴリズムを考えると、次のようなものになるだろう。 int InversionNumber = 0; for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; i; j++) { if (A[j] \u0026lt; A[i]) InversionNumber++; } } これは明らかに$O(N^2)$で、間に合わない。 さてどうしよう。 実は、転倒数を$O(N \\log N)$で求めるアルゴリズムが存在する。 ここからその説明をする。 転倒数の定義から、次が成立する。 $$ \\begin{equation*} (転倒数) = \\sum_{i=0}^{N-1} ((j\u0026lt;i) ~ \\land ~ (A_i \u0026lt; A_j)を満たすjの数) \\end{equation*} $$ 少し寄り道をする。 まず、非負数列$B$に対して数列$C$を次のように定める。 $$ \\begin{equation*} C \\coloneqq \\{c_i\\}_{i=0}, ~ c_i = (数列Bに含まれるiの個数) \\end{equation*} $$ 具体例を挙げよう。 数列$(0, 1, 2, 3)$に対して、$C = (1, 1, 1, 1, 0, 0, \\dots)$であり、 数列$(1, 1, 3, 5, 7)$に対して、$C = (0, 2, 0, 1, 0, 1, 0, 1, 0, \\dots)$となる。 また、数列$B$に対して定められる数列$C$を$C_B$と表すことにする。 数列$A$の$i$項目から$j$項目までを順番を変えずに切り取った数列を、$A$の連続部分数列と呼び、 $A[i \\dots j]$と表すとする。 これらを用いて先程の転倒数の定義を言い換えると、次のようになる。 $$ \\begin{equation*} (転倒数) = \\sum_{i=1}^{N-1} \\sum c \\in ( C_{A[0 \\dots i-1]}[A_i+1 \\dots \\infty] ) \\end{equation*} $$ 式が最悪すぎるのには目をつぶってほしい\u0026hellip;数学に明るくなく、うまい定式化ができなかった。 さて、ここで$C_{A[0 \\dots i-1]}$については各ケースに対して1から求める必要は無く、 $C_{A[0 \\dots i-2]}$に$A_i$を含めてやればよいことがわかるだろう。 また、数列$C$は(数列$A$の最大値)番目以降は全て0になるため、そこで打ち切って良い。 したがって、各ケースで 「数列の要素を一つだけ変更する。新しく得た数列の$A_i+1$番目から最後までの総和を求めよ」という問題を解けば良い。 この問題は、数列の動的区間和を高速に求めるデータ構造(BITやSegment Tree)を用いることで解ける。 例えば、Segment Treeを使った場合、区間和の更新と取得で$O(\\log N)$かかるため、全体で$O(N \\log N)$になる。 以上で最初の一つの転倒数を$O(N \\log N)$で得ることができた。 補足: 本章では必要以上にややこしい説明を行っていますが、これは自分が後で見返したときのためです。 正直ググって他の資料をあたったほうがわかりやすいと思います。ごめんなさい。 実装例 import std; void main () { int N = readln.chomp.to!int; int[] a = readln.split.to!(int[]); solve(N, a); } void solve (int N, int[] a) { /* 転倒数 O(NlogN) */ auto RSQ = new SegmentTree!(int, (int a, int b) =\u0026gt; (a+b), () =\u0026gt; 0)(a.length); long[] ans = new long[](N); foreach (i; 0..a.length) { ans[0] += RSQ.prod(a[i]+1, a.length); RSQ.set(a[i], RSQ.get(a[i])+1); } /* 左端を右端に動かすとき、(もとの数列がわかれば)転倒数の変化は比較的簡単にわかるので、最初の一回を求められれば後はO(N) */ foreach (i; 1..N) { ans[i] = ans[i-1] - a[i-1] + (N-a[i-1]-1); } foreach (i; 0..N) writeln(ans[i]); } Segment Treeの実装は長いので省略した。 感想 自力でACできたのと、転倒数を$O(N \\log N)$で求めるアルゴリズムに触れたので良かった。 このように、「すでにわかっている結果から少しいじると他の解がわかる」 みたいなタイプの問題を落とさないようにしたい(3戦1勝2敗)。"
  },
  {
    url: "/post/abc235e/",
    title: "ABC235E、あるいはクエリ並列処理",
    date: "2023-10-31T00:00:00Z",
    body: "ABC235E、あるいはクエリ並列処理 問題概要 問題 辺の重みがすべて異なる無向連結グラフ$G$が与えられる。 さらに、クエリ$i$で$G$中のどの辺とも異なる重みをもつ辺$(u_i, v_i, w_i)$が与えられる。 クエリ$i$で与えられた辺を$G$に追加したグラフ$G\u0026rsquo;$を考える。 すべての$i$に対して、辺$(u_i, v_i, w_i)$は$G\u0026rsquo;$の最小全域木に含まれるか判定せよ。 制約 $2 \\leq N \\leq 2 \\times 10^5$ ($G$の頂点数) $N-1 \\leq M \\leq 2 \\times 10^5$ ($G$の辺数) $1 \\leq Q \\leq 2 \\times 10^5$ 考察と解法 クラスカル法を考えると、辺を重みと連結性で貪欲にとればよい。 したがって、一つのクエリに対して$O(N \\log N)$で答えることができる。 しかし、このままだと全体$O(QN \\log N)$で間に合わない。 高速化を考える。 一つ一つのクエリは最小全域木に含まれるかどうかのみを判定して、元のグラフ$G$に取り込まれないことを利用しよう。 クラスカル法によると、辺の重みでソートして、辺が結ぶ頂点がまだ連結でない場合にのみ辺を採用すればよい。 そこで、次のアルゴリズムを考える。 すべてのクエリを先読みして、もとからあった$M$個の辺と$Q$個の辺を重みでソートする。 クラスカル法に基づいて、辺を採用するかどうかを判定していく。 ただし、クエリで与えられた辺は採用できる場合でも採用しない。 これでうまくいく。 なぜなら、一つのクエリから見れば、ほかのクエリによる$Q-1$個の辺は必ず採用されないため、 グラフ$G$の連結性に影響を与えていないからだ。 時間計算量は$O((N+Q) \\log (N+Q))$となる。 実装例 import std; struct edge { int u, v; long w; int idx; } void main () { int N, M, Q; readln.read(N, M, Q); edge[] e = new edge[](M+Q); foreach (i; 0..M) { with (e[i]) { readln.read(u, v, w); u--, v--; idx = -1; } } foreach (i; 0..Q) { with (e[i+M]) { readln.read(u, v, w); u--, v--; idx = i; } } solve(N, M, Q, e); } void solve (int N, int M, int Q, edge[] e) { /* 解説AC クラスカル法を適用すればクエリ単品なら簡単に解ける。これをどうするか？ -\u0026gt; クエリ先読みして、全部の辺をまとめてソートしたうえでその辺を採用できるかどうかを見ると行ける。 */ e.sort!\u0026#34;a.w \u0026lt; b.w\u0026#34;; string[] ans = new string[](Q); auto UF = UnionFind!int(N+Q); foreach (ee; e) with(ee) { if (UF.areInSameGroup(u, v)) { if (idx == -1) continue; ans[idx] = \u0026#34;No\u0026#34;; } else { if (idx == -1) { UF.unite(u, v); continue; } ans[idx] = \u0026#34;Yes\u0026#34;; } } foreach (i; 0..Q) { writeln(ans[i]); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } UnionFindの実装は長いので省いている。 典型テク: クエリ並列処理 今回の問題のように、あるクエリがほかのクエリに影響を与えない場合、 すべてのクエリを一斉に処理することで高速に解くことができる場合がある。 クエリが飛んでくる問題が来た時に一度は検討したい方針である。 発展 今回の問題は、別の解法もある。 クエリ$i$で$(u_i, v_i, w_i)$が来た時、 この辺が最小全域木に採用されるかどうかは、 $(u_i, v_i)$を結ぶパス(木なので、ちょうど一つ存在)に含まれる辺の最大重みが $w_i$より重いかどうかで判定することができる。 より具体的には、 もし$w_i$より重い辺が存在するなら、その辺をカットして、 $(u_i, v_i, w_i)$を採用することで全域木であることを保ちつつ、より総和が小さくなる。 そうでない場合は必ず総和が増える。 実は、この問題は解くことができる。(らしい) 詳しくはkyopuro_friendsさんの解説に載っているが、 私はまだ理解できていないため、紹介にとどめる。 終わりに この発想は出なかった。次見たときには解けるようになりたい。"
  },
  {
    url: "/post/pgbattle2023/",
    title: "PG BATTLE 2023参加記録",
    date: "2023-10-23T00:00:00Z",
    body: "PG BATTLE 2023参加記録 始まりは突然に 10月9日に、やきとりさん(@yktr_drm06)からPG BATTLEに誘われて、 私、やきとりさん、ryotaさん(@95s7k84695a)のチームで参加することになりました。 このコンテストの存在は知っていたものの、学内に競技プログラミングをしている知り合いが存在しないため、どうしようか迷っていました。(最悪電通大競プロサークルのDiscordで募集かけようかと思っていた。) そんな時にお誘いいただいたので、ぜひ！ということで参加させていただきました。 メンバーが私よりも強い方なので、ラッキーだなとか思っていました(すいません。) PG BATTLEについて 普段はAtCoderのコンテスト及び類似のコンテストしか出ていないので、PG BATTLEのルールはちょっと新鮮でした。 要点は以下の通りです。 3人1チーム ひとりひとり解く問題が違う(配点は1/3ずつ) チーム内相談禁止 提出は一回のみ 総得点及び解答提出時間で勝負 ICPCですら提出は何回かできるので、プログラミングコンテストとしてはかなり珍しい方だなと思います。 問題は、ましゅまろ/せんべい/かつおぶしの三種類あり、誰がどの問題を解くかは事前に決めることができます。 私は二番目に簡単なせんべいを担当しました。 せんべい雑振り返り すべての問題はここで公開されています。 難易度2 積の符号 ちょっと前にTwitterで話題になっていた、注意力を要求するB問題みたいな雰囲気のする問題です。 符号を当てればよいので、全部掛け算する必要はなく、0があるかどうかで場合分けをすればよいです。 0がなければ、-の要素が偶数個か奇数個かでACできます。 import std; void main () { int N = readln.chomp.to!int; int[] A = readln.split.to!(int[]); int minus = false; A.sort; foreach (i; 0..N) { if (A[i] == 0) { writeln(0); return; } if (A[i] \u0026lt; 0) minus++; } if (minus % 2 == 0) { writeln(\u0026#34;+\u0026#34;); } else { writeln(\u0026#34;-\u0026#34;); } } 難易度3 ABCの個数 期待値を求める系の問題は大体よくわかってないので、 苦手問題来たーって思って身構えました。 ググって何とかならないかなーと思って、 「期待値の線形性」というキーワードで出てきたこのサイトを見ていたら、 応用例2がまさにこの問題でした。ラッキー！ どうやら各部分で\u0026quot;ABC\u0026quot;が作れる確率を足し合わせればよいようです。 期待値の線形性ってこうやって使うんだなぁと勉強になったような気がします。 ただ、数学的理解が怪しいのでうーんという感じです。 import std; void main () { string S = readln.chomp; solve(S); } void solve (string S) { /* 期待値の線形性を使う */ /* 場所iをスタートにしてABCができる確率X_iとすると、解はE[Σ(X_i)] */ double ans = 0; foreach (i; 0..S.length) { if (S.length \u0026lt;= i+2) continue; if ((S[i] != \u0026#39;?\u0026#39; \u0026amp;\u0026amp; S[i] != \u0026#39;A\u0026#39;) || (S[i+1] != \u0026#39;?\u0026#39; \u0026amp;\u0026amp; S[i+1] != \u0026#39;B\u0026#39;) || (S[i+2] != \u0026#39;?\u0026#39; \u0026amp;\u0026amp; S[i+2] != \u0026#39;C\u0026#39;)) continue; /* 確率0 */ int UnComfirmed = 0; for (int j = 0; j \u0026lt; 3; j++) if (S[i+j] == \u0026#39;?\u0026#39;) UnComfirmed++; ans += 1./(3^^UnComfirmed); } writefln(\u0026#34;%.10f\u0026#34;, ans); } 難易度4 距離K これは割とすぐ解法が見えました。 まずは数列を次のようにK個のグループに分けます。 $$\\mathrm{group}[i] \\coloneqq \\{ A[x] \\mid \\forall j, ~ x = i+jK \\}$$ 実は、操作によって入れ替わることができるのは同一グループに属する要素だけです。 簡単のため、ある一つのグループ以外を固定して考えます。 この時、数列Aは操作できるグループの「同じものを含む順列」通り数になります。 同様の議論をすべてのグループに適用することで、数列Aの変化先の総数は、 すべてのグループについての「同じものを含む順列」の総積であることが分かります。 式におこしましょう。$\\mathrm{group}[i]$が要素$x[j]$を$y[j]$個持つとすると、求める値は $$ \\prod_{i} \\frac{\\left( \\sum_{j} y[j] \\right)!}{\\prod_j (y[j]!)} $$ となります。$\\sum_{j}y[j] \\leq N$なので、 Nまでの階乗及びその逆元をを空間/時間$O(N)$で先に求めておけば、上の式を高速に求めることができます。 import std; void main () { int N, K; readln.read(N, K); int[] A = readln.split.to!(int[]); solve(N, K, A); } void solve (int N, int K, int[] A) { const long MOD = 998244353; /* 階乗前計算 */ long[] fact = new long[](N+1); long[] factInv = new long[](N+1); fact[0] = factInv[0] = 1; for (int i = 1; i \u0026lt;= N; i++) { fact[i] = i*fact[i-1] % MOD; factInv[i] = modInv(fact[i], MOD); } int[][] ModuloKGroups = new int[][](K, 0); foreach (i; 0..K) { if (N \u0026lt;= i) continue; int pos = i; while (pos \u0026lt; N) { ModuloKGroups[i] ~= A[pos]; pos += K; } } /* 最後にprodの総積をとる */ long[] prod = new long[](K); int[int] count; foreach (i; 0..K) { int ElemSize = cast(int) ModuloKGroups[i].length; foreach (m; ModuloKGroups[i]) count[m]++; prod[i] = fact[ElemSize]; foreach (key, val; count) { prod[i] *= factInv[val]; prod[i] %= MOD; } count.clear; } long ans = 1; foreach (i; 0..K) { ans *= prod[i]; ans %= MOD; } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } long modPow (long a, long x, const int MOD) { // assertion assert(0 \u0026lt;= x); assert(1 \u0026lt;= MOD); // normalize a %= MOD; a += MOD; a %= MOD; // simple case if (MOD == 1) { return 0L; } if (x == 0) { return 1L; } if (x == 1) { return a; } // calculate long res = 1L; long base = a % MOD; while (x != 0) { if ((x\u0026amp;1) != 0) { res *= base; res %= MOD; } base = base*base; base %= MOD; x \u0026gt;\u0026gt;= 1; } return res; } long modInv (long x, const int MOD) { import std.exception; enforce(1 \u0026lt;= MOD, format(\u0026#34;Line : %s, MOD must be greater than 1. Your input = %s\u0026#34;, __LINE__, MOD)); return modPow(x, MOD-2, MOD); } 難易度6 トリオ なんもわからん！こんなの無理だろ！と文句を言っていたらコンテストが終わりました。。。 chokudaiさんが解説を上げていたので見ましたが、これは本番解けるわけないな\u0026hellip;となりました。 しかし、一応状態$O(3^N)$までは見えていたので、悪くはないかな？ 終わりに チーム戦も面白いですね。 またこういうコンテストに出たいなぁと思いました。 チーム合計240点で割とよさげなので、なんか商品もらえるといいなぁ やきとりさん、ryotaさん、お誘いいただきありがとうございました。"
  },
  {
    url: "/post/functional-graph-cycle/",
    title: "Functional Graphのサイクル検出をいい感じに",
    date: "2023-10-13T00:00:00Z",
    body: "Functional Graphのサイクル検出をいい感じに はじめに グラフ表現に帰着できる問題を考察していると、Functional Graphと呼ばれるグラフのサイクル検出に帰着する場合があります。 本稿では、Functional Graphのサイクル検出の比較的簡単な実装を紹介します。 前提条件 本稿における、Functional Graphの定義は次のとおりです。 有向グラフであって、各頂点の出次数がちょうど1であるもの。 方法 まず、画像でイメージを掴んでもらいます。 これがFunctional Graphです。各頂点から一つだけ有向辺があるのが確認できると思います。 ここで、頂点{1, 2, 3, 4, 5}は閉路をなしていますが、それ以外は閉路に含まれていません。 これをどうやって検出するかが本題です。 UnionFind(dsu)を使います。 まず、Functional Graphの重要な性質に、連結成分がちょうど一つの閉路を持つというものがあります。 証明(厳密でない) 連結成分が少なくとも一つの閉路を持つこと 頂点1つから考えて、まだ連結成分でない頂点へ有向辺を張ると、必ず連結成分のサイズが1増えます。 つまり、サイズkの連結成分を成す最小の有向辺はk-1本です。 一方、Functional Graphにおけるサイズkの連結成分は必ずk本の有向辺を持ちます。 これは、少なくとも1本はすでに連結である頂点へと有向辺を張っていることになり、閉路を含みます。 高々1つの閉路を持つこと あるFunctional Graphの連結成分が2つの閉路を持つと仮定します。 閉路が頂点を共有するとき 少なくとも2つの頂点が出次数2になり、違反します。 閉路が頂点を共有しないとき 閉路同士を結ぶ辺が必要ですが、このときに少なくとも1つの頂点が出次数2になり、違反します。 3以上も同様に証明できます(ほんとか？)。よって、閉路は高々1つです。 証明終わり。 UnionFindで連結成分を増やしていくと、どこかですでに同じ連結成分に属する頂点が見つかるはずです。 このとき見つかる頂点は、必ず閉路の中に入っている頂点になります。 Functional Graphにおける連結成分はちょうど一つだけ閉路を持ち、 出次数が必ず1であるため、閉路を構成する1頂点が見つかれば、 閉路に入っている他の全ての頂点もたどっていくだけで全て見つけることができます。 よって、以下のアルゴリズムを得ます。 以下、G[i]は頂点iに隣接する頂点を指す。 i=0,1,\u0026hellip;,Nに対して、次を行う。 頂点iと頂点G[i]が同じ連結成分に属していなければ、頂点iと頂点G[i]をマージして終了。同じ連結成分に属していれば、2に進む。 pos=iとして、再びpos=iとなるまでpos=G[pos]として更新する。 その途中でposに代入された頂点は、全て記録しておく。 記録された頂点は、一つの連結成分の閉路をなす頂点集合と一致する。 時間計算量はO(Nα(N))です。(α(N))はアッカーマン逆関数) また、本稿では詳しく紹介しませんが、強連結成分分解によって時間と空間O(N)を達成することもできます。 しかし、実装のコストは(強連結成分分解ライブラリがなければ)こちらのほうが軽いです。 どちらもおすすめです。 実装例 D言語による実装例を示します。 auto UF = UnionFind!int(); bool[int] NumberInCycle; foreach (i; 0..N) { if (!UF.is_same_group(i, A[i])) { UF.merge_group(i, A[i]); continue; } // 閉路検出 int cur = i; do { NumberInCycle[cur] = true; cur = A[cur]; } while (cur != i); } このコードを実行したあとにNumberInCycleに存在する要素は、Functional Graphのいずれかの連結成分における閉路を構成する頂点である。 練習問題 練習問題を3問用意しました。ぜひ解いてみてください。 1問はまさにこのアルゴリズムを用いる問題ですが、他の2問は考察部分があり、Functional Graphに帰着するのは自明ではないです。 なので、ネタバレが嫌だという方は1問目だけ解くと良いです。 ABC311C 解法 状況設定はほとんど同じです。 紹介したアルゴリズムを用いるだけで解くことができます。 なお、この問題に関しては列を求める必要があるため、強連結成分分解よりもUnionFindの方が直接的に求められます。 ABC296E 解法 このゲームにおけるK_i回の操作は、Functional Graphにおける辺を移動していくことだとみなせます。 そこで、もしこのグラフのある閉路に頂点iが含まれる場合、ゲームiにおいて任意のK_iに対して勝てる初期配置が存在します。 逆に、そうでないとき、十分に大きなK_iを指定するだけで必ず青木くんが勝てます。(例えば、K_i=10^9を考えてみてください。) すなわち、この問題はFunctional Graphの閉路に含まれる頂点の種類数を数える問題に帰着します。 ABC256E 解法 人iから人X_iに有向辺を張ったグラフを考えます。すると、これはFunctional Graphになります。 うまく順列を選ぶことで、必ず一つの連結成分あたり一人以外の不満度を0にすることができます。 連結成分は閉路をなしますから、全員を不満度0にはできません。 そこで、連結成分の誰を不満にするかを選ぶ問題に帰着します。 これは明らかに最小の不満度を取る貪欲法が有効です。 よって、Functional Graphの閉路に含まれる頂点を列挙する問題に帰着されました。 終わりに 本アイディアはABC256Eのnyaanさんの公式解説で紹介されていたものです。"
  },
  {
    url: "/post/yuki407/",
    title: "yukicoder contest407参加記録",
    date: "2023-10-06T00:00:00Z",
    body: "yukicoder contest407参加記録 はじめに 本稿は2023-10-06に行われたyukicoder contest 407の参加記録です。 戦績 雑振り返り A - napsack Problem? 問題へのリンク 重さW以下のナップサックのうち、容量の最大値を見ていくだけです。O(N) この人は単にデカいナップサックが欲しいだけみたいですね。 import std; void main () { int N, W; readln.read(N, W); int[] v = new int[](N); int[] w = new int[](N); foreach (i; 0..N) { readln.read(v[i], w[i]); } int ans = -1; foreach (i; 0..N) { if (w[i] \u0026lt;= W \u0026amp;\u0026amp; ans \u0026lt; v[i]) { ans = v[i]; } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - K-th in L2 with L1 問題へのリンク 結構問題文の読解が難しいと感じました。 ユークリッド距離がDであるような点は高々4D個になるので、 全部列挙 すべてに対するユークリッド距離を計算して配列に格納 良い点一つ一つについて、条件を満たすかどうか二分探索 でO(Dlog(D))だと思います。 import std; void main () { int Q = readln.chomp.to!int; foreach (_; 0..Q) { int D, K; readln.read(D, K); solve(D, K); } } void solve (int D, int K) { // マンハッタン距離Dの点集合を列挙 alias coord = Tuple!(int, \u0026#34;y\u0026#34;, int, \u0026#34;x\u0026#34;); bool[coord] DistanceDPoints; for (int i = 0; i \u0026lt;= D; i++) { int y = D-i; int x = i; DistanceDPoints[coord(y, x)] = true; DistanceDPoints[coord(y, -x)] = true; DistanceDPoints[coord(-y, x)] = true; DistanceDPoints[coord(-y, -x)] = true; } int[] dist; foreach (key, val; DistanceDPoints) { dist ~= key.y^^2 + key.x^^2; } dist.sort; // 二分探索 int f (int idx) { if (idx \u0026lt; 0) return -int.max; if (dist.length \u0026lt;= idx) return int.max; return dist[idx]; } foreach (key, val; DistanceDPoints) { int EuclidDist = key.y^^2 + key.x^^2; { int ok = 0, ng = cast(int) dist.length; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid) \u0026lt;= EuclidDist) { ok = mid; } else { ng = mid; } } if (ok+1 \u0026lt; K) continue; } { int ok = -1, ng = cast(int) dist.length; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid) \u0026lt; EuclidDist) { ok = mid; } else { ng = mid; } } if (K \u0026lt;= ok+1) continue; } writeln(\u0026#34;Yes\u0026#34;); writeln(key.x, \u0026#34; \u0026#34;, key.y); return; } writeln(\u0026#34;No\u0026#34;); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } おそらくかなり無駄の多い実装になっています。 こういうの結構苦手より。 C - Sum within Components 問題へのリンク 連結成分を列挙していくだけです。 visited[i]をboolにするのではなく、iを含む連結成分の総和が配列の何番目に入っているか？ という情報を入れておくことで、最後x=1, 2, \u0026hellip;, Nについての問題をO(1)で解けます。 割と明らかな問題な気がします。Bより簡単でした。 import std; void main () { int N, M; readln.read(N, M); int[] A = readln.split.to!(int[]); int[][] graph = new int[][](N, 0); foreach (_; 0..M) { int U, V; readln.read(U, V); U--, V--; graph[U] ~= V; graph[V] ~= U; } solve(N, M, A, graph); } void solve (int N, int M, int[] A, int[][] graph) { // 連結成分を列挙していけばよいですね～ const long MOD = 998244353; int[] visited = new int[](N); DList!int Q; long[] SumOfComponent; int idx = 0; visited[] = -1; foreach (i; 0..N) { if (visited[i] != -1) continue; visited[i] = idx; Q.insertBack(i); SumOfComponent ~= A[i]; SumOfComponent[idx] %= MOD; while (!Q.empty) { auto head = Q.front; Q.removeFront; foreach (to; graph[head]) { if (visited[to] != -1) continue; visited[to] = idx; (SumOfComponent[idx] += A[to]) %= MOD; Q.insertBack(to); } } idx++; } long ans = 1; foreach (x; 0..N) { ans *= SumOfComponent[ visited[x] ]; ans %= MOD; } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Three Sets 問題へのリンク 式いかつ過ぎです。 |S|は必ず非負整数なので、ΣAとかはなるたけでかい方が良いです。 したがって、部分集合といいつつ、要素を削るなら小さいものから削るのが最適なことが分かります。 これで各列から何個整数を持ってくるかを全探索できます。 累積和を用いてO(N3)です。 全く間に合いませんが、これ以上はわかりませんでした。 import std; void main () { // なるたけどれもデカいほうが良い。部分集合といいつつ、削るなら最小要素から削るべき(要素数は負にならないので、できるだけでかい方がお得) // O(N^3)しかわからんけど... int[3] N; int[][3] X; readln.read(N[0], N[1], N[2]); X[0] = readln.split.to!(int[]); X[1] = readln.split.to!(int[]); X[2] = readln.split.to!(int[]); solve(N, X); } void solve (int[3] N, int[][3] X) { // O(N^3) foreach (ref x; X) x.sort!\u0026#34;a\u0026gt;b\u0026#34;; int[][3] sum; foreach (i, ref s; sum) s = new int[](N[i]+1); foreach (idx, ref s; sum) foreach (i, ref ss; s) { if (i == 0) { ss = 0; continue; } ss = s[i-1] + X[idx][i-1]; } long ans = -long.max; for (int i = 0; i \u0026lt;= N[0]; i++) for (int j = 0; j \u0026lt;= N[1]; j++) for (int k = 0; k \u0026lt;= N[2]; k++) { ans = max(ans, sum[0][i]*j + sum[1][j]*k + sum[2][k]*i); } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } E以降 Dが解けていないのであまり見ていません。 終わりに yukicoderいつも難しくて良くて3問か4問までしか解けません。"
  },
  {
    url: "/post/mod-division-tech/",
    title: "割れるし割りたいのに割れない数を割る方法",
    date: "2023-10-05T00:00:00Z",
    body: "割れるし割りたいのに割れない数を割る方法 状況設定 $x, ~ y, ~ z \\in \\mathbb N$ $x\\%y = 0$ $1 \u0026lt; \\mathrm{gcd}(y, z)$ $x$は陽に求められないほど大きく、$y$、$z$は常識的な大きさ 問題 $xy^{-1}$を$z$で割った非負最小剰余を求めよ。 何が厳しいのか $\\mathrm{gcd}(y, z) = 1$が満たされていれば話は終了です。 なぜなら、このような$y$は$\\mathrm{mod} ~ z$上で逆元を持つからです。 普通に拡張ユークリッドの互除法などを用いれば答えられます。 問題はそうでない時です。 この時、$y$は逆元を持ちませんから、先に$\\dfrac{x}{y}$を計算したくなります。 しかし、$x$はデカいので、陽に求めるのは無理です。 さてどうしましょう？ 解答 結論から言います。$\\mathrm{mod} ~ yz$上で考えるとうまくいきます。 もう少し具体的には、次の手順を踏むことで答えることができます。 $x ~ \\mathrm{mod} ~ yz$を求める。 それを$y$で割る。 正当性を追っていきます。 除法定理より、次を満たす整数$q, ~ r$の組がただ一つ存在します。 $x = q(yz) + r$ $0 \\leq r \u0026lt; yz$ ちなみに$r = x ~ \\mathrm{mod} ~ yz$です。 ここで、$x\\%y = 0$を仮定しているので、必ず$r\\%y = 0$となっています。 両辺$y$で割ります。 $$ \\begin{equation} \\frac{x}{y} = qz + \\frac{r}{y} \\end{equation} $$ です。 ここから少し定義に戻って確認します。 $\\dfrac{x}{y} ~ \\mathrm{mod} ~ z$を求めるとは $$ \\begin{equation} \\dfrac{x}{y} = q\u0026rsquo;z + r\u0026rsquo; ~ \\left( 0 \\leq r\u0026rsquo; \u0026lt; z \\right) \\end{equation} $$ なる$r\u0026rsquo;$を求めることです。 ここで、除法定理よりこのような整数の組$(q\u0026rsquo;, r\u0026rsquo;)$はただ一つに定まります。 さて、式(1)を見てみましょう。 $0 \\leq r \u0026lt; yz$でありますから、$0 \\leq \\dfrac{r}{y} \u0026lt; z$であることが分かります。 式(2)と見比べてみましょう。$r\u0026rsquo; = \\dfrac{r}{y}$となっていることが確認できます。 なんということでしょう。求めることができてしまいました。除法定理が強力すぎますね。 応用例 実際にこのテクニックを使える問題を2問紹介します。 ARC111A - Simple Math 2 解法 $10^N = qM + r ~ (0 \\leq r \u003c M)$と表すと、 $\\left\\lfloor \\dfrac{10^N}{M} \\right\\rfloor = \\left\\lfloor \\dfrac{qM + r}{M} \\right\\rfloor = q$ であるから、解は$q\\%M$です。 これをもとに変形していきます。 $$ qM = 10^N - r $$ $$ q = \\frac{10^N-r}{M} $$ ここまで変形すると今回のテクニックに帰着します。 求めたいのは$q ~ \\mathrm{mod} ~ M$ですが、$M$は$\\mathrm{mod} ~ M$上で逆元を持ちません。 また、$10^N-r$も大きすぎて陽に求めるのは無理です。 そこで、$(10^N - r) ~ \\mathrm{mod} ~ M^2$を計算してから最後に$M$で割ってやるとうまくいきます。 実装例(一部抜粋) void solve (long N, int M) { // 10^N = qM + r (0\u0026lt;=r\u0026lt;M) を得たとき、解はq%M // 両辺Mで剰余をとってみると、 (10^N)%M = r%M // 条件より、(10^N)%M = r // 典型テク: mod MK (Mは最後に求めたい剰余、Kは割りたいけど法と互いに素でない数) で考える。 long ans = modPow(10, N, M^^2); ans -= modPow(10, N, M); if (ans \u0026lt; 0) { ans += M^^2; } ans /= M; writeln(ans); } ABC293E - Geometric Progression 解法 解法がたくさんありますが、kyopro_friendsさんのユーザー解説と同じ方法です。 丁寧に式変形を追っていきます。 $S(x) \\coloneqq \\displaystyle\\sum_{i=0}^{x}A^i$と定めます。 $0 \\leq N$を用いて、 $$ \\begin{alignat*}{3} A \\times S(N) \u0026amp;= \u0026amp;\u0026amp;A^1 + A^2 + \\cdots + A^N-1 + A^N + A^{N+1} \\\\ S(N) \u0026amp;= A^0 + \u0026amp;\u0026amp;A^1 + A^2 + \\cdots + A^N-1 + A^N \\\\ \\end{alignat*} $$ が成立します。そこで、 $$ A \\times S(N) - S(N) = A^{N+1} - A^0 $$ となります。$S(N)$でくくると、 $$ (A-1) \\times S(N) = A^{N+1} - 1 $$ です。$A-1 \\neq 0$ならば、両辺を割れて、 $$ S(N) = \\frac{A^{N+1}-1}{A-1} $$ を得ます。 さて、今回求める値は$S(X-1) ~ \\mathrm{mod} ~ M$にほかなりません。$A-1 \\neq 0$のとき、$0 \\leq X-1$なので、上式を適用できます。 $$ S(X-1) = \\frac{A^X-1}{A-1} $$ ここで、$A-1$は$\\mathrm{mod} ~ M$上で逆元を持つとは限りません。今回のテクを使いましょう。 つまり、$\\mathrm{mod} ~ M(A-1)$で考えるとうまくいきます。 注意点として、この値は法としてはかなり大きくなる(それでも十分常識の範囲ですが)ので、 計算途中で64bit整数型を超える可能性が高いです。128bit整数や、多倍長整数を使いましょう。 多倍長整数とはいえ、そこまで桁数は大きくならないので十分高速です。 よくわからない人はpythonを使うとよいです。 また、$A-1 = 0$の時はすべての項が1になるため、簡単に計算できます。 実装例(一部抜粋) void solve (int A, long X, int M) { // 解は (A^x - 1) / (A - 1) // 場合分けが必要なケース if (A == 1) { writeln(X%M); return; } BigInt a = A, x = X, m = M; BigInt ans = std.bigint.powmod(a, x, m*(a-1)) - 1; if (ans \u0026lt; 0) ans += m*(a-1); ans /= A-1; writeln(ans); } 補足 問題2の解法説明で、 「逆元を持つとは限りません」と書きましたが、逆元を持っていてもよいことに注意してください。 正当性の証明のパートを見ればわかるように、法と除数の関係性は正当性を示すのに用いていないためです。 もちろん$\\mathrm{gcd}(M, A-1)$を計算して、逆元を持つ場合はそちらを経由するという方法でも解けます。 また、問題2に関しては、行列累乗による$O(\\log(X))$解法や、平方分割による解法など勉強になる解法がたくさん紹介されています。 余裕のある人はぜひ学んでみてください。(ちなみに私は学べてないです。コーナーで差をつけろ！) 終わりに いつかまとめようと思っていたネタです。 ほんの思い付きで書き始めたつもりが約2時間たっていて現在深夜1時です。 助けてくれ。 このアイディア自体はまさに上で紹介したABC293Eのユーザー解説から得たものです。 かなり行間が広いと感じたので、そこを埋める目的で作りました。 なので、この主張がどこまで一般化できるのかなどは私はわかっていません。 誤りがありましたら指摘していただければありがたいです。"
  },
  {
    url: "/post/floyd-warshall/",
    title: "ワーシャル・フロイド法について調べて、納得したこと",
    date: "2023-10-02T00:00:00Z",
    body: "ワーシャル・フロイド法について調べて、納得したこと はじめに 辺に任意の重みがある$N$頂点有向グラフ(ネットワーク)において、負の長さの閉路が存在しないとき、 全点対の最短経路を$O(N^3)$時間で求めるワーシャル・フロイド法と呼ばれるアルゴリズムが存在する。 本稿では、筆者がワーシャル・フロイド法について調べ、理解したことを記録する。 ワーシャル・フロイド法でできるもの 負閉路が存在しないネットワークにおいて、任意の2頂点間の最短経路を求める。 頂点数を$N$としたとき、空間$O(N^2)$と時間$O(N^3)$を要する。 アルゴリズムの詳細 以降、頂点のインデックスは0を基準とする。 また、頂点iから頂点jへの辺の重みを$w_{i,j}$とする。 $\\mathrm{dist}[i][j]:=$「頂点iから頂点jへの最短経路」とする。 最初、$\\mathrm{dist}[i][j]$を次のように初期化する。 $$ \\mathrm{dist}[i][j] = \\begin{cases} w_{i,j} \u0026amp; \\text{if ~ $i$から$j$への辺が存在,}\\\\ \\infty{} \u0026amp; \\text{if ~ $i$から$j$への辺が存在しない,} \\\\ 0 \u0026amp; \\text{if ~ $i = j$.} \\end{cases} $$ $k = 0, 1, \\cdots{} N-1$に対して、順に次の手順を行う。 全ての$0 \\leq{} i, ~ j \\leq{} N-1$の組に対して、 $$ \\mathrm{dist}[i][j] \\leftarrow{} \\min{}(\\mathrm{dist}[i][j], ~ \\mathrm{dist}[i][k] + \\mathrm{dist}[k][j]) $$ 以上を終えたとき、$\\mathrm{dist}[i][j]$は頂点iから頂点jへの最短経路長が入っている。 アルゴリズムの説明 下準備として、与えられたネットワークの辺が存在しない頂点対には距離無限大の辺が存在するとみなす。 こうすると、N頂点有向完全グラフになる。 そして、到達可能性を距離が有限であるかどうかで判定するとする。 このアルゴリズムは次の部分問題を用いた動的計画法とみなせる。 番号k以下の頂点のみを経由するとき、頂点iから頂点jへの最短経路はいくらか？ この問題が解けるとすると、k=N-1の問題に対する解が求めたい解そのものである。 このアルゴリズムを理解する鍵は、あるkとk+1における問題を考えることであると思う。 適当なkに対して問題を考える。 頂点iから頂点jへの最短経路は次のような構造になっている。 頂点i -\u0026gt; (頂点i, jを除いたk以下の頂点集合の部分集合の順列) -\u0026gt; 頂点j k+1に対して問題を考える。 kに対する問題が解けているという仮定のもとで議論を進める。 このとき、新しく最短経路となりうるのは、途中経路に頂点k+1を含むものに限られる。 (なぜなら、k以下に限った解は上の部分問題で解けているから) つまり、最短経路は次のような構造になっている。 頂点i -\u0026gt; (頂点i, jを除いたk以下の頂点集合の部分集合の順列) -\u0026gt; 頂点k+1 -\u0026gt; (頂点i, jを除いたk以下の頂点集合の部分集合の順列) -\u0026gt; 頂点j ここで、負閉路が存在しないことを仮定しているため、 上の経路が最短になるのは、i-\u0026gt;k+1とk+1-\u0026gt;jの経路が最短になるときである。 なぜなら、そうでない場合は経路を最短のものに変えることで距離を必ず改善できるからである。 さて、i-\u0026gt;k+1とk+1-\u0026gt;jの最短経路は、kに対しての部分問題を解いたときにすでに解けていることに気づくだろうか？ わからない人は、部分問題の設定を見直してみてほしい。 したがって、k+1における問題は $$ \\mathrm{dist}[i][j] = \\min(\\mathrm{dist}[i][j], ~ \\mathrm{dist}[i][k+1] + \\mathrm{dist}[k+1][j]) $$ という遷移で解けることがわかる。 まとめ ここまで分かったことをまとめる。 解きたい問題は、k=N-1のときの部分問題である。 kに対して問題が解けるならば、k+1に対して問題が解ける。 あと必要なのは、一番最初のケースを解けるのか？ということである。 k=-1を考える。 これは、始点と終点以外の頂点を一切経由しないときの最短経路問題であり、この部分問題のベースケースである。 この問題は明らかに頂点iから頂点jへ辺が存在するかどうかを見るだけで解くことができる。 以上より、帰納的に問題が解けることが理解できる。 負閉路が存在するとき 負閉路が存在するとき、そこを通ることができる経路に対する最短経路はいくらでも縮めることができる。 しかし、このときワーシャル・フロイド法は$-\\infty$を返さないことがあり得る。(というか、まず$-\\infty$にはならない) 遷移を見ればわかるとおり、ワーシャル・フロイド法により求まるのは最短「パス」であるからである。 つまり、真の最短経路が閉路を含む(同じ頂点を2回以上通る)ものは正しく結果を求めることができない。 追記(2023-10-05) 以下、アルゴリズムロジックからの情報を追加します。 疲れているときに書いたので、普段以上に内容が怪しいかもしれません。ご注意ください。 負閉路の検出 負閉路が含まれているとき、閉路中の任意の一つの頂点をiとする。すると、iからiへの最短パスは総和が最小となる負閉路をぐるっと一周回ったものが採用される。 負閉路がない時、$\\mathrm{dist}[i][i] = 0$となるはずなので、これを用いて$O(N)$で検出できる。 bool hasNegativeCycle () { for (int i = 0; i \u0026lt; N; i++) { if (dist[i][i] \u0026lt; 0) return true; } return false; } 最短距離の一つを復元 $\\mathrm{prev}[i][j] \\coloneqq$ ($i$から$j$への最短経路で、$j$の一つ前にいた頂点) とすると、空間$O(N^2)$を用いて復元できる。 $\\mathrm{prev}$は$\\mathrm{dist}$と一緒に更新するとよい。 $\\mathrm{prev}$の初期値は次のようになる。 $$ \\mathrm{prev}[i][j] \\coloneqq \\begin{cases} i \u0026amp; \\text{if $(i = j) \\lor (iからjへ辺が存在する)$,} \\\\ -1 \u0026amp; \\text{otherwise.} \\end{cases} $$ -1は異常値として採用しています。 更新は、$\\mathrm{dist}$と一緒に行います。 for (int k = 0; k \u0026lt; N; k++) { for (int i = 0; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; N; j++) { if (dist[i][k] \u0026lt; int.max \u0026amp;\u0026amp; dist[k][j] \u0026lt; int.max \u0026amp;\u0026amp; dist[i][k] + dist[k][j] \u0026lt; dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; prev[i][j] = prev[k][j]; } } } 復元は次のようになります。 int[] restorePath (int start, int end) { if (prev[start][end] == -1) return []; int[] res; int cur = end; while (cur != start) { res ~= cur; cur = prev[start][cur]; } res ~= start; res.reverse; return res; } 実装例 次の問題に回答するD言語によるコードを示す。(本問題はワーシャル・フロイド法を用いなくても解けるが、簡単のため採用した。) 問題 頂点$U$から頂点$V$への最短経路を出力せよ。到達不能である場合、-1を出力せよ。 入力形式 N M U V u_1 v_1 w_1 u_2 v_2 w_2 . . . u_M v_M w_M import std; void main () { /* input N, M */ int N, M; readln.read(N, M); int U, V; readln.read(U, V); U--, V--; // 0-indexed /* difine dist[][] */ int[][] dist = new int[][](N, N); foreach (i; 0..N) foreach (j; 0..N) dist[i][j] = int.max; foreach (i; 0..N) dist[i][i] = 0; /* input all edge */ foreach (_; 0..M) { int u, v, w; readln.read(u, v, w); u--, v--; dist[u][v] = w; } solve(N, M, U, V, dist); } void solve (int N, int M, int U, int V, int[][] dist) { /* Floyd-Warshall Algorithm */ for (int k = 0; k \u0026lt; N; k++) { for (int i = 0; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; N; j++) { if (dist[i][k] \u0026lt; int.max \u0026amp;\u0026amp; dist[k][j] \u0026lt; int.max) { dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } } } /* output */ if (dist[U][V] \u0026lt; int.max) { writeln(dist[U][V]); } else { writeln(-1); } } ジャッジはないし、veryfyもないです。何ならコンパイルすらしてないので間違っているかもしれないですが、参考程度でお願いします。 練習問題 本記事を読んだ方は、ぜひ挑戦してみてほしい。 大抵の場合、全点対最短距離に帰着するまでのパートはかなり明らかなことが多いので、ネタバレはそこまで問題ではないと思う。 ABC208D ABC79D 参考文献 浅野 孝夫. グラフ・ネットワークアルゴリズムの基礎 数理とCプログラム(初版). 近代科学社, 2017. 様々なグラフアルゴリズムを簡潔に紹介しています。グラフ理論による厳密な証明などは比重が小さく、数学系でない人も気軽に内容を浚える本だと思います。 rp523. \u0026ldquo;ワーシャルフロイド法がなぜうまくいくのか、改めて考えてみる\u0026rdquo;. qiita. 2022. https://qiita.com/rp523/items/8fba3882c4a6ea203757, (2023-10-02閲覧). この動的計画法がどのようにして状態を圧縮しているのかを丁寧に説明しています。 吉田 雄真. \u0026ldquo;参考文献の書き方\u0026rdquo;. 新潟大学付属図書館. 2021. https://www.lib.niigata-u.ac.jp/learning_support/doc/20210709-3.pdf, (2023-10-02閲覧). 参考文献リストはこの文献を参考に書きました。"
  },
  {
    url: "/post/abc322/",
    title: "ABC322参加記録",
    date: "2023-09-30T00:00:00Z",
    body: "ABC322参加記録 はじめに 本稿は、2023/09/30に行われたABC322の参加記録です。 戦績 今回の提出状況は次の通りです。 AからDまでの5完でした。パフォーマンス1480で、レーティング変化は1195 =\u0026gt; 1227でした。 所感 遂に水色乗れました。うれしいです。 今回はDEがかなり実装が大変でした。 D問題TLEしてしまって、あきらめそうになりましたが、定数倍高速化をいろいろやってみたら通りました。 E問題はあまり賢くない実装方針をとってしまいかなり大変でしたが、何とか通せてよかったです。 解法 A - First ABC2 問題へのリンク nの定義域が明示されているのは楽でいいですね。 前から力任せ法で見ていけば十分高速です。 スライスがある言語なら、スライスを用いるとちょっと楽かもしれないです。 import std; void main () { int N = readln.chomp.to!int; string S = readln.chomp; solve(N, S); } void solve (int N, string S) { foreach (i; 0..S.length-2) { if (S[i..i+3] == \u0026#34;ABC\u0026#34;) { writeln(i+1); return; } } writeln(-1); } B - Prefix and Suffix 問題へのリンク SがTの接頭辞であるかどうか？とSがTの接尾辞であるか？を判定する方法があればif文で解けます。 N、Mは十分小さい上、制約でSの長さはT以下であることが保証されているので、全部言われたとおりに見ていけばよいです。 実装ではスライスを用いていますが、普通にfor文回しても解けます。 この場合、関数化するとちょっと楽だと思います。 import std; void main () { int N, M; readln.read(N, M); string S = readln.chomp; string T = readln.chomp; solve(N, M, S, T); } void solve (int N, int M, string S, string T) { int ans = 3; if (S.length \u0026lt;= T.length \u0026amp;\u0026amp; T[0..S.length] == S \u0026amp;\u0026amp; T[$-S.length..$] == S) ans = 0; if (S.length \u0026lt;= T.length \u0026amp;\u0026amp; T[0..S.length] == S \u0026amp;\u0026amp; T[$-S.length..$] != S) ans = 1; if (S.length \u0026lt;= T.length \u0026amp;\u0026amp; T[0..S.length] != S \u0026amp;\u0026amp; T[$-S.length..$] == S) ans = 2; writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - Festival 問題へのリンク 二分探索を用いてi\u0026lt;=Ajが初めて成立するポイントを探します。 AM=Nなので、境界を多少雑に扱っても解けます。 普段ならAM\u0026lt;iである可能性があるので、判定関数をA[M\u0026lt;x]=infとするのですが、今回は必要ないです。 import std; void main () { int N, M; readln.read(N, M); int[] A = readln.split.to!(int[]); solve(N, M, A); } void solve (int N, int M, int[] A) { bool f (int i, int x) { return i \u0026lt;= A[x]; } for (int i = 1; i \u0026lt;= N; i++) { int ok = M-1, ng = -1; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng)/2; if (f(i, mid)) ok = mid; else ng = mid; } writeln(A[ok]-i); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Polyomino 問題へのリンク 少し大きな台紙を用意して、はみだし、かぶりのないように張り付けて条件を満たすかを見ていく全探索をしました。 3つあるミノのうちの1つは向きを固定してよいため、そこで少し高速化しています。 1300msかかってるの私だけっぽいので、もう少しマシな解き方を復習しようかなと思います。 import std; void main () { char[][][] mino = new char[][][](3, 4, 0); foreach (i; 0..3) foreach (j; 0..4) mino[i][j] = readln.chomp.dup; solve(mino); } void solve (char[][][] mino) { char[][] field = new char[][](12, 12); void AllClear () { foreach (ref f; field) f[] = \u0026#39;.\u0026#39;; } bool isOver () { foreach (i, ff; field) foreach (j, f; ff) { if (f == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; (i \u0026lt; 4 || 8 \u0026lt;= i || j \u0026lt; 4 || 8 \u0026lt;= j)) return true; } return false; } bool paste (int idx, int i, int j) { foreach (y; i..i+4) foreach (x; j..j+4) { if (mino[idx][y-i][x-j] == \u0026#39;.\u0026#39;) continue; if (mino[idx][y-i][x-j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; field[y][x] == \u0026#39;#\u0026#39;) return false; if (mino[idx][y-i][x-j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; (y \u0026lt; 4 || 8 \u0026lt;= y || x \u0026lt; 4 || 8 \u0026lt;= x)) return false; if (mino[idx][y-i][x-j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; field[y][x] == \u0026#39;.\u0026#39;) field[y][x] = \u0026#39;#\u0026#39;; } //return !isOver(); return true; } bool check () { int count = 0; foreach (i, ff; field) foreach (j, f; ff) if (f == \u0026#39;#\u0026#39;) count++; return count == 16; } // 始点縦と横 foreach (i1; 0..7) foreach (j1; 0..7) { // 1ピースは向き確定でもよい。 //foreach (_1; 0..4) { mino[0] = mino[0].rotate; foreach (i2; 0..7) foreach (j2; 0..7) foreach (_2; 0..4) { mino[1] = mino[1].rotate; foreach (i3; 0..7) foreach (j3; 0..7) foreach (_3; 0..4) { mino[2] = mino[2].rotate; AllClear(); if (paste(0, i1, j1) \u0026amp;\u0026amp; paste(1, i2, j2) \u0026amp;\u0026amp; paste(2, i3, j3) \u0026amp;\u0026amp; check()) { writeln(\u0026#34;Yes\u0026#34;); return; } } } } writeln(\u0026#34;No\u0026#34;); } char[][] rotate (char[][] X) { if (X.length == 0) return []; char[][] res = new char[][](X[0].length, X.length); foreach (i; 0..X.length) foreach (j; 0..X[i].length) res[$-j-1][i] = X[i][j]; return res; } E - Product Development 問題へのリンク こういうのは大抵貪欲は無理だと相場が決まっています。また、とるかとらないかのO(2N)全探索もNが少し大きすぎます。 そこで、パラメータの取りうる値が小さいことに着目します。 一つのパラメーターに対して、P以上になったものはすべて同一視してよいため、本質的に区別すべき状態はパラメーターがP未満のもののみです。 いくつかの開発案を採択したとき、ありうる状態はパラメーター1つあたり0からPまでのP+1通りになり、パラメーターがK個独立に存在するので、(P+1)K通りになります。 これを持ちながら多次元部分和問題のようなことをやります。 私は全ケースK=5に帰着させて解きました。具体的には、K\u0026lt;jであってAi,jが存在しない時、Ai,j=Pと定義してあります。 こうすることで、本来存在しない架空のパラメータを一つ以上の開発案をとれば必ず達成できるとみなしています。 こういうdpは、多次元空間をイメージするよりも「ノードの識別子(一意に特定するために必要なタグ)がK種類ある」という理解が良いと思います。 一応この手のdpは過去にたくさん出題例があります。 その一部を紹介します。 ABC219D yukicoder No.2317 import std; void main () { int N, K, P; readln.read(N, K, P); int[] C = new int[](N); int[][] A = new int[][](N, 0); foreach (i; 0..N) { int[] input = readln.split.to!(int[]); C[i] = input[0]; A[i] = input[1..$]; } solve(N, K, P, C, A); } void solve (int N, int K, int P, int[] C, int[][] A) { long[][][][][][] dp = new long[][][][][][](N+1, P+1, P+1, P+1, P+1, P+1); // dp[i][j][k][l][m] := (i, j, k, l, m)を達成できる最小コスト(ただし、パラメータ=5は達成できている) foreach (dim; 0..N+1) foreach (i; 0..P+1) foreach (j; 0..P+1) foreach (k; 0..P+1) foreach (l; 0..P+1) dp[dim][i][j][k][l][] = long.max; dp[0][0][0][0][0][0] = 0; int f (int[] a, int idx) { if (idx \u0026lt; a.length) return a[idx]; return P; } foreach (dim, a; A) foreach (i; 0..P+1) foreach (j; 0..P+1) foreach (k; 0..P+1) foreach (l; 0..P+1) foreach (m; 0..P+1) { if (dp[dim][i][j][k][l][m] == long.max) continue; // とる dp[dim+1][min(f(a, 0) + i, P)][min(f(a, 1) + j, P)][min(f(a, 2) + k, P)][min(f(a, 3) + l, P)][min(f(a, 4) + m, P)] = min(dp[dim][i][j][k][l][m] + C[dim], dp[dim+1][min(f(a, 0) + i, P)][min(f(a, 1) + j, P)][min(f(a, 2) + k, P)][min(f(a, 3) + l, P)][min(f(a, 4) + m, P)]); // とらない dp[dim+1][i][j][k][l][m] = min(dp[dim+1][i][j][k][l][m], dp[dim][i][j][k][l][m]); } if (dp[N][P][P][P][P][P] == long.max) { writeln(-1); } else { writeln(dp[N][P][P][P][P][P]); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 急いで解いたので、一部コメントが間違っています。そもそももう少しましな方針があるので、そちらを参考にすべきです。 終わりに 最近レーティングに取り憑かれている実感があったので、とりあえず水色に乗って一区切りつけることができてよかった。 純粋にProblem Solvingを楽しめるように努力したいと思った。プロコンを嫌いにならないためにも。"
  },
  {
    url: "/post/abc270e/",
    title: "ABC270E - Apple Baskets on Circle",
    date: "2023-09-26T00:00:00Z",
    body: "ABC270E - Apple Baskets on Circle 問題概要 問題へのリンク 円環状に並べてある$1$から$N$の番号が付いた$N$個のかごがある。 かごは$1$から$N$まで順番に並んでおり、かご$N$の隣にはかご$1$がある。 かご$i$にはりんごが$A_i$個入っている。 高橋君は、以下の行動を繰り返す。 目の前にあるかごの中にりんごがあれば$1$個かごから取り出して食べる。その後、りんごを食べたかどうかにかかわらず、右隣のかごの前に移動する。 高橋君がちょうど$K$個のりんごを食べた時点で、各かごに入っているりんごの数を求めよ。 制約 $1 \\leq{} N \\leq{} 10^5$ $0 \\leq{} A_i \\leq{} 10^{12}$ $1 \\leq{} K \\leq{} 10^{12}$ $K \\leq{} \\sum A_i$ 解法 $K$の値が非常に大きいため、高橋君の動きをシミュレートすることはできない。 そこで、高橋君の動きを少しずつまとめよう。 例えば、ある時点において$0$個を除いたりんごの最小値が$x$個であって、かつ$1$個以上のりんごが入ったかごが$y$個であったとする。 この時、少なくとも$x$周している間は$y$は一定になるはずであるから、素直にシミュレートすると$x$周必要なところを$1$周にまとめることができる。 $x$周しても$A_i$における大小関係は逆転しない($A_i \u0026lt; A_j$が$A_i = A_j$になることはあるが、$A_i \u0026lt; A_j$が$A_j \u0026lt; A_i$となることはない)ので、次の最小値$x$を容易に計算することができる。 また、$x$周している間に$K$個を超えてしまうときは、$K$個を超えないで何周できるかを計算するとよい。 具体的には、今まで食べたりんごを$\\mathrm{sum}$として、$\\lfloor{} (K-\\mathrm{sum})/y \\rfloor{}$とすればよい。 最後の一周は高々$N$回の操作で終わるので、シミュレートすればよいだろう。 そこで、次の解法を得る。 解法1 詳しいアルゴリズムは言語による説明よりもソースを見る方が早いかと思うので、D言語による実装を掲載する。 Remainingはその時点で$0$個以上のりんごが入っているかごの数である。 また、現時点で最小のりんごの数を得るために優先度付きキューを利用している。 これは上で説明した大小関係が保存されることを利用している。 void solve (int N, long K, long[] A) { long sum = 0; long Remaining = 0; foreach (a; A) if (0 \u0026lt; a) Remaining++; BinaryHeap!(pair[], \u0026#34;b.val \u0026lt; a.val\u0026#34;) PQ = []; foreach (i, a; A) PQ.insert(pair(cast(int) i, a)); while (sum \u0026lt; K) { auto head = PQ.front; PQ.removeFront; with (head) { if (A[idx] == 0) continue; if (K \u0026lt;= sum + Remaining) { // 一周とれば終了 int i = 0; while (sum \u0026lt; K) { if (0 \u0026lt; A[i]) sum++, A[i]--; i++; } break; } if (sum + Remaining \u0026lt; K) { // A[idx]が最小なので、これを上限にして、できるだけとる long take = min(A[idx], (K-sum)/Remaining); sum += Remaining*take; foreach (ref a; A) if (0 \u0026lt; a) { a -= take; if (a == 0) Remaining--; } } } } // output foreach (i; 0..A.length) write(A[i], (i == A.length-1 ? \u0026#34;\\n\u0026#34; : \u0026#34; \u0026#34;)); } この解法は確かに正しい解を得るが、実は$\\text{worst} ~ O(N^2)$となっている。(筆者はこれに気づかずに2TLEした。) 例えば$A_i = i$であって、$K = \\sum A_i$であるときがこのケースに当たる。 更新が$N$行われて、かつ更新一回で$O(N)$回の操作が必要であるからだ。 素直にシミュレートするよりはかなり高速化したが、これでは間に合わない。 解法2 さて、少し突飛な発想であるかもしれないが、$x$周したときに何個りんごをとれるかを考えよう。 $x$個に満たないかごからは$A_i$個までしかとれないので、$\\sum \\min{} (x, A_i)$個ということになる。 この値は$x$に対して(適切な区間で)狭義単調増加する。 すると、この値が$K$を超えるかどうかで二分探索ができることが分かる。 要するに、何周までなら$K$を超えないのかを高速に求めることができる。 最後の一周は素直にシミュレートすればよいので、これで解ける。 時間計算量は$O(N \\log{} (\\max{} A_i))$である。 以下にD言語による実装例を載せる。 void solve2 (int N, long K, long[] A) { // A[i]からとれるならX個とるとするとき、その総和がKを超えるかどうかで二分探索 // 二分探索: f(x) := sum( min(x, A[i]) ) に対して、f(ok) \u0026lt;= K \u0026lt; f(ng) // ok \u0026lt;- [0, max(A)] long f (long x) { long sum = 0; foreach (a; A) sum += min(x, a); return sum \u0026lt;= K; } long ok = 0, ng = 10L^^12+1; while (1 \u0026lt; abs(ok-ng)) { long mid = (ok+ng)/2; if (f(mid)) { ok = mid; } else { ng = mid; } } long sum = 0; // 少なくとも(とれるなら)ok個とってよい。 foreach (ref a; A) sum += min(a, ok), a -= min(a, ok); // 端数を一周して合わせる { int i = 0; while (sum \u0026lt; K) { if (0 \u0026lt; A[i]) sum++, A[i]--; i++; } } // output foreach (i; 0..A.length) write(A[i], (i == A.length-1 ? \u0026#34;\\n\u0026#34; : \u0026#34; \u0026#34;)); } 振り返り 解法2は解法1をさらにまとめた形だということもできるだろう。 筆者がこの解法に至るまでに次のような手順を踏んだ。 (解法1がTLEして)$A$がばらばらの値の時にまずいのか\u0026hellip; なんか何回も同じ要素を引き算してんな\u0026hellip;どうにかならんかな\u0026hellip; $0$個になったかごは無視してもいいから\u0026hellip;(天啓が下りてきて)可能なら$x$個とる方針で行けば二分探索できそう？ \u0026hellip;うまく言語化できない。というよりは、どうやって思いついたのか詳細にはわからないというのが正しいのか\u0026hellip; ただ、やはり最後の一周とそれまでを区別して考えるのは大事なポイントだと思う。 もし各かごにりんごが無限に入っていたとしたらこのように「何周するのか」に着目する解法を容易に構成できると思う。 が、今回は、りんごの減少に伴って変化が生じるので発想の難易度が上がっていると思った。 より易しい問題設定を考えたり、過去に解いた問題の記憶をためることが重要なのかなと思う。 (2023-09-28追記) 深夜に考えていたら少し思いついたので補足します。 この手の問題は「解の構造」を考えることが大事だと思います。 K個目のりんごを食べるときにかごのりんごがどのように減っているかを考えると、 0になるまで減る、または今まで周回した分だけ減るということが分かります。 すると、何周したかに着目できるのかなと思いました。 何周したかに着目できれば二分探索に帰着するのはそんなに難しくないと思います。 しかし、この手の問題は大抵シミュレーションの高速化で解けることが多いので、解法1を組み切る力も必要かなと思います。 (もちろん、シミュレーションの最悪計算量を一発で見抜く力も) 類似問題 ABC216E"
  },
  {
    url: "/post/abc202d/",
    title: "ABC202D - aab aba baa",
    date: "2023-09-24T00:00:00Z",
    body: "ABC202D - aab aba baa 問題概要 問題へのリンク A個のaとB個のbからなる文字列であって、辞書順でK番目のものを求めよ。 制約 1 \u0026lt;= A, B \u0026lt;= 30 辞書順でK番目の文字列が存在する。 解法 まず、問題文の条件を満たす文字列は$\\displaystyle\\frac{(A+B)!}{A!B!}$通り存在する。 これは、単にA+B個を並べたものからAの重複とBの重複を除いたものである。 また、これは二項係数$\\displaystyle\\binom{A+B}{A} = \\binom{A+B}{B}$でもあり、 A+B個の枠のうち、AかBを入れる場所を決めれば文字列が一つ定まると解釈することもできる。 制約下で最も種類数が多くなるのはA=B=30のときで、これは$\\displaystyle\\frac{60!}{30!30!} = \\binom{60}{30} = 118264581564861424$通りである。 したがって、文字列をすべて列挙して解くことはできない。 そこで、先頭からどの文字を使うかを決めていくことを考える。 ちなみにこれは辞書順を考えるときの典型テクニックらしいので、ある程度パターンマッチングとして選択肢に入れておくようにすると良いかもしれない。 先頭にaを入れた時を考える。 このとき、残るA-1個のaとB個のbで作ることができる文字列の種類は$\\displaystyle\\binom{A+B-1}{A-1}$通りになる。 もしKがこの値よりも大きければ、先頭にaを入れた時点でK番目に到達できないことが確定する。 つまり、先頭の1文字目は次の条件分岐で決定できる。 $K \\leq{} \\displaystyle\\binom{A+B-1}{A-1}$であるとき、a そうでないとき、b 続けて次の文字を決定したいが、その前にやることがある。 上記の条件分岐でbを先頭に入れた場合、aが先頭であったときにあり得た$\\displaystyle\\binom{A+B-1}{A-1}$通りは 必ず自分よりも辞書順で若いはずである。 つまり、現時点で少なくとも$\\displaystyle\\binom{A+B-1}{A-1}$通り分のパディングを持っていることになる。 これを記録しておく必要がある。 さて、2文字目を決定しよう。 実は2文字目もほとんど同様に決めることができる。 1文字目との変化は 1文字目にとった文字の分減らして考えないといけない パディングを忘れないようにする という点だけである。 つまり、2文字目は次の条件分岐で決定できる。 $$ now = \\begin{cases} \\displaystyle\\binom{A+B-1}{A-1} \u0026amp; \\text{if 先頭がbである。} \\\\ 0 \u0026amp; \\text{if 先頭がaである。} \\end{cases} $$ として、先頭の文字に合わせて$A \\leftarrow{} A-1$または$B \\leftarrow{} B-1$とする。 $K \\leq{} now + \\displaystyle\\binom{A+B-1}{A-1}$であるとき、a そうでないとき、b とできる。 これを繰り返すことで文字列を決定できる。 注意として、aかbどちらかを使い切ってしまえば文字列が確定するので、最後まで手順を繰り返す必要はない。 時間計算量は、二項係数1回求める時間を$O(x)$と置くと、$O(x\\cdot{}\\mathrm{max}(A, B))$である。(多分) 提出 import std; void main () { int A, B; long K; readln.read(A, B, K); solve(A, B, K); } void solve (int A, int B, long K) { // 先頭からaとbどっちにするか決めていく。 // n_i個のアルファベットA_i(1\u0026lt;=i\u0026lt;=n)で構成される文字列の種類は多項係数の数だけ存在するので、頭の一つを決めれば後ろに何個存在するかがわかる。 long now = 0; char[] ans; ans.reserve(A+B); while (0 \u0026lt; A \u0026amp;\u0026amp; 0 \u0026lt; B) { if (now + nCk(A+B-1, A-1) \u0026lt; K) { now += nCk(A+B-1, A-1); ans ~= \u0026#39;b\u0026#39;; B--; } else { ans ~= \u0026#39;a\u0026#39;; A--; } } foreach (_; 0..A) ans ~= \u0026#39;a\u0026#39;; foreach (_; 0..B) ans ~= \u0026#39;b\u0026#39;; writeln(ans); } long nCk (int n, int k) { assert(0 \u0026lt;= n \u0026amp;\u0026amp; 0 \u0026lt;= k); if (n \u0026lt; k) return 0L; long res = 1; for (int i = 1; i \u0026lt;= k; i++) { res *= n-i+1; res /= i; } return res; } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 発展 3種類以上の文字を含む場合にも同様の手順で辞書順K番目の文字列を求めることができる。 $m$種類の文字に対して、文字$c_i$が$N_i$個含まれる文字列の種類数は多項係数 $$ \\binom{\\sum{}N_i}{N_1, N_2, \\dots{}, N_m} = \\frac{(\\sum{}N_i)!}{\\prod{}N_i!} $$ により求めることができるから、これを用いて上のアルゴリズムを適用すれば良い。 しかし、現実的には多項係数が非常に大きくなるので問題には出にくいと思う。"
  },
  {
    url: "/post/abc321/",
    title: "ABC321参加してきた。",
    date: "2023-09-23T00:00:00Z",
    body: "ABC321参加してきた。 久しぶりに参加記録を書きます。 ここ1か月くらい参加記録をずっとさぼっていましたが、hugoに移行したことでだいぶん楽になったので今週はちゃんと書きます。 本稿はABC321の参加記録です。 戦績 今回の提出は以下の通りでした。 今回AからEの5問解くことができました。 所感 今回はD問題まではさっと解法が見えました。 C問題は以前にABCの過去問で広義単調増加列の全探索をしたことがあったので、パッと見た瞬間に全列挙可能だと分かりました。 E問題はエーッ！やりたくないです！みたいな見た目をしていたが、こういう時に後ろの問題を見に行っていいことがあったためしがないので頑張って取り組みました。 雑振り返り A - 321-like Checker 問題文 書いてある通りにチェックしたらOKです。こういう時は文字列として受け取ると楽です。 import std; void main () { string N = readln.chomp; foreach (i; 0..N.length-1) { if (N[i] \u0026lt;= N[i+1]) { writeln(\u0026#34;No\u0026#34;); return; } } writeln(\u0026#34;Yes\u0026#34;); } B - Cutoff 問題文 制約がデカければ面倒くさそうですが、実は簡単な全探索が通ります。 Nラウンド目に0から100点のどれかしか取れないので、最終結果としてあり得るものは高々100通りです。 よって、これらすべてについて問題文の通りにチェックを入れると解けます。 「全部見る」ということで複雑さを全部破壊するのは気持ちよいですね。 import std; void main () { int N, X; readln.read(N, X); int[] A = readln.split.to!(int[]); int[] B; int ans = int.max; for (int i = 0; i \u0026lt;= 100; i++) { B = A.dup; B ~= i; B.sort; int score = 0; for (int j = 1; j \u0026lt; B.length-1; j++) { score += B[j]; } if (X \u0026lt;= score) { ans = min(ans, i); } } if (ans == int.max) { writeln(-1); } else { writeln(ans); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - 321-like Searcher 問題文 実は以前もう少し緩い制約で定義される数を探索する問題を解いたことがあって、その時の記憶が残っていたので即座に全探索の判断をとりました。 上の桁から決めていくような感じでdfsで掘りました。 重複とか怖かったので一応対策しています。 1WAでペナってしまったので、おそらくオーバーフローかな？ import std; void main () { int K = readln.chomp.to!int; solve(K); } void solve (int K) { // 狭義単調減少列は少なかったような気がするので全列挙します。 long[] number; void dfs (long current, int last) { for (int i = 0; i \u0026lt; last; i++) { dfs(10*current+i, i); } if (0 \u0026lt; current) number ~= current; } dfs(0, 10); number = number.sort.uniq.array; writeln(number[K-1]); } D - Set Menu 問題文 こういうのは大抵片方を固定するとよいと相場が決まっています。 実際、この問題においてA[i]を一つ固定すると、必ず和がPを超えるかどうかで境界線を引くことができます。 これを二分探索します。 いちいちBの総和をとっているとO(M^2)が乗ってくるので、累積和で1ケースO(1)に落とします。 import std; void main () { int N, M, P; readln.read(N, M, P); int[] A = readln.split.to!(int[]); int[] B = readln.split.to!(int[]); solve(N, M, P, A, B); } void solve (int N, int M, int P, int[] A, int[] B) { // Aを一つ決めたときに境界線を探す。 long ans = 0; B.sort; long[] cum; cum.reserve(M+1); cum ~= 0; foreach (b; B) { cum ~= cum[$-1]+b; } long f (int idx) { if (idx \u0026lt; 0) return cast(long) -int.max; if (M \u0026lt;= idx) return cast(long) int.max; return B[idx]; } foreach (a; A) { // 二分探索: a+f(ok) \u0026lt;= P, P \u0026lt; a+f(ng) // ただし、f(x\u0026lt;0)=-inf, f(M\u0026lt;=x)=inf int ok = -1, ng = M; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (a+f(mid) \u0026lt;= P) { ok = mid; } else { ng = mid; } } if (ok == -1) { ans += 1L*P*M; } else { ans += 1L*(ok+1)*a+cum[ok+1]; ans += 1L*P*(M-ok-1); } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 一発で通せて本当に良かった。 E - Complete Binary Tree 問題文 制約は載せていませんが、Tが105で、そのほか1018です。 まず、この木がどうなっているのかを図に書いてチェックします。 すると、これは完全二分木になっていることが確かめられます。 さて、制約がクソでかなので、グラフ上で実際にチェックしてやるのは無理です。 完全二分木の何かしらの性質を使います。 しばらく悩んで、例えばX=1で固定だったらどうだろうという発想に至りました。 この時、割と簡単に解けそうだなという感じです。具体的には、最左のノードと最右のノードの番号を持っておいて、(left, rightとします。) left = 2*left; right = 2*right+1; を深さ分だけ続けていけばよさそうです。 途中でN \u0026lt; leftなら解は0で、そうでなければmin(N, right)-left+1になりそうな感じです。 式で書くと分かりにくいですが、実際はずっと15要素の二分木とにらめっこしていました。 というわけで、自分を根とする部分木に対してなら問題が解けました。 頂点1以外は必ず親を持つので、この部分木に対する問題を解くサブルーチンを適切に親ノードを選んで実行する感じで解きました。 import std; void main () { int T = readln.chomp.to!int; foreach (_; 0..T) { long N, X, K; readln.read(N, X, K); long ans = solve(N, X, K); writeln(ans); } } long solve (long N, long X, long K) { // 自分を根とする部分木の数え上げはできそう /* return: 自分を根とする部分木において、自分との距離がdistであるようなものの数を数え上げる。多分logくらい */ long count (long root, long dist) { enforce(0 \u0026lt;= dist); if (N \u0026lt; root) return 0; if (dist == 0) return 1L; long left = root, right = root; while (0 \u0026lt; dist) { left = 2*left; right = 2*right+1; dist--; if (N \u0026lt; left) return 0; } return min(N, right)-left+1; } bool[long] memo; long ans = 0; ans += count(X, K); memo[X] = true; X /= 2; K--; if (K \u0026lt; 0) return ans; while (1 \u0026lt;= X) { if (K == 0) { ans++; break; } memo[X] = true; if ((2*X) !in memo) { ans += count(2*X, K-1); memo[2*X] = true; } if ((2*X+1) !in memo) { ans += count(2*X+1, K-1); memo[2*X+1] = true; } X /= 2; K--; } return ans; } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } これがACをとったコードですが、どのように動くかを具体的に見てみようと思います。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 バックスラッシュが円マークになってしまうのでpreに位置関係を書きました。 一例として、X=6の動作を示します。 以下、countは指定した頂点を根とする部分木に対して答えを返す関数になります。 countにX=6とKを渡します。 X=6をメモっておき、X/=2、K--とします(一つ上の階に上がる) 2Xと2X+1のうち、メモに入っていない方、およびK-1をcountに渡します。また、Xもメモっておきます。 これを1 \u0026lt;= Xである間(根にたどり着くまで)繰り返します。K=0になったりしたときには適切に処理します。 という感じです。これでもれなく探索できます。 計算量はcountが1回につきO(log(N))程度で、Xから1になるまで上に登っていくので、大体クエリ1回あたりO(log^2(N))くらいです。多分。 最初の実装では、countに渡した2Xまたは2X+1のノードが存在しない時にバグっていたようで、なかなか気づかなくて大変でした。 最後何とか気づいてギリギリ通りました。 おそらくもっと良い解法があるので、復習します。 F以降はほぼ見てないです。 感想 Eが解けてよかったー これからもできる範囲で精進頑張ります。"
  },
  {
    url: "/post/hugo-setting/",
    title: "InTheDayDreamをhugoに移行するためにやったことたち",
    date: "2023-09-15T00:00:00Z",
    body: "InTheDayDreamをhugoに移行するためにやったことたち 手動ブログ運営はしんどい！ さて、皆様はhatenablogなどのサービスを全く介さずに、単にインターネット上の置き場所にWebページを展開したことがありますでしょうか？ 私がしばらく運営している当ブログは、github pagesを利用した完全な手動運用のサイトです。 まあこれが辛いんです結構 具体的に何がしんどいのかと言うと、ページ公開に伴う面倒な作業がとにかく多いんですね。 例えば一つ公開したいページがあるとき、色んな所にリンクを貼り付ける必要があります。 また、すべてのCSSや、各ページのヘッダ(htmlの\u0026lt;head\u0026gt;タグの中身)とかも全部用意しなければいけません。 これがやりたいという人はいいですけど、結構面倒くさくて記事更新のモチベーションがゴリゴリ減らされるわけです。 私は現在競技プログラミングに取り組んでいて、新しい知見を得ることが結構ありますが、わざわざ一つの問題に対して記事を建てるなんて面倒くさくてやりたくないわけです。 これはかなりのデメリットです。 私はフロントエンドエンジニアでもなんでもなく、gitの使い方すらガバガバな初心者ですから、大抵の実装はその場しのぎで後からいじるとかはやりたくないわけです。 現在私のブログはもう触りたくないけどなーみたいなゴミがたくさん転がっているひどい現状です。 しかも、折角書いた記事も全然再利用性がないなーと感じています。 私の理想を言うなら、できるだけmarkdownなどでプレーンテキストデータに近い形で記事をおいておきたいわけです。これにスタイルシートとかを当てたり、他のフォーマットに変換するのは割と容易ですし。 というわけで、このあたりの面倒くさい作業をhugoに丸投げしちゃおうと言う感じです。 hugoとは？ The world’s fastest framework for building websites Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. 以下google翻訳 ウェブサイトを構築するための世界最速のフレームワーク Hugo は、最も人気のあるオープンソースの静的サイト ジェネレーターの 1 つです。 Hugo の驚くべきスピードと柔軟性により、Web サイトの構築が再び楽しくなります。 hugo公式サイトより だそうです。すごく簡単に言うと、WordPressなどのようなCMSと違い、設計図のようなものから静的Webサイトを構築するソフトウェアです。 似たようなソフトウェアにjekyllとかがあります。 実は、以前jekyllをワチャワチャしてみようと思ったのですが、その時はよくわからずに諦めてしまったことがあります。 Jekyllなんか知らんけど動かない \u0026mdash; In (@UU9782wsEdANDhp) March 26, 2023 これはjekyllがプログラミング言語rubyとかなり密接につながっていることが原因の一つです。 jekyllはちょっと動かしてみたいなーってだけでなんだか色々インストールだの何だのを要求されます。 私はプログラミングのことなんか全然わかりませんから、普通にキレてやめました。 一方、hugoはあまりややこしいことをしなければgo言語の処理系を用意する必要すらないということで、割と良さそうだなと思って試しています。 もちろんソースからビルドとかしたいなら処理系が必要ですが、各プラットフォーム向けにバイナリが配布されているようなので、それでなんとかします。 let\u0026rsquo;s try! とりあえずバイナリをここからひったくってきます。 Windowsの方などはhugo_extended_0.118.2_windows-amd64.zipっていうやつをパクってきたらいいと思います。(2023/09/15) Linuxなどの方は、ディストリビューションのパッケージとして公開してくれてるやつを引っ張ってきても良いと思います。 私はUbuntu 22.04.3 LTS (64bit)ですので、aptからパクってくることもできます。 sudo apt update sudo apt install hugo ただ、なんか微妙に古かったので、さっきのリンクからパッケージをパクってきて、それをaptに渡しました。 hugo_extended_0.118.2_linux-arm64.debをダウンロード sudo apt install path/to/hugo_extended_0.118.2_linux-arm64.deb インストールできない？俺もわからん hugo version # -\u0026gt; hugo v0.118.2-da7983ac4b94d97d776d7c2405040de97e95c03d+extended linux/amd64 BuildDate=2023-08-31T11:23:51Z VendorInfo=gohugoio だそうです。 使い方は次のリンクをさっと見ていきましょう。ちなみに私は細かい使い方とか難しいことは何も分かっていません。 公式サイト(英語) さくらのナレッジ 私は読んでないけど、なんかドンピシャなやつあった(qiita) こっちは読んだやつ(Zenn) 読んだやつパート2(Zenn) もっとちゃんと知りたい人はちゃんと公式サイトを浚いましょうね。 さて、サイトテーマを決めましょう。hugoは公式サイトで有志が作ったテーマをいっぱい公開してくれています。 ここで物色しましょう。 テーマってなんやねんと思う方もいると思います。 私の浅いイメージ的には、 hugo : ユーザーが特定のディレクトリに配置したファイルからいろんなデータなどを抜き出し、それを操作する統一的なインターフェースとかを提供する。(例えば、配置したmdファイルからテキストを抜き出して、{{content}}みたいな記法で他のファイルに挿入できるようにするとか) hugoテーマ : hugoが提供してくれる機能をいい感じにデコったりしてくれる。 みたいな感じなのかな？ なので、hugo側でデフォルトで提供されているものの、テーマがそれに対応していないこともあります。readmeとかを見てちゃんと決めましょう。リポジトリを見に行けば大抵デモページが用意されています。 私がやったこと さて、本題です。 ここからは、私がこのサイトを構築するためにやったことを色々書きます。 どちらかと言うと自分が忘れたときのためのものなので、大して参考にならんかもしれません。 正直に言うと、このセクションのためにこの記事を書き始めました。 テーマ選択 テーマはsimplogを選択します。 主な選定理由はタグやカテゴリなどの便利機能をサポートしつつ、シンプルで使いやすそうだからです。 さて、今まで構築していたリポジトリをローカルにコピーしておいて、破壊しましょう。 cp -r ./ path/to/archive/ rm * hugo new site . --force # 以下実際のログ Congratulations! Your new Hugo site was created in /home/in/dev/git/myblog. Just a few more steps... 1. Change the current directory to /home/in/dev/git/myblog. 2. Create or install a theme: - Create a new theme with the command \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; - Install a theme from https://themes.gohugo.io/ 3. Edit hugo.toml, setting the \u0026#34;theme\u0026#34; property to the theme name. 4. Create new content with the command \u0026#34;hugo new content \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 5. Start the embedded web server with the command \u0026#34;hugo server --buildDrafts\u0026#34;. See documentation at https://gohugo.io/. 次に、テーマをインストールします。よく分かってないですが、とりあえず書いてあるとおりに進めます。(なんだよsubmoduleって) git submodule add https://github.com/michimani/simplog.git ./themes/simplog # 以下実際のログ Cloning into \u0026#39;/home/in/dev/git/myblog/themes/simplog\u0026#39;... remote: Enumerating objects: 2538, done. remote: Counting objects: 100% (664/664), done. remote: Compressing objects: 100% (262/262), done. remote: Total 2538 (delta 288), reused 625 (delta 280), pack-reused 1874 Receiving objects: 100% (2538/2538), 3.09 MiB | 6.19 MiB/s, done. Resolving deltas: 100% (1201/1201), done. 全体の設定(hugo.toml) さて、驚くべきことに、これで大半の作業は終了です。 後は設定やテーマをいじりましょう。 まず、ルート直下にあるhugo.tomlを設定します。(hugoのバージョンによってはconfig.tomlがデフォだったりする) 私の設定を貼り付けておきますが、このあたりはテーマに依存する項目も多いですから、いろんな情報を見てみると良さそうです。 あと、一応注意喚起ですが、私は雰囲気で設定したので多分いくつかおかしいです。 baseURL = \u0026#39;http://inthebloom.github.io/\u0026#39; languageCode = \u0026#39;ja\u0026#39; DefaultContentLanguage = \u0026#34;ja\u0026#34; title = \u0026#34;InTheDayDream\u0026#34; description = \u0026#34;InTheBloom\u0026#39;s Website\u0026#34; author = \u0026#34;InTheBloom\u0026#34; theme = \u0026#34;simplog\u0026#34; paginate = 10 summarylength = 20 enableInlineShortcodes = true ignoreErrors = [\u0026#34;error-remote-getjson\u0026#34;] googleAnalytics = \u0026#34;\u0026#34; disqusShortname = \u0026#34;\u0026#34; [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true [menu] [[menu.main]] identifier = \u0026#34;home\u0026#34; name = \u0026#34;Home\u0026#34; url = \u0026#34;/\u0026#34; weight = 1 [[menu.main]] identifier = \u0026#34;tags\u0026#34; name = \u0026#34;Tags\u0026#34; url = \u0026#34;/tags/\u0026#34; weight = 2 [[menu.main]] identifier = \u0026#34;categories\u0026#34; name = \u0026#34;Categories\u0026#34; url = \u0026#34;/categories/\u0026#34; weight = 3 [[menu.main]] identifier = \u0026#34;archives\u0026#34; name = \u0026#34;Archives\u0026#34; url = \u0026#34;/archives/\u0026#34; weight = 4 [[menu.main]] identifier = \u0026#34;about\u0026#34; name = \u0026#34;About\u0026#34; url = \u0026#34;/about/\u0026#34; weight = 5 [taxonomies] category = \u0026#34;categories\u0026#34; tag = \u0026#34;tags\u0026#34; archive = \u0026#34;archives\u0026#34; [services] [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true [params] subtitle = \u0026#34;\u0026#34; colorTheme = \u0026#34;default\u0026#34; description = \u0026#34;\u0026#34; twitter = \u0026#34;UU9782wsEdANDhp\u0026#34; customCSS = \u0026#34;/css/custom.css\u0026#34; adobeFontsKitId = \u0026#34;\u0026#34; headerImagePath = \u0026#34;\u0026#34; [params.enabled] comment = true summary = true toc = true ポイントとしては、mdファイル中の生のhtmlを反映するようにunsafe機能を有効にしてあります。また、カスタムcssを有効にしてあります。カスタムcssは/static/以下が検索されてるっぽい？ カスタムcss(static/css/custom.css) cssは気に入らないものをオーバーライドしましょう。 ブラウザの調査機能などを使うと比較的簡単にどれを変えればよいかわかります。 img { width: auto; max-width: 100%; height: auto; border: 1px solid black; } #content h2 { padding-bottom: 0.5em; border-bottom: 1px solid gray; margin-top: 3em; } #main-menu-nav-items { grid-template-columns: repeat(5, 20%); } .block-separater { margin-top: 50px; } #content-footer { margin-top: 70px; } テンプレートのオーバーライド(layouts/) テーマに用意されているテンプレートもいじりましょう。 themes/以下のlayoutsではなく、ルート以下のlayoutsに同様のファイルを用意してあげることで、差異があったら優先的に使ってくれます。 cp -r themes/simplog/layouts/* ./layouts/ KaTeXの設定 これを利用する。 要はCDNからKaTeXを読み込んで、JSでロード時に変換しているっぽい？ 詳しいことはたくさん記事が存在するから各自でやりましょう。 まず諸々の設定を入れ込んだpartialを作成しよう。 touch layouts/partials/math.html 中身はこれ \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { // customised options // • auto-render specific keys, e.g.: delimiters: [ {left: \u0026#39;$$\u0026#39;, right: \u0026#39;$$\u0026#39;, display: true}, {left: \u0026#39;$\u0026#39;, right: \u0026#39;$\u0026#39;, display: false}, // {left: \u0026#39;\\\\(\u0026#39;, right: \u0026#39;\\\\)\u0026#39;, display: false}, // {left: \u0026#39;\\\\[\u0026#39;, right: \u0026#39;\\\\]\u0026#39;, display: true} ], // • rendering keys, e.g.: throwOnError : false }); }); \u0026lt;/script\u0026gt; 各ページで読み込むための設定をしよう。 フロントマター(各記事先頭の設定)や、hugo.tomlで記述したパラメータを参照してオンオフを切り替えるようにした。 layouts/partials/header.htmlあたりにでも埋め込もう。 \u0026lt;!-- KaTeX Settings --\u0026gt; {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34;}} {{ end }} これでページ先頭にmath: trueなどと書けばKaTeXを使ってくれる。 余談ではあるが、markdownとKaTeXを同時に運用するのは相性的にあまり良くない。というのも、markdownパーサーがKaTeX記法と衝突することがあり、この場合htmlのロード後に発動するKaTeXが必ず負ける。 いろんなケースがあるので、問題が発生したらその都度解決策を考える必要があり、かなり面倒くさい。 マジで誰かなんとかしてくれ Table Of Contentsを強調する 記事の先頭にTOC(Table Of Contents)を設置してくれる機能がある。しかし、simplogのデフォルトはあまりにもわかりにくいと感じるので、改造する。 TOCはlayouts/_default/single.htmlをいじれば良さそう。 これが元 \u0026lt;!--TOC--\u0026gt; {{ if eq .Site.Params.Enabled.Toc true }} {{.TableOfContents}} {{ end }} 改造後 \u0026lt;!--TOC--\u0026gt; {{ if and .Site.Params.Enabled.Toc (not (eq .Params.Toc false)) }} \u0026lt;div style=\u0026#34;padding: 0em 1em; margin-bottom: 5em; margin-top: 0.7em;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;font-size: 1.3em;\u0026#34;\u0026gt;Table Of Contents\u0026lt;/p\u0026gt; {{.TableOfContents}} \u0026lt;/div\u0026gt; {{ end }} ついでに各記事内でTOCを制御できるようにした。先頭メタデータでtoc: true/falseで制御できる。 記事タイトルをh1にする 何故か最大の見出しがh2にされていて、自作cssが適用されちゃうのが嫌なのでh1に差し替える。 いじるファイルは同様にlayouts/_default/single.html あと、ついでに公開日のところをいじる。 before \u0026lt;!--Title--\u0026gt; \u0026lt;h2\u0026gt;{{.Title}}\u0026lt;/h2\u0026gt; {{ if or (not .Params.hideDate) (eq .Params.hideDate false) }} \u0026lt;span class=\u0026#34;sub\u0026#34;\u0026gt;{{.Date.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; {{ end }} after \u0026lt;!--Title--\u0026gt; \u0026lt;h1\u0026gt;{{.Title}}\u0026lt;/h1\u0026gt; {{ if or (not .Params.hideDate) (eq .Params.hideDate false) }} \u0026lt;span class=\u0026#34;sub\u0026#34;\u0026gt;Published on {{.Date.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;span class=\u0026#34;sub\u0026#34;\u0026gt;Last Modified {{.Lastmod.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/span\u0026gt; {{ end }} 何気にパラメータlastmodが追加された。 先頭メタデータ内で、lastmod: 2006-01-01みたいな感じで指定してあげると良さそう なお、lastmodが設定されていないときはデフォルトでdateに合わせてくれた。気が利くなぁ ogpの画像の参照先をいじる ogpというのは、SNSなどにリンクを貼ったときにいい感じにプレビュー画像みたいなのを表示してくれるやつです。 デフォルトでは相対パスで検索しているようなので、ここを絶対パスを使うようにしてみます。 layouts/partials/head.htmlをいじります。 before \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ $site.BaseURL }}{{ . }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ $site.BaseURL }}{{ . }}\u0026#34;\u0026gt; after \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ . }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ . }}\u0026#34;\u0026gt; これで、メタデータでogimage: path/to/imageで指定できます。ただし絶対パスが必要になるので、外部のURLを指定すべきです。 ついでにデフォルトのogpimageを設定しておきましょう。{{ $site.BaseURL }}/images/featured_image.jpgという設定になっているようなので、この場所、名前で適当に作って配置します。 \u0026hellip;と思ったが、メタモンが発生してやる気がなくなったのでやめた。 faviconを用意する ブラウザなどでサイト名の横に表示されるちっちゃい画像のことをファビコンと呼ぶ。 これを用意する。 \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;180x180\u0026#34; href=\u0026#34;{{ relURL \u0026#34;images/apple-touch-icon.png\u0026#34; }}?c={{$cacheHashBase}}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; sizes=\u0026#34;32x32\u0026#34; href=\u0026#34;{{ relURL \u0026#34;images/favicon.png\u0026#34; }}?c={{$cacheHashBase}}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; sizes=\u0026#34;16x16\u0026#34; href=\u0026#34;{{ relURL \u0026#34;images/favicon-16x16.png\u0026#34; }}?c={{$cacheHashBase}}\u0026#34;\u0026gt; layouts/partials/head.htmlにこのような記述があった。この名前とサイズで用意しよう。 なんかよくわからないが/static/images/*.pngに用意したら反映された。 aboutページを用意する contents/about.mdを用意すると動きました。 細かいことには触れません。 大体完成！ 後はルートディレクトリでhugo serverを実行するとhttp://localhost:1313にアクセスすると見れます。 ビルドするときはhugoを実行すればpublic/に静的サイトが作成されます。 適当にpushしときましょう。 メタデータのテンプレートはこんなかんじかな？ --- title: title date: yyyy-mm-dd # lastmod: yyyy-mm-dd # ogimage: https://path/to/ogimage.img tags: - categories: - archives: - # math: true # toc: false --- 追記 注意このセクションに書いてあることとそれまでのセクションで書いてあることが重複していたり、矛盾している場合、こちらがより正しい。 実用的にはほとんど何もしなくてもいい感じにしてくれるほうが良いなと思った。 記事作成でメタ情報の追加が面倒くさそうだなと思ったので、分類をタグのみに絞ることにした。 まず、hugo.tomlの内容を修正する。 具体的には、次の内容を消す # [taxonomies]にある category = \u0026#34;categories\u0026#34; # [menu]にある [[menu.main]] identifier = \u0026#34;categories\u0026#34; name = \u0026#34;Categories\u0026#34; url = \u0026#34;/Categories/\u0026#34; weight = 4 すると、上のメニューバーが一枠開くので、CSSを修正する。 /static/css/custom.cssを次のように修正する。 /* #main-menu-nav-itemsにある */ /* 次を消す */ grid-template-columns: repeat(5, 20%); /* 次を追加 */ grid-template-columns: repeat(4, 25%); これでタクソノミーを減らすことができた。hugo的にはカテゴリとタグを特別使い分けてなさそう(知らんけど)ので、許されるんじゃないかな 全文検索をパクる まくまくhugoノートを見ていたら、全文検索を実装できるらしい。 この機能があれば過去記事とかから情報を検索できてすごく便利だなと思ったので、導入することにした。 ほとんど上のコードをパクり、/layouts/shortcodes/search.htmlとしてファイルを作成し、search.mdというファイルでショートコードを取り込むことにした。 内容は省略するとして、search.mdの内容を載せておく。 --- title: サイト内全文検索 hidedate: true toc: false _build: {list: never} --- サイト内の文章からインクリメント検索が可能です。 下の入力欄に入力することで検索ができます。 本ページは検索の対象外になっています。 \u0026lt;!-- searchのショートコードを入れる(ここに入れるとここでも無限再帰になってしまう。) --\u0026gt; _build: {list: never}というのをすると、一覧系のページに表示されなくなるらしい。これをしないとビルドのときに無限再帰になってしまう。 さて、これで上のメニューバーに検索を入れたくなった。 CSSを再度修正し、先程消したカテゴリの分を作る。 grid-template-columns: repeat(5, 20%); [[menu.main]] identifier = \u0026#34;search\u0026#34; name = \u0026#34;Search\u0026#34; url = \u0026#34;/search/\u0026#34; weight = 4 出来上がりは検索ページで確認できる。 また、詳細なファイルの内容はgithubのリポジトリにおいてある。 それはそれとして、さっき直したものをまた直すとは計画性のないアホである。 関連タグの表示を調整する 便利な機能として、関連タグの記事を下の自動リンクしてくれる機能があるが、その見た目があまり良くなかった。 ので、改造する。 /layouts/partials/related-tag-posts.htmlを次のように修正する。 \u0026lt;!-- 次を削除 --\u0026gt; \u0026lt;h4\u0026gt;Other posts tagged by \u0026#34;{{ $t }}\u0026#34;\u0026lt;/h3\u0026gt; \u0026lt;!-- 次を追加 --\u0026gt; \u0026lt;h4 style=\u0026#34;font-size: 1.3em;\u0026#34;\u0026gt;Other posts tagged by \u0026#34;{{ $t }}\u0026#34;\u0026lt;/h4\u0026gt; これ修正して気づいたが、オリジナルのコード閉じタグ間違ってない？ それと同時にCSSに次のものを追加する。 .related-tag-category-list { margin-top: 5em; } これで幅と可読性がいい感じになった。 過去記事の移植 今日(9月23日)、まだ完了していませんが、pandocでhtmlをmarkdownに変換して手作業で移植しています。つらたん。 (デプロイ後に発覚)faviconの謎の不具合 なんかlayouts/partials/head.htmlのfaviconのhrefの後ろにc=?\u0026lt;謎の文字列\u0026gt;みたいな謎の処理が入っているが、何故かgithub pages上でうまく動かなかった。 よって、これを削除した。 どういう影響があるのか知らない。 2023-09-23追記: 多分キャッシュ関連の何かだと思うんだけど、調べてもよくわからなかった。まあ動かなかったのは事実なのでfaviconくらい別にいいでしょの顔 ただ不思議なのは、cssとかもこれをやる設定になっているように見えること。なぜかfaviconだけうまく動かない。 win機でpullしたときに発覚したこと (これはhugoの記事として適切ではないかもしれません。) 最初にsimplogをgit submoduleしてとってきましたが、他のPCでこのリポジトリをクローンした場合、自動的にsubmoduleまでとってきてくれるわけではないようです。 これを参考にして、次のコマンドを打ったらうまくいきました。 git submodule init git submodule update フロントマターのテンプレート 最後に改訂版フロントマターのテンプレートを載せておく。 --- title: hogehoge # description: hogehoge date: yyyy-mm-dd # hidedate: true # lastmod: yyyy-mm-dd # ogimage: https://hoge/fuga/piyo.img tags: - hoge archives: - yyyy - yyyy-mm # math: true # toc: false # build: {list: never} --- 終わりに なんだかんだ1週間以上色々やってた。 疲れました。 これでいろんな記事を作りやすくなった。嬉しい。"
  },
  {
    url: "/post/abc315/",
    title: "ABC315参加記録",
    date: "2023-08-24T00:00:00Z",
    body: "ABC315参加記録 はじめに 本稿は2023/8/19に行われたABC315の参加記録です。 戦績 今回の提出は以下のとおりです。 レーティング変化は以下のとおりです。 A, B, C, D, Eの5完で、レーティング変動は 979=\u0026gt;1032(+53)でした。 所感 今回でついにレーティング1000の大台に乗ることができました！かなり嬉しいです。 最近のABCでかなり手痛い負け(負けでないにしろ、解けないとダメだった問題を落としたり)が続いていたため、 今回で多少モチベが回復したような気がします。 コンテストに対する感想としては、今回D問題がかなり重実装(?)の問題だったようです。 当たりの方針を引いて、かつうまく実装できないと解くのが難しかったようで、difficultyが水色になっていました。 私は運良く筋の良い方針を見つけることができたため、なんとか通すことができました。 これが今回のパフォーマンスの上ブレに繋がったようです。 E問題は解けはしましたが、割と試行錯誤して通した感じがあります。 もっと問題の本質を見極められるようになりたいなと思います。 解法 A - tcdr Sの長さが十分に短いので、一つづつチェックするだけで良いです。 一文字のチェックに5回の同値判定をすれば良いので一回の判定がO(1)、全体O(|S|)です。 提出 B - The Middle Day 制約から、必ず真ん中の日が存在して、それは(Dの総和+1)/2になります。 D_1から順に総和をとっていき、初めて(真ん中の日)\u0026lt;=(総和+D_x)となるxが真ん中の日を含む月になります。 また、その月の(真ん中の日)-(総和)日目が真ん中の日になります。 混乱してしまう場合は、一旦紙に書いて一つづつ数えるとわかりやすいと思います。(自分もこういうの苦手です。) 計算量は、総和でO(M)、前からのシミュレーションでO(M)であるから、全体O(M)です。 提出 C - Flavors 素直にやるなら、N個から2つ選ぶ全探索のO(N^2)です。 これは間に合いません。 この手のO(N^2)(だけではないが)が通らないタイプの問題にはいくつかパターンがあり、よくあるのは 何らかの前計算をしておき、各ケースの計算量を落とす。 分割統治で擬線形時間に落とす。(例: ソートなど) 動的計画法により前進的に(そうでない場合は、トポロジカル順に)求める。 実は探索するべきものはそんなに多くない。 とかです。 今回は、問題をよく見ると、全探索を減らすことができそうだとわかります。 場合分けしましょう。 2つのアイスの種類が同じ: 美味しさのトップ2を取ればよい。 2つのアイスの種類が違う: (異なるアイスの)美味しさのトップ2を取れば良い。 さて、1番はO(N)個の候補しかなく、2番は高々一つの候補しかありません。 ただし注意として、これらのうちどちらか片方は候補が一つも存在しないことがありえます。(両方候補がなくなることはないです。) 前処理をさくっとできれば、残りは線形時間で処理できそうです。 というわけで、アイスを種類ごとに振り分けてソートし、(存在すれば)それぞれの候補値のmaxを取れば良いです。 提出 私は候補が存在しないケースに気づかずに2WAしました:( D - Magical Cookies 今回の激ヤバ問題です。 色々考えました。 最初は印をつけたやつを即時消してよいのかと思っていました。 しかし、サンプル2を見て、定義された操作の順番に操作しないとダメなケースがあるなと気づき、 シミュレーションで解く方向に舵を切りました。 完全にそのままシミュレーションしてしまうと、 一回の操作あたりO(HW)となり、全体O((HW)^2)になりそうだなーという感じでダメそうです。 というわけで、配列で各行、各列の「残っている色の種類数」「クッキーの総数」を管理しながらシミュレーションしました。 削除する列(行)となくなるクッキーの色をキューで管理して、楽に削除クエリを処理できるようにしました。(説明が難しい) 自分の文章力だと限界なので、提出例から読み取ってくれ(丸投げ) 提出 E - Prerequisites 順番を考えなければ、必要な本を見つけるのはそれほど難しいことではないです。 具体的には、「その本が必要とする本」へ辺を張って、本1から辿れる連結成分が必要な本です。 無向グラフにしてしまうと変な本を取り込んでしまうおそれがあるので、有向グラフでやりましょう。 変な本を取り込む例: 本1が本2を必要とし、本3が本2を必要とするとき、連結成分に本3も含まれるが、別にいらない。 この連結成分をいい感じの順番で出力すればACです。 ある時点で読むことのできる本の条件は、その本が必要とする本を全部読んでいることです。 これをグラフで表現すると、その本から有向辺でつながっている本を全部読み終わっていることといえます。 ここで、出次数をうまく扱います。 先程の条件は、出次数を用いると、「出自数が0の本なら読んでも良い」になります。 読んだ本へと伸びている辺を切っていけば(辺の始点の出次数を減らせば)順番に上がっていくことができます。 すまん、うまく説明できない。「トポロジカル順序」でググってくれ(丸投げ)(最悪) 提出 自分の提出では、有向辺を逆向きにたどるために、後から逆方向の辺を張って無向グラフに変えています。 終わりに ブログエントリ作るの時間かかる上に、問題をちゃんと解けないとネタがないから割と大変です。。 このブログはかなりメチャクチャな構造をしているので、最近どうにか改装しようと頑張っているのですが、こっちも思った以上に大変で心が折れそう。 まあなんにせよ引き続き競プロがんばります。"
  },
  {
    url: "/post/modpow/",
    title: "繰り返し二乗法について",
    date: "2023-08-05T00:00:00Z",
    body: "繰り返し二乗法について はじめに この度私のライブラリに冪乗の余りを求める、いわゆるmodPow関数を追加しました。 丁度いい機会ということで、本稿ではmodpowの仕組みを説明し、詳細な実装方法と実装例を示します。 数学をガバっていたらすみません。 modpowとは 以下、$\\times{}$は整数の積を表します。 まず、剰余を定める重要な定理を紹介します。 定理1 (除法定理) $\\forall{} n, m \\in{} \\mathbb{Z} ~ (m \\neq{} 0)$に対して、 $q, r \\in{} \\mathbb{Z}$が存在して、次を満たす。 $$ n = qm+r, ~ 0 \\leq{} r \u0026lt; |m| $$ また、このような$q, r$は$m, n$に対してただ一つに定まる。 ::: (証明略) ここで、$q, r$をそれぞれ、「$n$を$m$で割った商」、「$n$を$m$で割った非負最小剰余」と定めます。 次に、$\\forall{}x \\in{} \\mathbb{Z}$と非負整数$n$に対して、冪乗$x^n$を次で定めます。 $$ x^n = \\begin{cases} x \\times{} x^{n-1} \u0026amp; \\text{if $n \\geq{} 1$} \\\\ 1 \u0026amp; \\text{if $n = 0$} \\end{cases} $$ 本稿で紹介するmodPow関数で求める値は、$a^x$をMODで割った非負最小剰余です。 (数式苦手な方へ)これは何を求めているのかをできるだけ形式的に定めているだけなので、あまり気にしなくても良いです。 「$a$ を $x$ 回掛け算して、MODで割った余りを求める。」でOKです。 (注意): 便宜上、$0^0=1$ としています。 計算原理 以下、割る数は$0$を含まない正整数とします。 割る数とはプログラムにおけるMODのことです。 (定義を考えれば負の整数に対しても非負最小剰余はただ一つに定まりますが、実用上正整数を用いることが多いのかな？) 通常、冪乗は比較的簡単に非常に大きな値になります。 例えば、$2^{10}=1024$ ですが、$2^{64}=18446744073709551616$ であり、 上の定義をそのまま計算するだけでは非常に厳しいことがわかります。 そこで、まず次の定理が大事になります。 定理2 $(a ~ \\text{mod} ~ m)$と書けば、$a$を$m$で割った非負最小剰余を表すとする。 このとき、整数$x, y$に対して次が成立する。 $$ ((x \\times{} y) ~ \\text{mod} ~ m) = ( ((x ~ \\text{mod} ~ m) \\times{} (y ~ \\text{mod} ~ m)) ~ \\text{mod} ~ m) $$ 証明: 上で示した定理により、次が成立する。 ある整数 $q_{1}, q_{2}, r_{1}, r_{2}$ が存在して、$x = q_{1}m + r_{1}, ~ y = q_{2}m + r_{2}$ また、 $$ \\begin{split} x \\times{} y \u0026amp;= (q_{1}m + r_{1}) \\times{} (q_{2}m + r_{2}) \\\\ \u0026amp;= q_{1}q_{2}m^2 + (q_{1}r_{2} + q_{2}r_{1})m + r_{1}r_{2} \\\\ \u0026amp;= (q_{1}q_{2}m + (q_{1}r_{2} + q_{2}r_{1}))m + r_{1}r_{2} \\\\ \\end{split} $$ であるから、 $$ \\begin{split} (左辺) \u0026amp;= ( ((q_{1}q_{2}m + (q_{1}r_{2} + q_{2}r_{1}))m + r_{1}r_{2}) ~ \\text{mod} ~ m ) \\\\ \u0026amp;= ((r_{1}r_{2}) ~ \\text{mod} ~ m) \\end{split} $$ 一方、 $$ (x ~ \\text{mod} ~ m) \\times{} (y ~ \\text{mod} ~ m) = r_{1}r_{2} $$ であるから、 $$ (右辺) = ((r_{1}r_{2}) ~ \\text{mod} ~ m) $$ 証明終わり。 この定理は、積に関してなら どのタイミングで非負最小剰余に変換しても最後は同じ値になるということを示しています。 また、定理では右辺は両方非負最小剰余に変換していますが、もちろん片方だけで行っても同様の結果が得られます。 これで $a^x$ の大きさに関する問題は解決します。 なぜなら、一回 $a$ を掛け算するたびに非負最小剰余に逐次変換していけば良いので、 $(割る数) \\times{} (割る数)$さえ正しく計算できれば $a^x$ の非負最小剰余もまた計算可能になるからです。 プログラム的には、用いる整数の型が $k$ bitであるとき、MODの大きさが $k/2$ bit程度であれば計算できます。 したがって、次のようなプログラムは正しく動作します。 long long modPow (long long a, long long x, const int MOD) { // 不正な入力を弾く assert(0 \u0026lt;= x); assert(1 \u0026lt;= MOD); // aを正規化 a %= MOD; a += MOD; a %= MOD; long long res = 1; for (long long i = 0; i \u0026lt; x; i++) { res *= a; res %= MOD; } return res % MOD; } $a$ の正規化というのは、底を最初の段階で非負最小剰余に変換しているということです。 上のコードは積や剰余演算を$O(1)$でできると仮定すれば、全体で$O(x)$で抑えられます。 しかし、(競技プログラミングなど)実用上はxは$10^9$程度であったりすることが多く、このままでは使えません。 そこで、通常は次に説明するような高速化を施します。 まず、以下の定理を導入します。 定理3 ($p$ 進法) 2以上の整数 $p$ を固定する。任意の非負整数 $x$ に対して、 長さ$1$以上の整数列 ${c_{i}} ~ (c_{i} \\in{} {0, 1, \\cdots{}, p-1})$ が存在し、 $$ x = \\sum_{i=0} c_{i}p^{i} $$ と表すことができる。 また、このような表し方(すなわち、数列 ${c_i}$)は $x=0$ を特別扱いするとき、先頭の余計な $0$ の項を除いて一意に定まる。 証明: まず、任意の非負整数が上の形で表されることを示す。 (1) $x=0$ のとき、すべての項が $0$ であるような整数列 ${c_{i}}$ を用いれば良い。 (2) $x=1$ のとき、整数列 ${c_{i}}$ であって、 $$ c_{i} = \\begin{cases} 1 \u0026amp; \\text{if $i=0$} \\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} $$ であるようなものを用いれば良い。 (3) $x\u0026gt;1$ に対して $x$ 未満の正整数が上の形で表されると仮定する。 このとき、$x = qp + r$ と表示すると、 (i) $q=0$ のとき、$0 \\leq{} r \u0026lt; p$ であるから、整数列 ${c_{i}}$ であって、 $$ c_{i} = \\begin{cases} r \u0026amp; \\text{if $i=0$} \\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} $$ であるようなものを用いれば良い。 (ii) $q \\neq{} 0$ のとき、$q \u0026lt; x$ であるから、仮定より長さ1以上の整数列 ${d_{i}}$ が存在して $$ q = \\sum_{i=0} d_{i} p^{i} $$ よって、$x=qp+r$としていることを思い出せば $$ pq = \\sum_{i=0} d_{i} p^{i+1} $$ であるから、ここで新しく整数列 ${c_{i}}$ を次のように定める。 $$ c_{i} = \\begin{cases} r \u0026amp; \\text{if $i=0$} \\\\ d_{i-1} \u0026amp; \\text{otherwise} \\end{cases} $$ すると、 $$ x = pq+r = \\sum_{i=0}^{m} c_{i} p^{i} $$ と表すことができる。 数学的帰納法により、任意の整数を表すことができる。 次に、このような表し方が非負整数$x$に対して一意に定まることを示す。 まず、$x=0$ のとき、すべての $c_i$ が $0$ である。 これは「先頭の余分な $0$」のみで構成されている唯一の数字なので、これを特別扱いして、一意に定まっているとみなす。 (1) $0 \u0026lt; x \u0026lt; p$ のとき $$ x = \\sum_{i=0} c_i p^i $$ とすると、$1\\leq{}i$ なる $i$ に対して $c_i \\neq{} 0$ であるとき、明らかに $p \\leq{} x$ となる。これは仮定に反する。 したがって、 $$ c_i = \\begin{cases} x \u0026amp; \\text{if $i=0$} \\\\ 0 \u0026amp; \\text{if $i \\neq{} 0$} \\\\ \\end{cases} $$ 以外の表し方は存在しない。 (2) $p \\leq{} x$ のとき $x$ 未満の数は、すべて一意的に表されると仮定する。 このとき、 $$ \\begin{split} x \u0026amp;= \\sum_{i=0} c_i p^i \\\\ \u0026amp;= \\left( \\sum_{i=1} c_i p^{i-1} \\right) p + c_0 \\end{split} $$ とできる。定理1により、$\\sum_{i=1} c_i p^{i-1}$ と $c_0$ はただ一つに定まる。 ここで、明らかに $\\sum_{i=1} c_i p^{i-1} \\leq{} x$ である。 仮定より、$c_i ~ (1\\leq{}i)$ は一意に定まる。 以上より、数学的帰納法により任意の非負整数 $x$ は一意に表される。 証明終わり。 少々天下り的ですが、$p=2$ を選んで、$x = \\sum_{i=0} 2^i c_i ~ (c_i \\in{} {0, 1})$ とします。 定理より、非負整数 $x$ はこのような表示を先頭の $0$ の自由を除いて一意に持ちます。 このとき、 $$ \\begin{split} a^x \u0026amp;= a^{\\sum_{i=0} 2^i c_i} \\\\ \u0026amp;= a^{c_0 + 2 c_1 + 2^2 c_2 + \\dots{}} \\\\ \u0026amp;= a^{c_0} \\times{} a^{2 c_1} \\times{} a^{2^2 c_2} \\times{} \\dots{} \\\\ \u0026amp;= \\prod_{i=0} a^{ 2^i c_i} \\\\ \u0026amp;= \\prod_{i=0} \\left( a^{2^i} \\right) ^{c_i} \\end{split} $$ となります。 (式変形がわからない人はこちらを参考にしてください。) 実は、この形まで変形すると非常に高速に計算できるようになっています！ 先程の定義通りに計算する方法では、$x$ が大きいときに時間がかかるということが問題でした。 上の変形は、視覚的に説明するなら、 $$ a^{100} = a^{64} \\times{} a^{32} \\times{} a^{4} $$ のように分解しているということです。 定理3は、このような分解をしたときに、右辺の指数が必ず $2^k$ と表せるということを保証しているとも言えます。 この定理のおかげで $a^{2^k}$ の形の数さえ高速に列挙できれば良くなり、結果的に冪乗を求めるのも高速になるということです。 また、$a^{2^k} = a^{2^{k-1}} \\times{} a^{2^{k-1}}$ という関係が成立するため、$a^{2^k}$ の形の数は簡単に求められます。 以上より、次のアルゴリズムを得ます。 $a^x ~ \\text{mod} ~ m$ を高速に求めるアルゴリズム $x$ を2進法展開する。つまり、$x = \\sum_{i=0} c_i 2^i$ と表す。 $base \\leftarrow{} (a ~ \\text{mod} ~ m), ~ ans \\leftarrow{} (1 ~ \\text{mod} ~ m), ~ i \\leftarrow{} 1$ とする。 すべての $k ~ (i \\leq{} k)$ に対して $c_k = 0$ であれば、$ans$ を出力し終了。 $c_i = 1$ であれば $ans \\leftarrow{} ((ans \\times{} base) ~ \\text{mod} ~ m)$ とする。 $base \\leftarrow{} ((base \\times{} base) ~ \\text{mod} ~ m), ~ i \\leftarrow{} i+1$ とする。 3に戻る。 このアルゴリズムの時間計算量は、手順3から手順6のループ1回あたり $O(1)$ とみなせば、 $x \u0026lt; 2^k$ となった時点で停止するため($k$ 以降の数 $l$ において $c_l = 0$ となるから)、全体で $O(log(x))$ になります。 元々の $O(x)$ のアルゴリズムからかなり改善されました！ 実装 実は、$x$ を2進法展開するのはほとんどのプログラミング言語で必要ないです。 というのは、コンピュータは内部的に整数を2進法で表現しているからです。 ビット演算と言われるような機能を持つプログラミング言語ならこの過程を飛ばすことができます。 具体的には、$x$ を2進法展開したときの $c_0$ は、プログラム上ではx\u0026amp;1 で得ることができます。 更に、x \u0026gt;\u0026gt;= 1などで「ビットシフト」をすると、次にx\u0026amp;1をしたときには $c_1$ が得られます。 (ただし、このあたりはプログラミング言語によります。) 負の数が関わると2の補数表現など少しややこしくなりますが、$0\\leq{} x$ を仮定しているので問題ありません。 以下にC言語、C++、D言語、python3での実装例を示します。 C言語/C++ #include \u0026lt;assert.h\u0026gt; // C言語なら\u0026lt;assert.h\u0026gt; // C++なら\u0026lt;cassert.h\u0026gt; long long modPow (long long a, long long x, const int MOD) { // assertion assert(0 \u0026lt;= x); assert(1 \u0026lt;= MOD); // normalize a %= MOD; a += MOD; a %= MOD; // calculate long long ans = 1L % MOD; long long base = a; while (x != 0) { if ((x\u0026amp;1) != 0) { ans *= base; ans %= MOD; } base = base*base; base %= MOD; x \u0026gt;\u0026gt;= 1; } return ans; } D言語 long modPow (long a, long x, const int MOD) { // assertion assert(0 \u0026lt;= x); assert(1 \u0026lt;= MOD); // normalize a %= MOD; a += MOD; a %= MOD; // calculate long ans = 1L % MOD; long base = a % MOD; while (x != 0) { if ((x\u0026amp;1) != 0) { ans *= base; ans %= MOD; } base = base*base; base %= MOD; x \u0026gt;\u0026gt;= 1; } return ans; } python3 def modPow (a, x, MOD): # assertion assert 0 \u0026lt;= x, \u0026#34;x must be an integer greater than or equal to 0\u0026#34; assert 1 \u0026lt;= MOD, \u0026#34;MOD must be an integer greater or equal to 1\u0026#34; # normalize a %= MOD # calculate ans = 1 % MOD base = a while x != 0: if (x\u0026amp;1) != 0: ans *= base ans %= MOD base = base*base base %= MOD x \u0026gt;\u0026gt;= 1 return ans 終わりに まとめるのすごく大変だった... 内容に不備があれば著者のtwitterに連絡していただければ助かります。 どれだけ些細な内容でも大歓迎です。 参考文献 本稿における主張、紹介した定理及びその証明はほとんど以下に依ります。 尾関和彦、 情報技術のための離散型数学入門、 共立出版(2023) 主に第5章、第6章を参考にしました。"
  },
  {
    url: "/post/abc310/",
    title: "ABC310参加記録",
    date: "2023-07-17T00:00:00Z",
    body: "ABC310参加記録 はじめに 本稿は、2023/7/15に開催されたABC310の参加記録となっています。 戦績 まずは、今回の戦績です。 A,B,Cの3完で、パフォーマンスは1142で、 レーティング変化は961=\u0026gt;981(+20)でした。 今回の提出は以下の通りです。 所感 今回久しぶりに本番中にD問題が通せませんでした。 かなり悔しいとともに、何故かパフォーマンス1000以上が出て割とレートがプラスになったのは少し腑に落ちない感じです。 後で発覚したのですが、実はD問題は解けていて、配列の範囲外参照によるREで落ちていたようです。(上の提出記録にあるように、どこでRE引いてるのかわからなくて提出でバッグを試みていました。) というのも、実はD言語はAtCoder側でコンパイルオプションがリリースモードになっているようで、配列の範囲外参照を拾ってくれないんですよね。 なので、try-catchでエラーを捕まえてデバッグしようとしても無駄でした。 これマジでどうにかしてほしいんですが... 更にいうとE問題も正直ムズいと思います。 適当にDPもどきみたいなものを書いて通したんですが、解説が難解でよくわからなかった(小並感) こういうのを適当な理解で済ませると後で痛い目を見ると思うので、ちゃんとなんで解けてるのか究明しないといけないわけです。 しかし、より広い問題設定に耐えうるような包括的な理解というものは難しいものですよね。(諦観) 問題と解法 解けた問題について振り返ろうと思います。 今回試験的に問題文を丸コピしてみます。特にことわりがなければ、問題名のリンク先が引用元になっています。 A - Order Something Else 問題文 高橋君は、レストランで「AtCoder ドリンク」というドリンクを飲もうとしています。 AtCoder ドリンクは定価である $P$円を払えば飲むことができます。 また、高橋君は割引券を持っており、それを使うと AtCoder ドリンクを定価より安い価格である $Q$ 円で飲むことができますが、 その場合には AtCoder ドリンクの他に、$N$ 品ある料理の中から 1 つを追加で注文しなければなりません。$i=1,2,\u0026hellip;,N$ について、$i$ 番目の料理の価格は $D_i$ 円です。 高橋君がドリンクを飲むため支払う合計金額の最小値を出力してください。 解法 仮に他に料理を頼むなら、一品だけ頼むのが最適になります。 したがって、料理を頼まないときの金額と、一品だけ料理を頼むときの金額を全部見て、それらの最小値が解になります。 制約も十分小さいのでこれでACできます。 提出 B - Strictly Superior 問題文 AtCoder 商店には $N$ 個の商品があります。 $i$ $(1\\leqq{}i\\leqq{}N)$ 番目の商品の価格は $P_i$ です。 $i$ $(1\\leqq{}i\\leqq{}N)$ 番目の商品は $C_i$ 個の機能をもち、$i$ $(1\\leqq{}i\\leqq{}N)$ 番目の商品の $j$ $(1\\leqq{}j\\leqq{}C_i)$ 番目の機能は $1$ 以上 $M$ 以下の整数 $F_{i,j}$ として表されます。 高橋くんは、AtCoder 商店の商品で一方が一方の上位互換であるものがないか気になりました。 $i$ 番目の商品と $j$ 番目の商品 $(1\\leqq{}i,j\\leqq{}N)$ であって、次の条件をすべて満たすものがあるとき Yes と、ないとき No と出力してください。 $P_i\\geqq{}P_j$ である。 $j$ 番目の製品は$i$ 番目の製品がもつ機能をすべてもつ。 $P_i\u0026gt;P_j$ であるか、$j$ 番目の製品は $i$ 番目の製品にない機能を $1$ つ以上もつ。 解法 問題が結構ワチャワチャしていて読解が大変ですが、やること自体はシンプルです。 しっかり読み取るべき情報は、 各商品の「機能」は、1以上M以下の値からなる100項以下の数列で表される(以後、「機能数列」と呼ぶ) 「商品iと商品jが機能xを持つ」とは、どちらの商品の機能数列もxを含むことである ということです。 これを踏まえた上で、「商品iが商品jの上位互換である」ということを次のどちらかの条件を満たすことと定めます。 すべての商品iの持つ機能を商品jが持ち、逆に、すべての商品jの持つ機能を商品iが持つ。 かつ、商品iの値段が商品jの値段未満である すべての商品jの持つ機能を商品iが持ち、かつ、ある機能が存在して、商品iはその機能を持ち、商品jはその機能を持たない。 かつ、商品iの値段が商品jの値段以下である。 堅苦しく書いたのはそっちのほうが実装に落とし込みやすいかなと思っているからです。 これを正確に実装すればACが取れます。 なお、機能を持っているかのチェックは二重ループなどによる全探索でも余裕で間に合います。 提出 C - Reversible 問題文 ボールがいくつか刺さった棒が N 本あり、各ボールには英小文字が $1$ 個書かれています。 $i=1,2,\\cdots{},N$ について、$i$ 番目の棒に刺さった各ボールの英小文字は、文字列 $S_i$ によって表されます。 具体的には、$i$ 番目の棒には文字列 $S_i$ の長さ $|S_i|$ に等しい個数のボールが刺さっており、 刺さっているボールの英小文字を、棒のある端から順に並べたものは文字列 $S_i$ と等しいです。 $2$ つの棒は、一方の棒に刺さっているボールの英小文字をどちらかの端から並べた列と、もう一方の棒に刺さっているボールの英小文字をどちらかの端から並べた列が一致するとき、同じ棒とみなされます。 より形式的には、$1$ 以上 $N$ 以下の整数 $i,j$ について、$i$ 本目の棒と $j$ 本目の棒は、$S_i$ が $S_j$ と一致するか、$S_i$ が $S_j$ を前後反転したものと一致するとき、かつそのときに限り、同じとみなされます。 $N$ 本の棒の中に、何種類の異なる棒があるかを出力してください。 解法 ややこしいですが、言ってることはこうです。２つの文字列a, bが等しいということを次で定める。 aとbが等しい aを逆順にしたものとbが等しい いくつか文字列が与えられます。相異なる文字列はいくつありますか？ 素直に全探索するとO(N^2)で間に合いません。 そこで、連想配列などを利用します。 解法1: 全部の回分でない文字列と、全部の回分でない文字列の逆順を連想配列に登録して、登録数を2で割ったものと回分の和を取る。 解法2: 全部の文字列を登録する。 その後、それぞれ回分でないものを逆順にしたものが連想配列に登録されているかを見ていき、 登録されていたら、逆順にする前の文字列を連想配列から除去する。 最後に登録数を出力。 解法1はほぼ自明です。解法2は、これを行うことでもとの文字列を逆にしたものだけが残ります。 ある文字列と、その逆順文字列がどちらも与えられるパターンと、そうでないパターンについて考えると証明できそう(知らん) 回文が色々とコーナーケースになっているので気をつける必要がありますが、サンプルに載っています。 自分はアホなので解法2を取りましたが、普通に考えて解法1のほうが楽です。 提出 D - Peaceful Teams 問題文 $N$ 人のスポーツ選手がいます。 $N$ 人の選手たちには互いに相性の悪い選手のペアが $M$ 組あり、相性の悪い組のうち $i$ $(1\\leqq{}i\\leqq{}M)$ 組目は $A_i$ 番目の選手と $B_i$ 番目の選手です。 あなたは、選手を $T$ チームに分けます。 どの選手もちょうど一つのチームに属さなければならず、どのチームにも少なくとも一人の選手が属さなければなりません。 さらに、どの $i=1,2,\u0026hellip;,M$ についても、 $A_i$ 番目の選手と $B_i$ 番目の選手が同じチームに属していてはいけません。 この条件を満たすチーム分けの方法は何通りあるか求めてください。 ただし、チーム分けの方法が異なるとは、ある二人が存在して、彼らが一方のチーム分けでは同じチームに所属し、もう一方では異なるチームに所属することをいいます。 解法 私は公式解法2通りのどちらでもない解法で無理やり通したので、それを書きます。 まず、少なくとも一人がチームにいないといけないということなので、nCtを全列挙します。 nCtで選ばれたT人を、前からチーム0,1,2,...,T-1に割り当て、 残ったN-T人をN-TビットT進数と見てビット全探索します。 ビットがiの人をチームiに割り当てることにすると、 すべてのチームの分け方を探索できます。 しかしこのままだと、チームの分け方が重複する場合が存在します。 重複の数はチームiのメンバー数を$m_i$とすれば、$\\displaystyle\\prod_{i=0}^{T-1} m_i$となります。 よって、重複数で分けて総和を取り、最後に重複数で割った総和が答えになります。 最初にnCtをしているのはビット全探索パートの計算量を落とすためです。 計算量は全体で$O(N*({}_n\\mathrm{C}_t)*(N-T)^T*(チーム分けがOKかどうかの一回の判定分))$くらいかなぁ...よくわからん。 細部を説明するのは大変な上、かなり怪しい解き方なのでこれ以上は言及しません。 提出 余談ですが、公式解説の全探索とdpはもっと一般化した主張にできるんじゃないかな(できたら便利そうだな)と思っていますが、 数学無理なので無理です。(は？) E - NAND repeatedly 問題文 0 と 1 からなる長さ $N$ の文字列 $S$ が与えられます。 $S$ は長さ $N$ の数列 $A=(A_1,A_2,\u0026hellip;,A_N)$ の情報を表しており、$S$ の $i$ 文字目 $(1\\leqq{}i\\leqq{}N)$ が $0$ のとき $A_i=0$ 、$1$ のとき $A_i=1$です。 $$ \\sum_{1\\leqq{}i\\leqq{}j\\leqq{}N} (\\cdots{}((A_i\\bar{\\land{}}A_{i+1})\\bar{\\land{}}A_{i+2})\\bar{\\land{}}\\cdots{}\\bar{\\land{}}A_j) $$ を求めてください。 より厳密には、次のように定められる $f(i,j) (1\\leqq{}i\\leqq{}j\\leqq{}N)$ に対して $\\displaystyle\\sum_{i=1}^N \\displaystyle\\sum_{j=i}^N f(i,j)$ を求めてください。 $$ \\begin{equation*} f(i,j)= \\begin{cases} A_i \u0026amp; \\text{$(i=j)$} \\\\ f(i,j−1)\\bar{\\land{}}A_j \u0026amp; \\text{$(i\u0026lt;j)$} \\end{cases} \\end{equation*} $$ ただし、否定論理積 $\\bar{\\land{}}$ は次を満たす二項演算子です。 $0\\bar{\\land{}}0=1,0\\bar{\\land{}}1=1,1\\bar{\\land{}}0=1,1\\bar{\\land{}}1=0$ 解法 普通にやるとO(N^2)で間に合いません。そこで、何かしらの性質を利用する必要がありそうだとわかります。 演算が左結合であり、演算の結果取りうる値が0か1しかないということを利用して計算します。 $dp[i][j]:=$(左からi文字目まで見て、値がjであるような場合の数) としてやるとうまく行きます。 $\\displaystyle\\sum_{i=0}^{N-1} dp[i][1]$が答えになります。 正直よくわかっていませんが、始点を固定したとき同じ領域を何回も計算しているのを圧縮しているっぽいです(適当) この辺もちゃんと解けるようになりたいなぁ 提出 終わりに 今週のABCは色々とだめなところが多かったなと反省です。 ここ最近精進をちょっとサボってしまっていたのが悔やまれるので、今週はしっかり取り組みたいです。 今回出題された問題は最近の中でも特に学びが多そうな雰囲気があるので、復習もがんばります。 あと、問題文コピってくるのラクかなーって思ってやってみましたが、クソ大変でした。二度とやりません。"
  },
  {
    url: "/post/abc309/",
    title: "ABC309参加記録",
    date: "2023-07-13T00:00:00Z",
    body: "ABC309参加記録 始めに 本稿は2023/7/8に開催された、ABC309の参加記録です。 戦績 今回の戦績を紹介します。 A, B, C, D, Eの5完で、 パフォーマンスが1130で、レーティング変化が964=\u0026gt;982でした。 以下は今回の提出です。 解いた問題 A - Nine 問題概要: 各マスに異なる数字が書かれている3*3の盤面がある。整数A, Bが与えられるので、横方向で隣接しているかをせよ。ただしA\u0026lt;Bが保証される。 また、盤面は以下のとおりである。 1 2 3 4 5 6 7 8 9 解法: 法則性を見るなら、Aが3の倍数の時、条件を満たすBをとることができない。したがって、必要十分条件はB-A==1かつA%3!=0となる。 また、あり得る入力のパターンが少ないので、解をすべて埋め込むのも手である。 提出 B - Rotate 問題概要: N行N列のマスが与えられる。外周を一マス右回りに動かした結果を出力せよ。 次は操作の例である。 次が操作前のマスである。 0101 1101 1111 0000 次が操作後のマスである。 1010 1101 0111 0001 解法: 解法自体は言われたことをやるだけである。計算量的には全くネックではない。 ただし、インプレースで置換しようとすると面倒くさい処理が発生することが予測される。 そこで、マス目をコピーして、片方は読み取りだけを行うようにした。 ただし、高次元の配列を参照で持つpythonなどの言語はシャローコピーとディープコピーの違いに気を付ける必要がある。 D言語も単に代入をすると同じメモリを指す参照のコピーとなるので、プロパティ関数.dupを利用して確実にコピーをする必要がある。 提出 C - Medicine 問題概要: N種類の薬を考える。薬iは処方された日を含めてa_i日間、毎日b_i錠ずつ飲む必要がある。 ここで、今日は1日目であり、すべての薬を処方された。 1日に飲む必要のある薬の総和が初めてK以下となる日を出力せよ。 解法: 薬を飲む量が減る日は全部でN日あり、それらはa_i+1日目である。よって、次のような解法で解くことができる。 始めに1日目に飲む必要のある薬の量を求める。これはb_iの総和である。 もし最初の時点でこれがK以下となっていれば、1を出力し終了する。 a_i, b_iのペアをa_iをキーにした昇順ソートし、a_iが小さい順にペアのb_iを総和から引いていく。 K以下になったとき、a_i+1を出力し終了する。 計算量はソートが支配的になり、O(NlogN)となる。 また、もう一つの解法としては、X日目に飲む必要のある薬の量がO(N)でわかるので、解についての二分探索で解くことができる。 計算量はO(NlogK)である。 どっちの解法も個人的にかなり好きであるが、二分探索のほうが汎用性がありそうだなと思う。 提出 D - Add One Edge 問題概要: N_1+N_2頂点M辺の無向グラフが与えられる。ここで、次の条件が保証される。 1\u0026lt;=u, v\u0026lt;=N_1となるような任意の2頂点は連結で、 また、N_1+1\u0026lt;=u, v\u0026lt;=N_1+N_2となるような任意の2頂点は連結である。 頂点1と頂点N_1+N_2は連結でない。 次の操作を一度だけ行う。 1\u0026lt;=u\u0026lt;=N_1, N_1+1\u0026lt;=v\u0026lt;=N_1+N_2なるu, vを選び、辺を追加する。 操作を行った後、頂点1と頂点N_1+N_2間の最短パスの長さを最大化せよ。 解法: グラフは二つの連結成分に分けられている。したがって、連結成分内で目的の点から一番遠い点同士を結ぶことで、明らかに最大化することができる。 重みが均一なグラフのパスの長さはBFS(Breadth-First search)を用いて解くことができる。計算量はO(N_1+N_2+M)となり、ネックにはならない。 提出 E - Family and Insurance 問題概要: N頂点の木が与えられる。いくつかの頂点は正の整数であらわされる「保険」を持っている。 頂点1を根として、「保険」を持つある頂点から距離が「保険」の値以下であり、かつその子孫であるようなノードは「被保険者」とする。条件を満たさないノードはは保険対象外である。 「被保険者」は何人存在するかを出力せよ。 解法: 保険の影響が親に波及することはない。したがって、根から保険の影響が及ぶかどうかを調べていけばよい。現在の保険の影響力が今いるノードの保険の影響力より小さい場合、より影響が大きいほうに乗り換えていけばよい。 実装自体はほとんどDFS/BFSそのものである。よって計算量はO(N+N-1)となる。 また、最も影響力の強いノードを優先度付きキューで管理する多点ダイクストラ法でも解くことができる。詳しくはこの問題の解説が詳しい。 提出 終わりに 今回5問解くことができた。 最近ABCで調子が良いが、気を抜かずに取り組みたいと思う。 実際、F問題は全く解法が分からなかった。 毎回画像を張り付けるのはユーザビリティ的にどうかなと思っていたので、今回は問題の概要をすべてテキストで書いてみた。 今後のエントリのスタイルは検討中である。 近況としては、 電気通信大学からチーム「A.N.Serenade」でICPC国内予選に出場した。 この感想などもやる気があれば近日中にエントリを公開したいと思う。 また、このコンテストの翌日のARC164でかなり手痛い負けをしてしまった。 普段ARCのエントリは作成していないが、忘れないようにという意味も込めてエントリを書くかもしれない。 あとから読み返して気が付いたが、ですます体が混在していて最悪なことになってしまった。"
  },
  {
    url: "/post/sorttech/",
    title: "unstableをstableにする小技",
    date: "2023-07-03T00:00:00Z",
    body: "unstableをstableにする小技 はじめに 先日(2023/7/1)のABC308のC問題にややこしいソート問題が出ました。 本稿はその問題を簡潔に解く実装のアイディアの紹介です。 無理やりstable化 標準ライブラリで一番簡単に使えるソートは安定ソートでないことが多いです。 このため、競技プログラミングでよくある2値以上を取る要素のソートのときなどに、 もとの順序が破壊されて困ることがあります。 これを解消するには、比較関数を自炊してソートに渡してあげればよいです。 例えば、以下のような構造体のソートを考えます。 struct pair { int age; int id; } この構造体を次のルールに従って並べ替えます。 ageが若いほうが先頭 ageが同じなら、idが小さいほうが先頭 このとき、次のような実装で解決することができます。 pair[] person = new pair[](N); // ... // 省略 // ... bool Less (pair x, pair y) { if (x.age == y.age) { return x.id \u0026lt; y.id; } return x.age \u0026lt; y.age; } // 比較関数を渡す。 person.sort!(Less); これ、賢いです。 多分3変数以上に拡張可能です。 さらに、stableにしたいという目的以外でも応用可能です。 例えば、この問題で、 構造体に座標を突っ込んでいき、このソートをかければ 隣接要素が等しいものが一つでもあればYesというふうにできます。 (とは言ったものの、特に理由がなければ普通にstd::mapなりなんなりを使いましょう) おまけ: C言語での文字列ソート C言語から始めた人は文字列のソートに 結構苦戦したことある人が多いんじゃないかと勝手に思っています。 せっかくソート小技のエントリなので、サンプルコードを貼り付けときます。 次の問題を解け N個の長さが10以下の文字列が与えられます。これを辞書順に出力してください。 入力形式 N S_1 S_2 . . . S_N-1 S_N 解法1: 二次元配列で楽するアレ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; // T[i]へのポインタが引数なので、char **への変換からのデリファレンスが必要 int mystrcmp (const void *x, const void *y) { return strcmp(*(char **)x, *(char **)y); } int main (void) { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); char S[N][11]; char *T[N]; for (int i = 0; i \u0026lt; N; i++) { scanf(\u0026#34;%s\u0026#34;, S[i]); T[i] = S[i]; } // ソートする qsort(T, N, sizeof(char *), mystrcmp); // 出力 for (int i = 0; i \u0026lt; N; i++) { printf(\u0026#34;%s\\n\u0026#34;, T[i]); } return 0; } 解法2: 一次元配列で文字列を受け取る #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; // T[i]へのポインタが引数なので、char **への変換からのデリファレンスが必要 int mystrcmp (const void *x, const void *y) { return strcmp(*(char **)x, *(char **)y); } int main (void) { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); char S[11*N]; char *T[N]; int idx = 0; for (int i = 0; i \u0026lt; N; i++) { T[i] = \u0026amp;S[idx]; // 入力を受け取る char input[11]; scanf(\u0026#34;%s\u0026#34;, input); for (int j = 0; input[j] != \u0026#39;\\0\u0026#39;; j++) { S[idx] = input[j]; idx++; } // 終端文字も忘れずに S[idx] = \u0026#39;\\0\u0026#39;; idx++; } // ソートする qsort(T, N, sizeof(char *), mystrcmp); // 出力 for (int i = 0; i \u0026lt; N; i++) { printf(\u0026#34;%s\\n\u0026#34;, T[i]); } return 0; } どちらも自動変数に文字列を積んでおいて、それらへのポインタを並べ替えることによってソートを実現しています。 解法1は楽ですが、一つの文字列あたりの長さが不定のときには取り回しが悪いです。 解法2は拡張性がありますが、シンプルに面倒くさいです。 結論: 動的配列が簡単に利用できる言語を使おう！(すみません) 余談 方法2は競プロフレンズさんの実装で知りました。 C言語はこういう謎テクが多くて困っちゃう。"
  },
  {
    url: "/post/abc307/",
    title: "ABC307参加記録",
    date: "2023-06-27T00:00:00Z",
    body: "ABC307参加記録 はじめに 本稿は、2023年6月24日に行われたABC307の参加記録です。 戦績 今回の戦績です。 今回はパフォーマンス1166で、 レート変動は842-\u0026gt;879でした。 コンテスト中にA,B,C,Dの4完することができました。 また、コンテスト後にE問題を通すことができました。 解いた問題 A - Weekly Records 問題文に書いてあることをそのまま行います。$A_i$があまり大きくないので普通にintでOKです。 私は前から足していって、7の倍数番目の番号のとき出力とリセットをしました。 ただし、通常プログラミング言語では0-indexedなので、i+1を考える必要があります。 (詳細は提出コードを参照) 提出 B - racecar $N$が十分に小さいので、すべての$i$,$j$について$S_i$と$S_j$の連結が回文になるかどうかをチェックする方法でOKです。 二重ループなどで解くと良いでしょう。 C言語で解くなら、不定長の文字列を受け取るテクニックが使えます。 まず、charの配列を$51*N$程度で宣言します。 その後、char*の配列を$N$要素で宣言して、 各char*の$i$番目の要素が$S_i$の先頭を指すようにすると省メモリで扱えます。 具体的には次のようにします。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); char SS[51*N]; char *S[N]; int len[N]; int idx = 0; for (int i = 0; i \u0026lt; N; i++) { char tmp[51]; scanf(\u0026#34;%s\u0026#34;, tmp); int j = 0; S[i] = \u0026amp;SS[idx]; for (; tmp[j] != \u0026#39;\\0\u0026#39;; j++) { SS[idx++] = tmp[j]; } len[i] = j; SS[idx++] = \u0026#39;\\0\u0026#39;; } } うーん、C言語辛い！w 提出(C言語ではないです。) C - Ideal Sheet 今回の激ヤバ問題です。 C問題なのにdifficultyが1200を超えています。(結構な人がスルーしたみたいです。) 要は、いい感じに文字列を組み合わせて、与えられた模様を作れるか？という問題です。 結構激重実装問題っていう風に言われていますが、 私はむしろ、どうやって解くか？という部分が一番大事になるんじゃないかと思いました。 というのも、シートAとシートBを張り合わせる土台を適当に超巨大に作ってしまうと 計算量がエラいことになってしまうからです。 私の方針としては、概ね次のような感じです。 シートA, B, Xの透明部分を長方形であることだけを保ったまま可能な限りカット 土台としてX(をカットしたもの)と同じサイズのものを用意する シートA, Bをはみ出さないように貼り付ける手順を全探索 土台とXが一致しているかチェック というような感じで解きました。 ポイントが、土台をXのカットと同じサイズにすることです。 明らかにこれが土台の限界の小ささになります。 マージンを取りすぎると全探索が多くなりすぎてTLEするみたいです。 というわけで気合でACできました。 こういう「カットできるとこをカットする」みたいな操作は絶対にC言語で実装したくないです。(強い意思) 提出 D - Mismatched Parentheses 文字列から「有効な括弧列」を削除する問題です。 有効な括弧列を処理するのにはスタックが非常に向いています。 というのも、その定義の一つに 「連続する()を削除することを0回以上繰り返して空文字列にできるもの」 というものがあるので、 明らかに)を見つけたら(までスタックから取り除く という方法で有効な括弧列を除去することができてしまいます。 後は現在スタックの中に(が何個あるかという情報を持っておくと、 )からスタックを削っていって(が見つかるかどうかを判定することができ、 残すべきところと残すべきでないところを判断することができます。 ただ、私は(の個数を管理するということまで思い至らなかったため、 「たどっていってる途中で(が見つかる前にスタックが空になってしまったらansに追加する」 という感じで解きました。計算量はO(N)です。 提出 E - Distinct Adjacet 見た目がなんかいかつそうな問題です。 まず、問題を単純化してみます。 例えば、輪っかになっていないという仮定をしてみます。 左から一人ずつ決めていくとして、 受け取ってはいけない数字は一つ左の人のみに依存するので、最初の人がM通り、 次の人からは全員M-1通りになり、答えは$M*(M-1)^{N-1}$になりそうです。 フムフム、結構自由度が高いんだなと考えながら、 輪っかの方の考察に戻ってみます。 輪っかの方もほとんど同じで、最後の一人以外は一つ左の人のみに依存するので、$M-1$通りになりそうです。 最後の一人は、最初の一人にも依存するので、状況が少し複雑になります。 最初の一人と最後から二番目の人が同じ数字のとき このとき、明らかに$M-1$通りになります。 最初の一人と最後から二番目の人が違う数字のとき このときは$M-2$通りです。 最後から二番目の人が最初の人と同じ数字である場合の数を考えるには、 最後から三番目の人が最初の人と同じ数字かどうかを知る必要があります。 アレ、ややこしくなってきましたね。 それならいっそ「$i$番目の人が、最初の人と同じ数である場合の数」と、 「最初の人と違う数である場合の数」を考えればよいのではないでしょうか？ これなら順々に計算できそうです。 というわけで、DPします。 $dp[i][j] := i人目が状態jであるような場合の数$ とします。ここで、$j=0$は一人目と同じ数字、$j=1$は一人目と違う数字であるとします。 初期値は、 $dp[0][0] = M$, $dp[0][1] = 0$となります。 漸化式は $dp[i][0] = dp[i-1][1]$ $dp[i][1] = (M-1) * dp[i-1][0] + (M-2) * dp[i-1][1]$ となります。 これをあまりを取りながら計算して、$dp[N-1][1]$が解になります。 DP難しいよ〜 提出 終わりに 最近緑になれましたーヤッター 競技プログラミング死ぬほど難しいけどなんとかがんばります。 あと、ICPC出れそうです。そっちの方も適当にがんばります。"
  },
  {
    url: "/post/katex/",
    title: "KaTeX導入してみる",
    date: "2023-06-23T00:00:00Z",
    body: "KaTeX導入してみる KaTeXを使ってみる $\\LaTeX{}$風の数式を表示できるJavaScriptライブラリ(らしい)である$\\KaTeX{}$を導入してみました。 本稿では、$\\KaTeX$の紹介と、自分がどうやって導入したかを説明します。 注意！ 筆者は$\\KaTeX{}$及び$\\LaTeX{}$に全く詳しくありません。 内容がガバガバかもしれないです。 使い方 ここに丁寧に書いてあるので、こっちを参考にしてください。 私は手元で動かしたい人向けにリポジトリから窃盗する手順だけ紹介します。 リポジトリはこちらです。 アクセスするとこんな画面になるはずです。 右下の方のReleasesの中のlatestがついてるやつをクリックしましょう。 こんな画面になるはずです。(私が作成してるときはv0.16.7でした。) tarballかzipをダウンロードして解凍しましょう。 こんなファイル群が出てくるはずです。 これらをhtmlファイル内で読み込めば使用できます。 下は実際にこのページで使用されている設定です。 (上で貼ったページのものをちょっぴり差し替えただけです。ファイルパスは自分の環境に合わせて変える必要があります。) \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;../katex/katex.css\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;../katex/katex.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;../katex/contrib/auto-render.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { delimiters: [ {left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true}, {left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false}, ] }); }); \u0026lt;/script\u0026gt; 数式のフォントサイズが気に入らなかったら、head内に次を足してください。(数字はお好みで) \u0026lt;style\u0026gt; .katex { font-size: 1em !important; } \u0026lt;/style\u0026gt; もしくはdivとかの中だけフォントサイズをいじるっていう方法もあります。 KaTeXテンプレート $\\KaTeX{}$を使うときは、インライン数式なら$で囲みます。 行単位なら$$で囲みます。 そうしないとうまく動かないです。 基本の使い方は$\\LaTeX{}$と同じなので、$\\LaTeX{}$記法はググると良いです。 よく使いそうな数式を紹介します。 行番号あり数式 $$ \\begin{equation} \\int_0^{2\\pi{}} \\sin{}x dx = 0 \\end{equation} $$ $$ \\begin{equation} \\int_0^{2\\pi{}} \\sin{}x dx = 0 \\end{equation} $$ 複数行に渡る数式(行番号一つ) $$ \\begin{equation} \\begin{split} \\sum_{k=0}^{n} {}_n \\mathrm{C}_k \u0026amp;= {}_n \\mathrm{C}_0 + {}_n \\mathrm{C}_1 + \\dots \\\\ \u0026amp;= 2^n \\end{split} \\end{equation} $$ $$ \\begin{equation} \\begin{split} \\sum_{k=0}^{n} {}_n \\mathrm{C}_k \u0026amp;= {}_n \\mathrm{C}_0 + {}_n \\mathrm{C}_1 + \\dots \\\\ \u0026amp;= 2^n \\end{split} \\end{equation} $$ デカ括弧 $$ T = 2\\pi{} \\sqrt{ \\frac{h}{g} \\left( 1+\\frac{2r^2}{5h^2} \\right) } \\left( 1+\\frac{\\theta{}^2}{16} \\right) $$ $$ T = 2\\pi{} \\sqrt{ \\frac{h}{g} \\left( 1+\\frac{2r^2}{5h^2} \\right) } \\left( 1+\\frac{\\theta{}^2}{16} \\right) $$ なお、絶対値やその他の括弧も基本上の例に従う。 インラインデカ数式 通常 $\\frac{a}{b}$ $\\sum_a^b$ $\\int_a^b$ デカ $\\dfrac{a}{b}$ $\\displaystyle\\sum_a^b$ $\\sum\\limits_a^b$ $\\displaystyle\\int_a^b$ $\\int\\limits_a^b$ 通常 $\\frac{a}{b}$ $\\sum_a^b$ $\\int_a^b$ デカ $\\dfrac{a}{b}$ $\\displaystyle\\sum_a^b$ $\\sum\\limits_a^b$ $\\displaystyle\\int_a^b$ $\\int\\limits_a^b$ これはinline表示をdisplayモードに矯正するコマンドです。一番適したものを使いましょう。 単位をつけるために微妙に間あけるやつ $1.0\\,\\mathrm{m}$ $1.0\\,\\mathrm{m}$ 数式環境下での立体は基本的に\\mathrm{}を使っておけば良い。 $\\KaTeX{}$が対応してるかなどは知らないが、 物理単位などによっては組み込みやパッケージ等でより良いものが用意されていることがあるので、 それらを調べてから使うとなお良い。 終わりに あくまでテキストベースなの良いですよね。($\\TeX{}$記法が再利用性が高いかは置いておくとして) ただ、思ったより色々と大変でした。 特に、markdownのパースのせいで$\\KaTeX{}$が崩されたりするのはかなり罠だと思います。 個人的な使い方としては、htmlに変換した後厳重にチェックした後放流するって感じになりそうです。"
  },
  {
    url: "/post/abc99c/",
    title: "ABC99C - Strange Bank",
    date: "2023-06-13T00:00:00Z",
    body: "ABC99C - Strange Bank はじめに 個人的に比較的難しく、教育的な動的計画法の問題に出会ったので、メモを残しておく。 防備録的な色合いが強いので、私にとって明らかなことは書かない。 問題 ABC99C Strange Bank 思考 もし仮に、6冪の金額のみを用いることができるという制約なら単純な6進数変換の問題である。 しかし、本問では9冪の金額も用いることができるため、最適解が自明な貪欲法でない可能性が高い。 例えば、 「6冪と9冪のなかで今の金額に一番近い値を採用し、それを続ける」 という貪欲法を考える。 実はこの貪欲ではテストケースすら突破できない。(確認済み) 貪欲で解ける可能性が低そうなので、次に全探索を考えてみる。 自明な全探索は、log_6(N)ビット6進数とlog_9(N)ビット9進数によるビット全探索だと思われる。 計算量はO(6^{log(N)}9^{log(N)}) これは明らかに間に合わない。(実は少し工夫した全探索による解法が存在するので後述する) 解法 一回引き出したら口座に戻せないという制約上、部分問題に分割することができる。 すなわち、x円を引き出す最小手順がわかっていれば、もう少し大きな金額yに対して、y円を引き出す最小手順がわかる。 このことに気づくのは比較的用意だと思う。 さて、部分問題を精査していく。 私は次に述べる点に気づかなかったため、動的計画法を構築できなかったのだが、具体的な遷移は「1手前」を考えるだけで良い。 私はずっと、6冪と9冪が使えるということは、「6冪と9冪に引っかからないけど6や9の倍数である数」への遷移を毎回考える必要があると思いこんでいた。 つまりは、 dp[x]を計算するときに、min(dp[x-6]+1, dp[x-12]+2, dp[x-24]+4, ...)というようなことをしなければだめだと思っていたということだ。 しかし実際は、dp[x-12]やdp[x-24]の値はdp[x]に到着する前に計算されており、更にそれを織り込み済みでdp[x-6]が計算されている。 つまり、遷移のときに気にする必要があるのは1回で引き出せる金額の更新だけなのである。 結論として、 dp[x] = min(dp[x-diff]) (diff := {x | a \u0026lt;- N, 6^a, 9^a}, k \u0026lt; 0 (dp[k] = infinity), dp[0] = 0) という遷移で計算可能である。 ある金額xに対して、高々logN通りの更新候補が存在するため、計算量はO(NlogN)で抑えられる。 また、全探索でも解くことができる。 「任意の引き出し方は、6進数成分と9進数成分に分解できる」 という事実を用いると、引き出す金額を2つに分割して、6進数/9進数表現に直したときのビットの総和が候補値になる。 分割の全探索がO(N)、各ケースO(logN)でx進数に変換できるから結局O(NlogN)で解くことができる。 上で述べた自明な全探索よりも少し工夫が入っている。 どちらが難しい解法かと言われると微妙だが、個人的には部分問題に分けるほうが自然かなと感じる。 追記 上の遷移式におけるNは、自然数全体の集合です。また、\u0026lt;-は集合の元であることを示す記号です。 提出 参考文献 けんちょんさんによる解説 動的計画法について"
  },
  {
    url: "/post/abc304/",
    title: "ABC304参加記録",
    date: "2023-06-05T00:00:00Z",
    body: "ABC304参加記録 はじめに 競技プログラミングに対してやる気がわかない夜は、コンテストの参加記録を書こう。 そうしよう。 というわけで、ABC304の参加記録です。 戦績 残念ながらジャッジにトラブルがあったようで、今回のコンテストはunratedになってしまいました。 そのため特にレート変動はありません。 今回の提出結果はこちらです。 AからEまでの5問正解することができ、全部で3ペナルティ食らいました。 問題と解法 コンテスト中にACできた問題についてかるーく振り返ります。 A - First Player A問題です。難しかった\u0026hellip; やること自体は簡単(に理解できるもの)ですが、この問題プログラミング始めたばっかりの人結構大変なんじゃないんですかねとか思いました。 この問題は剰余演算を用いることで簡単に解くことができます。 具体的にはx番目に最年少の人が来たとするとき、0\u0026lt;=i\u0026lt;=N-1であるiを用いて(x+i)%N番目の人の名前を出力することでACできます。 要はインデックスの余りをとってあげることでちょうどテーブルを一周できるわけです。 これよりもシンプルで初心者向けの解法が思いつきません。 提出 B - Subscribers 見た目がヤバいですね。ちなみに実際ヤバいです。 私の脳裏にこれが思い浮かびました。 「切り捨てる」という操作を、「元の数から、元の数を10^x^で割った余りを引く」という操作に置き換えます。 これを頑張ってifやswitchなどで場合分けするとACできます。 途中で混乱しないようにしましょう(1敗) これWA出たとき台パンしそうになった() あと関係ないですが、この問題名が「Subscribers」になっているのはYoutubeの登録者数表示に準拠してるのかな？とか思ったり(知らんけど) 提出 C - Virus これもなかなか難しい！ AtCoder Problems上で確認したところ、difficultyは366らしいです。 まず、制約を見ます。 割と制約がゆるそうなので、雑な全探索が通りそうな気がします。 ある感染者から感染する人を探したいとき、自分自身以外のN-1人を1回ずつ見れば十分なことが分かります。 また、探索の基準にする感染者をいちいち記録しておかなければいけません。 そこで、キューを使ったアルゴリズムを考えました。 キューに人1を入れる。 キューから人を取り出し、その人に対して、「調べ済み」の印をつける。 「調べ済み」のしるしがついていない人で、キューから出した人との距離がD以下の人を見つけたらその人に「調べ済み」の印をつけてキューに入れる。 キューが空でなければ手順2に戻る。空なら手順5に進む すべての人について、「調べ済み」の人はYes、そうでない人はNoを出力する。 よくよく見るとこれは「距離がD以下の人同士で無向辺をつないだグラフのBFS」とみなせます。 解いてるとき全く気付かなかった。。。 グラフとして見れたらもっと早く処理できたかもしれないなぁと思います。 提出 D - A Piece of Cake これ、難しくないですか？？？ 私は結構苦戦しました。 まず、制約を見た感じ長方形領域を一つ一つ見ていく方法は絶対に不可能なことが分かります。 ということで、「同じ領域に存在するイチゴならば同じ情報になる」というような情報の圧縮を考える必要があります。 逆に言うとイチゴの数はそこまで多くないわけですから、そのような圧縮が存在すれば簡単に解けるということです。 結論から言うと、「ケーキを切り分ける直線のインデックス」を用いるとうまくいきます。 例えば、一つのイチゴに対して順序対(X, Y)を以下のように定義します。 X := (イチゴのx座標よりも小さい最小のaのインデックス) Y := (イチゴのy座標よりも小さい最小のbのインデックス) 一つ注意として、制約が0 \u0026lt; a, bなのでa, bの配列の先頭に0を追加しないと上の定義ができません。 私は0を追加して解きました。 このようにすると、同じ領域に存在するイチゴは同じ順序対が割り当てられます。 あとはこれらを連想配列などで管理します。 mを求めるときにも少し注意する必要があります。 上の方法では切り分けた領域をすべて見ているわけではないので、一つもイチゴが乗っていない領域が存在するかどうかが分からないという問題があります。 これは、(連想配列の登録数)と(A+1)*(B+1)の大小関係で確定させることができます。 後者がより大きい時は必ずイチゴが乗っていない領域が存在します。 ということでACをとることができます。 提出 E - Good Graph なんか奇跡的に解けた問題です。 「頂点x_iとy_iを結ぶパスが存在しない」という条件は、まさしくx_iとy_iが連結でないということを示しています。 そのような予想の元、クエリにどうこたえるかを考えてみます。 頂点p_iとq_iを結ぶことでよいグラフが崩れるかどうかを判定するということは、 p_iとq_iの所属する連結成分が分かれば判定可能です。 具体的に言うと、あるjに対して、p_iとx_jが同じ連結成分に属していて、かつq_iとy_jが同じ連結成分に属していたらだめですね。 グラフGのそれぞれの連結成分を、ある代表元を用いて管理することで上の判定問題を高速に解くことができます。 \u0026hellip;はい、まんまUnion-Find Forestです。 具体的な解法としては以下のようになります。 グラフの連結成分を構築。 x_iとy_iの代表元を見つける。それをX, Yとして、(X, Y)と(Y, X)を連想配列などに追加しておく。 p_iとq_iの代表元を見つける。それをP, Qとして、(P, Q)が連想配列に登録されていたらNo、されていなければYesを出力する。 このようにしてACできます。 最近Union-Findもといdsuを用意したので、ドンピシャで使いどころが来てくれてなかなかうれしいです。 ただ、私のUnion-Findやたら動作が遅いのですごく心配です。 経路圧縮とUnion by sizeやってるはずなんだけどなぁ 提出 終わりに 最近D問題とかE問題が解けるときがあってうれしい！ 引き続き競技プログラミング(というかAtCoder)に取り組んでいきたいと思います！ ここまで読んでいただきありがとうございます。 それではまた次のエントリで。"
  },
  {
    url: "/post/mmacontest15/",
    title: "MMA Contest 015 参加記録",
    date: "2023-06-01T00:00:00Z",
    body: "MMA Contest 015 参加記録 はじめてのオンサイト、行ってキタ！ 電気通信大学にはMMAという格闘技みたいな名前のサークルがあります。 先日2023年5月28日、そのサークルの有志がオンサイトコンテストを開いていたので、(ヒマなので)参加してきました！ MMA Contest 015というオンサイト競技プログラミングコンテストを開催します！ 大学HPにもリンクを貼ってもらうことができました��� 教室は200人が余裕で入る教室のB202で実施します。 まだまだ参加枠に余裕があるので、参加登録お待ちしております！https://t.co/Jrqil1Yvpg \u0026mdash; 電気通信大学 MMA (@uecmma) May 8, 2023 明日，東京都調布市にある電通大でレート不問初中級者向け予選なし誰でも来てくれオンサイトコンテストを開催します！ コンテストページはYukicoderを使います．まだ間に合うので明日あいていればお越しください～https://t.co/0lkHO7Xeb8 \u0026mdash; Nafmo@固定イベント (@Nafmo2) May 27, 2023 参加した感想(?) コンテストが行われた教室は、電気通信大学の中でもかなり大きい方の教室だったのですが、思っていたよりもたくさん人がいてびっくりしました。 また、僕よりも若い方から社会人の方まで様々な方がいらっしゃったそうです。 すごい非日常感で面白かったです。(小並感) その日にARCがあるということと、参加者に知り合いが一人もいないという事情から終了後即帰ってしまったので、 他の方がどのような交流をしていたのかよくわかっていませんが、とても楽しそうな雰囲気でした。 ↑ココです。 初心者向けコンテストと謳っていたものの、私にとって難しい問題が多く、良い練習になりました。 運が良かったのか、12問中5問正解することができ、全体83位で終わりました。 2時間を超えるコンテストは初めてだったので、結構疲れました。 解けた問題の概要と解法 自分が解けた問題をてきとーに振り返ります。 コンテストページ(yukicoder) A - MMA文字列 コンテストが始まった瞬間から会場中「ｶﾀｶﾀ\u0026hellip;」という音が響きだし、結構焦りながら解きました。 シンプルな問題ですが、S[0] == S[1] \u0026amp;\u0026amp; S[1] == S[2]というケースが意外と落とし穴になっています。(1WA) 提出 B - Nafmo、A+Bをする 繰り上がりをしない2進数の足し算です。 私は配列に値を入れて、XOR演算(片方が1、片方が0のときのみ1)をシミュレートする感じで解きました。 注意点としては、文字列Sをbit列と見立てたとき、S[0]はその見た目に反して最上位bitになります。 AtCoderのコンテストの方でこれに気づかずに一生WAしていたことがあるので、今回はしっかり対応できました。 提出 C - Two Countries within UEC 作問のsepa_38さん曰く、「皆さんにWAをお配りするために作りました」だそうです。 クソむずかった\u0026hellip; はじめはC問題ということもあって、ちょっと考えたら解けるだろう！と思って考察していました。 実際、$f$が$x$の倍数であるときにはシンプルになります。 この問題を言い換えると、「xが与えられる。法をPとして$xy=f$であるようなyの個数を求めよ」となるので、 前述のようなケースでは法をPとしてy=f/xであるようなyを求めるだけです。 これは割り算ですぐできます。 しかし、その他のケースについてはどうしても難しいです。 上の条件を更に噛み砕くと、「$x$、$f$が与えられる。ある(0を含む)自然数$k$が存在して、$xy=f+kP$が成立するような$y$を数え上げよ」 という問題になります。 これを変形していって、「$y=(f+kP)/x$が成立するような$(k, y)$の組を数え上げよ」とまで持っていきました。 しかし、これは普通にやったらめちゃくちゃ計算量がかかります。 少なくとも私は全探索以外わかりません。 ということで、方針転換。 もしかしたら逆元というものが使えるのではないか？と考え、google先生に聞きました。 結果、$x$と$P$が互いに素であるとき、 $[0, P-1]$にただ一つの$x^{-1}$が存在して、$P$を法として$x\\cdot x^{-1}=1$である。 という結果を得ました。やった！これならPを法として$y=f \\cdot x^{-1}$(右辺は整数)が成立するようなyを数え上げる問題に帰着できる！ ということで実装します。 とはいっても逆元なんて使ったことなく、 実装方法よく知らなかったので、ネット上に落ちてたc++のコードをD言語で動くように改造して無理やりACしました。 なんかふぇるまーのしょうていり(？)を使っているそうです(バカ) また、$x$と$P$が互いに素でないとき、任意の$y$に対して友好度が0であることに気をつける必要があります。 modpow関数をバグらせまくってかなりペナを喰らいました。 提出 D - Skill Tree 問題文がゴツくて一瞬ビビりましたが、理解してしまえばそこまで複雑なことを聞いていないことがわかります。 ポイントは2つです。 ある技を覚えるために、事前に覚えておく必要のある技がある。 ある技を覚えるために、一定のレベルに達している必要がある。 これは技を覚える順番に依存関係があるということです。 グラフ表現に落とし込むことで機械的に処理できそうな感じがしますね。 まず、有向グラフを構築します。 技一つ一つを一つのノードと見て、その技を覚えることでアンロックされる技へと有向辺を張ります。 まずは覚えられるかどうかをどう判定するか考えます。 最初に覚えているのは技1のみであるので、ある技が習得可能な必要十分条件は、 技1を含む連結成分にその技が含まれていることです。 これはdfsなどを用いて簡単に判定できます。 また、ある技を覚えるために依存している技はちょうど1つです。 つまり、技の依存関係は一本道になり、分岐しません。 この性質から、技を覚える必要コストも容易に算出できます。 (ある技を覚えるために必要なレベル)=max((それが依存している技を覚えるのに必要なレベル), (それ自身を覚えるために必要なレベル)) というように、一種の動的計画法のように計算することができます。 これでクエリ2に答える目処が立ちました。 残りはクエリ1です。 まず愚直に考えます。 これを判定するには、技1のノードから順番に技を見ていって、 初めてxを超えるコストを持つノードについたときに今までたどったノードの数を答えることで達成できます。 換言すると、「技を覚えるためのコストを昇順に並べたとき、xは列の何番目に入りますか？」というものです。 よって、配列にコストを全部入れてソート→xの入る位置を2分探索で求めるという操作で答えることができます。 計算量は言及しませんが、これで十分高速に動作し、ACが取れました。 クエリ1の解法が面白かったです。 提出 E - Factorial to the Power of Factorial to the\u0026hellip; 見た目がゴツい！ 怖すぎる！ さて、まず指数部分がデカすぎてよくわからないので、条件を弱めた問題を考えます。 「N!はPで何回割れますか？」 という問題は典型問題で、ルシャンドルの定理を用いて解くことができます。 さて、残りの問題を考えましょう。 N!をx乗するとき、明らかにN!の素因数の個数はx倍になります。 (明らかにと言っていますが、私の中ではココが一番の山場かなと思います。) そこで、答えは上の問題の答えを$N!^{N!}$倍したものになります。 $N!:=N \\cdot (N-1) \\cdot (N-2) \\cdot (N-3) \u0026hellip; 2 \\cdot 1$であるから、指数部分をほぐすことができて、 $N!^{(N!)} = N!^{(N \\cdot (N-1) \\cdot \u0026hellip;2 \\cdot 1)}$ $= N!^{N^{{N-1} \\dots ^{2^{1}}}}$ となります。(二番目の変形は指数法則を用いています。) N乗の計算は繰り返し2乗法で高速にできるので、これで$N!^{N!}$を$O(NlogN)$で求められました。 というわけで適宜余りをとっていけばACになります。 ABCのD問題に出そう！解けてｳﾚｼｲ\u0026hellip; 提出 終わりに コンテスト面白かったです。また開催してほしい\u0026hellip; 参加記録の更新をずっとサボっててごめんなさい。 更新をサボっている間にメイン言語を切り替えたり、longest streakでトップ1000に入ったり、400ACカウント達成したり、色々ありました。 最近は大半をmarkdownで書いてサボっているので、もっと更新できたらなと思います。 競技プログラミング以外の話題も書きたいとは思っているんですが、なんか面倒くさくてサボってしまいます。助けてくれ。 それでは次のエントリで。"
  },
  {
    url: "/post/abc300/",
    title: "ABC300参加記録",
    date: "2023-05-01T00:00:00Z",
    body: "ABC300参加記録 ABC参加しました。 今回もABC300に参加してきました。 久しぶりに参加記録を書きます。 戦績 まずは、今回の戦績をざっくり振り返ります。 以下は今回の提出です。 今回は時間内にA, B, Cの3問を解くことができました。 また、コンテスト後にD問題を解くことができました。 レート変動はこちらです。 何とかプラスのレートを得ることができました。速く700行かせてくれー 問題と概要 今回解けた問題の軽い解説(?)をしていきます。ざっくりです。 A - N-choice question 問題文は以下の通りです。 問題文に書いてあることをその通りにやります。A+Bを変数に持っておいて、何番目のC[i]と一致するかを見つければよいです。 ループとstdinの扱いができればACできると思います。 提出例です。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int N, A, B; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;N, \u0026amp;A, \u0026amp;B); for (int i = 0; i \u0026lt; N; i++) { int tmp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;tmp); if (tmp == A + B) { printf(\u0026#34;%d\\n\u0026#34;, i + 1); break; } } return 0; } B - Same Map in the RPG World 問題文は以下の通りです。 この問題はB問題のわりにかなり難易度が高かったようで、AtCoder Problems上で400くらいのdiffがありました。 シンプルに言うと文字列の一致判定問題といえるでしょう。 ただし、片方の文字列に対して2つの操作を許されています。 列を一つずつ右にずらす。一番右の列は一番左にワープする。 行を一つずつ上にずらす。一番上の列は一番下にワープする。 サンプルが問題ページに乗っているので気になる人は見に行って見てください。 さて、この問題は十分に制約が緩いので、操作1, 2のすべての組み合わせを行うことができます。 具体的には、操作1をH回、操作2をW回行う2重ループをすることで正誤判定をすることができます。 典型テク「全探索ができるならやろう」です。 C言語での実装例 C - Cross 問題文は以下の通りです。 なかなかいかつい見た目ですね。 少し整理しましょう。 まず、問題文において「サイズnのバツ印」は(ざっくり)以下のように定義されています。 あるマスが#で、斜め4方向にn個の#が隙間なく続いている。 斜め4方向にn+1こ#が続いてはいけない。(これを許すとサイズ1~nのバツ印とn+1のバツ印が被っちゃう) サンプルです。 #...# .#.#. ..#.. .#.#. #...# これはサイズ2のバツ印です。サイズ1のバツ印を含んでいますが、ルール2により却下されます。 .#...# ..#.#. ...#.. ..#.#. .#...# #..... これは一辺だけサイズ3ですが、ルール1によりサイズ2と判定されます。 問題としては、(よくわからんけど)割と親切な文字列が与えられるので、「サイズ1~min(H, W)」のバツ印が何個あるか判定してくださいというものです。 解法としては、あるマスが#だった時にそこを中心としてバツ印がつくれるか？をすべてのマスに対して適用しました。 制約が比較的緩いので、上のルールでも十分動作します。 関数化したらこんな感じです。 int cross_size (int W, int H, int x, int y, char C[][W + 1]) { for (int i = 1; ; i++) { if (W - 1 \u0026lt; x + i || x - i \u0026lt; 0 || H - 1 \u0026lt; y + i || y - i \u0026lt; 0) { return i - 1; } if (C[y + i][x + i] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; C[y + i][x - i] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; C[y - i][x + i] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; C[y - i][x - i] == \u0026#39;#\u0026#39;) { } else { return i - 1; } } } 提出例 D - AABCC 問題文は以下の通りです。 出、出た～！数学問題奴～www なんかNの制約が割と大きそうなので、単純な探索だと厳しいという予想を立てました。 手元のカードとして「エラトステネスの篩」というものがあったので、素数を探索するのは下準備さえあればできるということを考えながら思案。。。 典型テクニック「変数が一つ以外決定されているときを仮定」をやってみると、b以外を固定すればすぐに答えられそうというのがわかる。 また、aとcは大体10^3^~10^6^くらい探索すればよいので二重ループしても間に合いそうだな\u0026hellip;という考えに至る。 求めたNが被ることは\u0026hellip;素数だから多分ヨシッ！ したがって、以下のアルゴリズムを考えた。 エラトステネスで大体10^6^くらいまで素数列挙 a, cをa^2^+c^2^ \u0026lt; Nの範囲で探索、それぞれのケースに対してbをいい感じに数え上げる。 さて、具体的にどうやってやるべきだろうか。 例えばあるa, cに対してbのとりうる最大と最小を考えると、数直線上の閉区間の素数の数を即座に答える必要がある。 アッ！累積和使えるやん！ ということで、あとは実装したら完成。AC取れました。ただし、手順2のbをいい感じにっていうところがちょっと面倒くさいので、ここは丁寧に考える必要あり。 提出例 D問題はコンテスト中に間に合いませんでした。残念。 また、解説を見た感じ、素数の数があまり多くないからエラトステネスからのa, b, cの全探索で解けるそうです。 実際に、やってみた。 全探索の提出例 これは今の私には思いつかないですね。 E - Dice Product 3 何ともならんかったわ。(事後報告) (画像はここから剽窃してきた。) 終わりに まず、一か月くらい記事更新をさぼってしまって本当に申し訳ない。 なかなか記事更新にも時間がかかってしまうというのもありますが、できるだけ参加記録を公開したいな～(願望) 私事ですが、Bootcamp For Beginnersのmediumが終わりました。 あと、longest streakが100日超えてました。 これからも頑張ります。 それではまた次のエントリで。"
  },
  {
    url: "/post/abc296/",
    title: "ABC296参加記録",
    date: "2023-04-03T00:00:00Z",
    body: "ABC296参加記録 ABC参加してきました。 こんにちは。今回のABC296も参加してきましたので、軽い参加記録です。 戦績 今回の戦績についてです。 今回はA, B, Cの3完、パフォーマンス650で、レート変動は627→630(+3)でした。 ギリ勝ちでした。 問題と解法 A~Dの4問の解法を紹介します。 A - Alternately 問題分は以下のとおりです。 男性または女性同士が隣り合っているかどうかを判定する問題です。シンプルに解くなら、文字列長をNとして、1文字目からN-1文字目までのそれぞれに対して以下の判定を行います。 i文字目とi+1文字目が一致しているか？ YES→Noを出力し、プログラムを終了 NO→何もしない この判定をN-1文字目まで行い、それでもプログラムが終了していなければYesを出力しプログラムを終了することで正しく判定することができます。 ほぼ自明な操作なので、文字列操作が適切に行えるならACが取れると思います。 実装例 B - Chessboard 問題分は以下のとおりです。 チェス盤の状態が文字列として渡されるので、コマが存在するマスを適切なフォーマットで出力する問題です。 制約から、コマが一つしかないことがわかるので、いわゆるオンラインアルゴリズムにて解くこともできます。 解法としては、文字列を一つづつ見ていき、*が存在する行番号と列番号を適切に変換すればよいです。注意点として、行数を表す番号は一番下が1番になっているため、出力するときには8-○のような形にする必要があります。 実装例 C - Gap Existence 問題分は以下のとおりです。 任意のi, jを全探索することで解を得ることができますが、この解法では解が存在しなかったときにおよそ10^10程度の探索が必要になります。したがって、この方針ではACを取ることは現実的ではないです。 そこで、次のように問題を言い換えます。「あるA_iに対して条件を満たすA_jが存在するなら、A_j=A_i+Xを満たす。」 つまり、「与えられた配列の中に値がA_i+Xと等しいものはあるか？」という問題に変わります。 事前に配列をソートしておくことで配列の中から値を探すという典型問題に落とし込めます。この時、全体の計算量はO(Nlog(N))で抑えることができます。定数倍を考えなければ約10^6回程度の探索で解を得ることができます。 二分探索を自分で実装する場合、この問題のようにキーが配列中に存在しないことも考慮したコードを作成しておくと良いと思います。 実装例 D - M\u0026lt;=ab 問題分は以下のとおりです。 かなりシンプルな問題です。こういうの苦手です。 まずは私が試していたダメな解法を紹介します。 制約から、N*N\u0026gt;=Mならば、-1ではない何かしらの解が存在します。なぜなら、N*Nが解の候補の一つだからです。 そこで、まずN*N\u0026lt;Mとなるようなケースはすべて-1を出力して終了。それ以外のケースについて考えることにします。 解となる可能性があるXに対して、両方がN以下となるような因数分解を見つける方針で考えます。まず、Xの範囲を絞ります。仮定から、M\u0026lt;=Xです。 色々考えた結果、Xの上界は「M以上になるもののうち最小の平方数」であることがわかりました。理由は単純で、この値を上界とする時明らかにN*N以下となり、少なくとも「その平方数」が解の候補になるからです。 以上より、M\u0026lt;=X\u0026lt;=(平方数)に対して、2つともN以下になるような因数が存在するかを判定する問題になりました。 ここからは単純に、「Xの平方数に一番近い整数」からX=1になる、または割り切れるまで「Xを」順番に試し割をすればよいです。こうすれば2数の差が一番小さくなるような因数分解ができます。 試し割りで見つかった因数が両方N以下ならXを出力して終了、そうでないならXを1増やして同じことをすれば良いです。 この解法は正しく動作しますが、 制限時間内に終わりませんでした。結果としては10ケースでTLEが出てしまい、コンテスト中に通せませんでした。 雑な計算量解析をすると、まず私の絞り込んだXの範囲が、最悪ケースのときに連続する平方数の差とほとんど同じになります。これは(a+1)^2 - a^2 = 2*a + 1程度です。制約から、aは最大で10^6程度までありえます。そして試し割りは最悪ケースのとき、つまりXが素数の時には√X回程度かかります。流石に素数が密集しているとは思えませんが、平均的に見て√Xの定数倍程度になっているだろうと予想できます。これも10^6程度までありえます。以上より、最悪ケースのときには十分10^8回程度を超える計算が行われる可能性があります。 (ダメな方の)実装例 さて、この問題を解くためには別のアプローチが必要になります。 まず、重要な事実は次の2つです。 解となる可能性のあるX=abに対して、a\u0026lt;=bを仮定すれば因数aの上界は10^6である。 あるaを一つ定めると、解となる可能性のあるbはただ一つ存在する。 それぞれについて検討していきます。まず1つ目です。制約より、M\u0026lt;=10^12となりますから、Xの因数a,bがどちらも10^6であれば、それは必ず解の候補になります。また、a,bどちらも10^6を超えるようなケースは存在しません。a=b=10^6がより優れた解の候補だからです。 2つ目に対しては、あるaに対して、a*bがMを超えるようなbのとり方は無数に存在しますが、解となり得るのはそれらのうち最小のものだけです。つまり、一つのaに対して必ず条件を満たしうるbが一つだけ存在します。 以上より、以下のアルゴリズムにてO(1)で解くことができます(10^6程度で抑えられるという意味です。)。 最初、a=1とする。解はans=-1としておく a*bがM以上になるような最小のbを求める。具体的にはM%a=0の時b=M/aで、それ以外のときb=M/a+1となる。 a\u0026gt;bとなっていたらansを出力し、プログラムを終了する。 b\u0026lt;=Nならばans=min(a*b, ans)とする。 aを1増やし、2に戻る 私の解法が、「Xの取りうる値に対して、条件を満たすように因数分解できるか？」だったのに対して、こちらの解法は「解になり得る因数を全探索する」というような解法になっています。Xを構成的に見つけていくことで、各aに対して数回の演算でbを求めているのが高速化に寄与している点だと思いました。 この問題から学べる教訓としては、 復数の変数が出現する問題では、ある一つ以外の変数が事前に定まっているという仮定のもとでなにか得られないか考えてみる。 できるだけ天下り的ではなく構成的に考える。 暗に大小関係を定めてしまえば探索範囲の重複を防ぐことができる(ことがある) と言ったところでしょうか？次出会ったら解けるようになりたいですね。 実装例(ほぼ公式解説の通り) 終わりに 今回の参加記録はここまでです。読んでいただきありがとうございます。 最近4完がほぼできておらず、大体茶色MAXdiffあたりから解けるかどうか怪しくなっているような感じです。早いところそのあたりの難易度帯の対策もしたいですね。 サラッと先週分サボってごめんなさい。やる気があったらD問題だけでも記事書きます。 あと、現在私のC言語ライブラリのサイトをgithubで構築中です。近いうちに宣伝するかも？(宣伝の宣伝) ではまた次の記事で"
  },
  {
    url: "/post/abc294/",
    title: "ABC294参加記録",
    date: "2023-03-21T00:00:00Z",
    body: "ABC294参加記録 ABC294に参加しました。 こんにちは。今週もABC294に参加してきましたので，その参加記録です。 戦績など まずは，今回の戦績です。 A, B, C, Dの4完でした。今回のパフォーマンスは626で，レート変動は633→632(-1)でした。 実は今回コンテスト開始に少し遅れてしまいました。それも相まって少しパフォーマンスが下がってしまいました。今回のE問題が普段に比べて簡単だったので5完チャンスだったのですが，少し間に合いませんでした。 問題の紹介 今回はコンテスト後にACをとることができたE問題まで紹介します。 A - Filter 問題文はこちらです。 この問題は，標準入力を適切に扱えるならすぐに解くことができます。制約も特に厳しい部分がないので，単純に一つずつ入力を受け取っていくときに，偶数ならそのまま出力することでACをとることができます。重複を考える必要も無いようです。 ACコード B - ASCII Art 問題文はこちらです。 この問題は，二次元配列やそれに準するデータ構造を使えるかを問うもののように見えます。計算量などは気にする必要がなさそうなので，入力を受け取り問題文の操作を適切に行うことでACをとれます。 C言語なら二次元配列を利用するのが一番自然です。char A[H][W]のような配列を宣言して，二重ループで入力の受け取りと出力をします。 A~i,j~番目の大文字アルファベットはASCIIコードの性質を利用することで簡単に出力することができます。ASCIIコードにおいて，大文字アルファベットはAから昇順に数値が割り当てられてあります。したがって，printf(\u0026quot;%c\u0026quot;, A[i][j] + 'A' - 1);のような形で実現することができます。(よくわからないという人は，C言語のprintfとASCIIコードについて調べてみるとよいと思います) W個出力するたびに改行するのを忘れないようにしましょう。 また，二次元配列を使用するのが自然といいましたが，実は使用しなくても解くことができます。各入力をどのように置き換えるかはそれぞれの入力のみで決まり，ほかの入力のことを考慮する必要がありません。つまり，受け取った数が0なら即座に.を，それ以外なら'A' - 1を足したものを文字として出力すればよいです。 ACコード C - Merge Sequences 問題文はこちらです。 少し問題文を要約します。「二つの数列が与えられる。これらの要素をひとまとめにして，昇順に並べ替えた数列を作る。元の数列のi番目の要素は，新しく作った数列の何番目にあるでしょう？」という感じです。 制約から，要素のダブりはないです。したがって，求めたいもの(何番目か)はただ一つに定まります。シンプルに行くなら新しく作った数列を最初から順番に見ていき，等しくなった時にインデックスを出力すればACをとれるはずです。 ただしこのやり方では時間が間に合いません。最悪ケースを考えてみると分かりやすいです。元の二つの数列をA, Bとするとき，もしBの要素がAのどの要素より大きいとすると，結合して並べ替えた数列においてBの要素を探すときに必ずAの要素数分の無駄な探索が行われます。制約から，元の数列の要素数は10^5^個まであり得るので，このようなケースではBの要素を探そうとすると10^10^程度の操作が必要になります。どう考えても間に合いません。 ここで，新しい数列が整列済みだという事実を利用します。このようなときには二分探索をすることができ，一つの値を高速に探すことができます。知らなかった人は覚えておくとこの先役に立つと思います。 二分探索は要素数nに対して，およそlog(n)程度の計算量で値の探索をすることができます。また，全体をソートするためにおよそnlog(n)程度の計算量がかかります。以上より，nlog(n)程度の計算量で解くことができます。これは今回の制約下の最悪ケースで10^6^超えるかな～っていう程度です。 ACコード(前半は私のお手製ソート関数群です) また，元の数列が整列済みだということを利用して，マージソートをするような感じでn + m程度の計算量でACをとることができるようです。(あえてACサンプルは載せません) D - Bank 問題文はこちらです。 よくあるクエリを処理するやつです。今回は銀行の待合のアレみたいな問題です。 各クエリの処理方法を考えましょう。クエリ1はまだ呼ばれていない人のみが対象なので，単純にクエリ1が来た回数が分かればO(1)で答えることができます。クエリ2は実際に人が受付に向かう操作です。これ以外のクエリで受け受けに向かうことはないです。クエリ3は呼ばれている人のうち番号が一番若い人を再度呼び出すクエリです。 明らかにクエリ2, 3の処理が面倒くさそうです。簡単な解法を考えると，クエリ1で呼ばれた番号を集めておき，クエリ2で呼ばれたら削除，クエリ3が来たらその集合の最小値を出力すればよいです。これをシンプルに実装するなら順序付きの集合のようなデータ型を用いるのが良いです。(解説ではstd::setを勧めていました)なぜなら，指定した番号のデータに対して削除と最小番号の出力を同時にこなす必要があるからです。(キューや連想配列などだとどちらかの要件が面倒くさいです。) 私は少し違う方法をとりました。まず，制約からNの上限がそこまで大きくないので，全部配列に載せることができます。したがって，順序付き集合の代わりに配列を使用することができます。具体的にはこうです。要素数Nの配列を用意しておく。クエリ1は呼ばれた回数を出力，クエリ2が呼ばれたら配列のx番目に-1などを代入しておく。クエリ3が呼ばれたら-1の入っていない最小インデックスを出力する。この時，-1の入っていない最小インデックスの位置を常に保持しておくことで，クエリ3をO(N)で求めることができます。(O(N)と言っていますが，一回通過した場所には戻らないのでクエリ3のすべてを処理したとしてもN回以下の操作で答えることができます。)実はこの方法は上の解法と同等以上に高速です。 ACコード E - 2xN Grid 問題文はこちらです。 連続文字列が(数字)(長さ)という風に圧縮されている，元の長さLの文字列2つに対し，同じ位置で同じ数字が存在する場所の数の総和を求める問題です。 ランレングス圧縮...ってコト！？ シンプルな問題ですが，この文字列をそのまま復元しようとすると，元の文字列長が長すぎてTLEします。(というか普通にメモリも使いすぎると思います。)したがって，何らかの方法で圧縮を戻さずに解を得る必要があります。 正直私にとって少しレベルの高い問題だったので，すっきりした解法ではないかもしれませんが，一応紹介します。 私はいたちごっこをしながらシュミレートする方法で解くことができました。まずは，各数字と圧縮長さをそれぞれv1[n1], len1[n1]とv2[n2], len2[n2]に格納します。 そしてn1のインデックスをi，n2のインデックスをjとします。基準点baseを最初0にしておきます。そして以下のアルゴリズムで解きます。 現在の総和sum1, sum2を用意し，最初にlen1[0], len2[0]を入れておきます。答えをans=0とします。 v1[i]==v2[j]ならば「sum1とsum2のうち小さいほう - base」をansに足す。 sum1 == L \u0026amp;\u0026amp; sum2 == Lならばansを出力し，終了 baseをsum1とsum2のうち小さいほうで更新し，より小さいほうにlen〇[△ + 1]を足し，△ += 1としてインデックスを更新する。 2に戻る。 下にこのアルゴリズムの簡単な図解を載せておきます。元画像はAtCoderのコンテストページからお借りしました。 正直難しかった(小並感) ACコード 完走した感想 今回は4完でしたが，少しだけレートマイナスになってしまい残念です。今自分が使えるデータ構造が配列しかないので，今回のような問題に対応するためにもいくつかライブラリを整備しておこうかなと思いました。 あと地味に私は二分探索を書くのが下手だということが分かったので，実装について少し研究したいなと思っています。 コンテスト関係ないですが，今回のエントリ書くの結構時間かかりました。疲れた。 それではまた次回のエントリで"
  },
  {
    url: "/post/abc293/",
    title: "ABC293参加記録",
    date: "2023-03-17T00:00:00Z",
    body: "ABC293参加記録 ABC293参加してきました。(今更感) もっとエントリ更新に力を入れると言っておきながらABC292の分をサボってしまいました。ABC293からすでに6日くらい経過していますが、一応有言実行ということで参加記録です。(すまんかった) 総評 今回の戦績です。 A, Bの2完でした。パフォーマンス375、レート変動553→535(-18)でした。 結果だけを見ると正直結構やらかしてしまったなという感じですが、ほとんど理解していないアルゴリズムが問われているので当然の帰結だと思います。あと、これで3週連続冷えなのでじわじわレートが下がっています。 問題など 今回は解けてはいないけどC問題まで紹介します。 A - Swap Odd and Even 問題文はこちらです。 操作によって文字列長が変化しない上、制約も優しいので普通にシュミレートすれば解けます。C言語等を使っている人はバッファオーバーランに気をつけましょう。この問題の制約下では文字列長が偶数になることがわかっているのでループ変数に2を加えていく方針でACできます。バッファオーバーランに気をつけるなら、操作に使う変数とループ変数を分けるのが良いでしょう。 ACコード B - Call the ID Number 問題文はこちらです。 こちらも基本的には言われたとおりにシュミレートすれば解ける問題になっています。ただし、A問題と比べて複雑になっているので注意深く問題分を読むべきだと思います。 「すでに番号を呼ばれた人」は割り当てられた番号を読み上げることができないので、これをシュミレートするために以下のような実装が考えられます。 人iが呼ぶ番号Aiを配列に格納する。(配列のi番目に人iの情報を入れる) 配列を最初から順に見ていって、「その要素番目」にある要素を-1(インデックスとして無効な値なら何でも良い)で上書きする。 最後にもう一度最初から見ていって、要素が-1になっていない人がまだ呼ばれていない人で、これはすでに昇順になっています。 配列が強すぎる ACコード(前半はソート関数郡です。(必要なかった)) C - Make Takahashi Happy 問題文はこちらです。 経路上に存在する数字がかぶるかどうかを判定するためには、すべての経路を具体的に知っていなければいけません。すなわち、重複順列の全列挙です。そこで、いくつか方法があります。 私の取った方法はbit全探索です。0と1を「右に進む」「下に進む」に対応させることで重複順列をすべて列挙することができます。ビット数はw + h - 2になります。たぶん知らないとできません。 具体的には、最下位ビットの加算を行うたびに全ビットを見ていって、「下に進む」を表しているビットの総数がh - 1に到達したときに求めたい組み合わせの一つになります。高校数学を履修した人にとっては馴染み深い考え方かもしれません。(経路の数を求める問題で出てくるはずです。) pythonやc++であれば、順列の列挙をするライブラリが利用できるはずなので、使い方を知っていればACしやすいと思います。C言語にそんなものはありません。(血涙) ACコード 完走した感想 今回のコンテストはちょうど対策が薄かったところばっかり出てきて中々苦しかったです。特に、組み合わせの列挙は近いうちの目標だったのですが、面倒くさくて放置していました。 D問題はグラフに関する問題が出ていました。まじでグラフをなんとかしないと茶色から落ちそうなのでがんばります。(C言語は動的配列のサポートが薄く、隣接リストを微妙に作りにくいからずっと面倒臭がって放置しています。) 全然関係ないけど200AC超えました。 それではまた次のエントリで"
  },
  {
    url: "/post/abc291/",
    title: "ABC291参加記録 ~ DPお前もう船降りろ ~",
    date: "2023-02-26T00:00:00Z",
    body: "ABC291参加記録 ~ DPお前もう船降りろ ~ はじめに 今週もAtCoder Beginners Contest 291に参加してきましたので、軽く参加記録です。 戦績 今回の戦績は以下の通りです。 A, B, Cの3完で、パフォーマンス439でした。レート変動は571→557です。 D問題ゆ゛る゛さ゛ん゛(大迫真) 問題とか 出た問題紹介します。 A - camel Case 大文字が出現する位置を答える問題です。私の解法では、asciiにおいて小文字を数値表現したときに90を上回ることを利用して判定するというものです。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { char s[101]; scanf(\u0026#34;%s\u0026#34;, s); for (int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if (90 \u0026gt;= s[i]) { printf(\u0026#34;%i\u0026#34;, i + 1); } } return 0; } B - Trimmed Mean バラバラに渡される数値の上からと下からN個を抜いて平均を取るという問題です。おそらく出題意図としては、O(N^2)でもいいからソートを実装してみてというものだと思います。 何らかの手段でソートをかけて、真ん中の3N個のデータについて平均を取ることでACをとれます。私はC言語の標準関数(qsort())を使わずに、自作関数でやってみました。 ACコードはやたらと長いので、実際の提出を載せます。 提出 C - LRUD Instructions 2 二次元座標平面のグリッド上を動き回る人が、二回以上同じ座標に来ることがあるかを判定する問題です。 正直結構悩みました。一番先に思いついたのは、訪れた座標をキーにして、連想配列に入れることです。pythonなどの組み込みのデータ構造がリッチな言語なら多分この方法でやっていました。 残念なことに、現状C言語で私がすぐに利用できる連想配列はないため、他の方法を取りました。 しばらく唸っていると、同じ座標を訪れるということは、訪れた座標をすべて記録しておき、ソートをかけることですぐに判定できるのではないかという天啓が訪れます。早速実装しましたが... 座標のxとyでソートをかけると、片方のソート結果までぐちゃぐちゃにされることを忘れていました。対策として、一旦xでソートをかけてから、xが同じ奴らに対してyソートをかけるように修正したら通りました。というわけで以下AC提出です。(やたら長いのでこちらも提出で) 提出 D - Flip Cards 2^Nの組み合わせの中から条件を満たすものの数を考える問題です。制約から明らかに全探索したら間に合いません。(原理的にはbit全探索すれば解けますが)というわけで何らかの簡略化を行う必要が出てきます。 組み合わせ + 全探索だと不可能 ← これ大体DP説 というわけでDPの線を疑いながら考えました。結果... 典型dpの攻略は春休み中の課題の一つです。がんばります... 解説に「配るDP」とか書いてあってビビっちゃいました。くやしいので解けたら別記事建てるかもしれません。 終わりに 参加記録は以上です。ここまで読んでいただきありがとうございました。 レートはモチベーションの一つではありますが、レートによってモチベーションが下げられるのはもったいない気がするので、今回の失敗はなかったことにしときます。春休み中に緑行けるといいなぁって思っています。それでは次のエントリで。"
  },
  {
    url: "/post/abc290/",
    title: "ABC290参加記録",
    date: "2023-02-21T00:00:00Z",
    body: "ABC290参加記録 ABC290参加した。 お久しぶりです。最近AtCoderコンテストの参加記録をサボりがちなので、流石にエントリを生成します。 今週行われたToyota Programming Contest 2023 Spring Qual B（AtCoder Beginner Contest 290）は、どうやらオンサイトのコンテストに向けての予選を兼ねているそうで、希望者は好成績を出すことができれば3/18日に行われる決勝イベントに招待されるそうです。なんかすごいですね。 まあ私はそんな実力には程遠いので、いつもどおり参加してきました。 成績とか 軽く今週の戦績を振り返っておきます。今回はA,B,Cの3完でパフォーマンス611, レート変動511→523でした。 微増ですがまあ勝ちは勝ちなので() あと前回の参加記録からしばらく時間が立っているので、いつの間にか入茶しています。(多分色変記事は書きません) 問題と解法 サラッと流します。今までの記事では結構このパートに力を使っていたんですが、比較的難しい問題などは前回の記事のようなスタイルで記事を立てようかなと思っているので、あまり深入りはしないことにします。 A - Contest Result 問題文はこちら すぬけくんの解いた問題番号は配点のあとに渡されるので、一旦配点はすべて記録しておく必要があります。✙最強のデータ構造✙である配列を用いれば一発です。ただしアクセスするインデックスは一つずれますから気をつけましょう。 C言語的なことを言うとしたら、制約からすぬけくんの総得点はintで大丈夫だし、何なら配点はcharで収まります。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int n, m; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;m); int a[n]; for (int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;a[i]); } int ans = 0; for (int i = 0; m \u0026gt; i; i++) { int tmp; scanf(\u0026#34;%i\u0026#34;, \u0026amp;tmp); ans += a[tmp - 1]; } printf(\u0026#34;%i\u0026#34;, ans); return 0; } B - Qual B 問題文はこちら 予選コンテストにちなんだ問題でしょうか？意外とAtCoderの問題って遊び心のあるものが多いような気がします。 さて、予選を突破するための条件は、「決勝希望者であり、希望者のの中で上位K人である」ことなので、単に上からoのついている人をK人分だけoにして、あとはxにするとオーケーです。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int n, k; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;k); char s[n]; scanf(\u0026#34;%s\u0026#34;, s); int sum = k; int count = 0; for (int i = 0; n \u0026gt; i; i++) { if (sum == 0) { break; } if (s[i] == \u0026#39;o\u0026#39;) { printf(\u0026#34;o\u0026#34;); sum--; } else { printf(\u0026#34;x\u0026#34;); } count++; } for (int i = count; n \u0026gt; count; count++) { printf(\u0026#34;x\u0026#34;); } return 0; } C - Max MEX 問題文はこちらです。 MEXってなんだよ(正論) MEXというものをほとんど聞いたことがなかったので「MEX 数学」でgoogle検索してみましたが、あまりヒットしなかったのでそこまで有名なものでもないようです。 さて、このMEX演算は自明な性質として、「数Xを生成したければ、最低でもX個の元が必要である」というものがあります。本問題ではK要素を抜き出してくるという操作を行うため、どんなに頑張ってもMEX(B)の最大値はKになります。 最大値がそれより小さくなるケースは、「0~K-1に至る途中の数のどれかが一つでも欠けている」というものになります。 以上より、数列Aに0~K-1までの数字がすべて含まれているときに答えはKになり、それ以外のときは「欠けている」最小の数字が答えになります。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int n, k; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;k); char check[k + 1]; for (int i = 0; k + 1 \u0026gt; i; check[i++] = 0) {} for (int i = 0; n \u0026gt; i; i++) { int tmp; scanf(\u0026#34;%i\u0026#34;, \u0026amp;tmp); if (k \u0026gt; tmp) { check[tmp] = 1; } } for (int i = 0; k + 1 \u0026gt; i; i++) { if (check[i] == 0) { printf(\u0026#34;%i\u0026#34;, i); break; } } return 0; } 余談ですが、ARC156にもMEX関連の問題が出ていましたね(全く解けませんでした) D - Marking 結構引っかかった問題なので、(もしやある気があれば)別記事をたてます。 終わりに 参加記録はこれでおしまいです。読んでいただきありがとうございました。 いつかの参加記事でも言及しましたが、最近はAtCoder Problemsが提供しているBoot camp for Beginnersに取り組んでいて、Easyの100問を解ききることができました。また、それに伴ってLongest Streakも50日を達成しました。ヤッター 個人的におすすめなので、みなさんもやってみてはいかがでしょうか？ それと今後の方針としましては、記事更新をもうちょっと頑張りたいな〜とか考えてます。それではまた次の記事で"
  },
  {
    url: "/post/arc155a/",
    title: "精説ARC155A",
    date: "2023-02-07T00:00:00Z",
    body: "精説ARC155A はじめに 先日1月29日にAtCoder Regular Contest 155がありました。ARCのA問題は，ARCがA~Fの6問体制になったARC104から現在に至るまでdifficultyの最大値は緑でした。しかし，今回のA問題は水色でした。 AtCoder Problemsより 現在レート400+程度の私にとって，ARCにおいては一問解くだけでパフォーマンス700+くらいが望めるので非常に「コスパのいい」大会だと思っていたのですが，今回のA問題が思いのほか難しく，一問も解くことができませんでした。 コンテスト後にもう少し粘ってみたら解けたので，(公式解説が思いのほかよくわからないこともあり)解法を残しておくことにします。 問題の概要 問題文は以下の通りです。 要約すると，「与えられた文字列をSとする。この時，Sの前にくっつけてもSの後ろにくっつけても回文になるような長さKの文字列が存在するか？」というものになります。 上の画像はビジュアル化したものになります。 方針 まず制約を見てみましょう。特筆すべき点は，Kがかなり大きくなる可能性があるということでしょうか。また，一つの入力に含まれるテストケースについて，Nの総和が2×10^5以下というのも重要そうです。一つの入力に与えられるテストケースの数が非常に多いからです。 さて，この問題を解くためにどうすればよいのでしょうか？数多くの方針があると思いますが，私はこういう時は最もシンプルな方針を試してみます。この問題に対して最もシンプルな方針は何でしょうか？それは与えられた条件からできるだけ実際にK文字のS'を構成するというものです。 幸い文字列Sは与えられるので，この考え方は試すことができそうです。 シンプルに考えてみる さて，「実際に構成する」といったものの，どのようにすればいいのでしょうか？まずは以下の図をご覧ください。 回文の定義を考えれば，「一番左にある文字」は「一番右にある文字」と同じで，それがずっと続くわけです。つまり，「左から〇番目にある文字」は「右から〇番目にある文字」と同じわけです。 すなわち，問題の題意を満たすような文字列S'が存在するなら，それは与えられた文字列Sの逆順の一部分に他ならないわけです。 さて，ここで一つ疑問がわきます。もし「与えられた文字列」が「構成しようとしている文字列」よりも長かった場合，今言った方法で構成しきることができます。しかし，もしそうでないなら？すなわち，構成しようとしている文字列が与えられた文字列よりも長い時に，残りの部分がどうなるのかを考える必要が出てきそうです。 K \u0026lt; N の場合 まずはややこしいパターンを考える前に，比較的簡単なパターンを処理してしまいましょう。 この時、前述のとおり各ケース実際にk文字分すべてを構成することができます。したがって、確認する必要があるのはS -\u0026gt; S'の順番で考えた時のS'と、S' -\u0026gt; Sの順番で考えた時のS'が一致するかどうかです。 上にある画像の通り、回文となるようなS'が存在することを仮定すると、S'はどちらのケースでも同一であるという仮定から、 文字列Sの先頭K文字と末尾K文字が一致する 文字列Sの先頭N-K文字と、末尾のN-K文字が回文を成す というSが要請される条件が見えてきます。このチェックにかかる計算量はO(N)になるので、制約的にも問題なさそうです。 K = N の場合 場合分けは漏らさずに考えることが必要です。イコールも忘れずにチェックします。先ほどのケースにこれを含めなかった理由は、場合分けはできるだけ細切れのほうが一ケース当たりに考えることが減るからです。 この時も同様に考えてみます。 S S'が回文: S'はSの逆順そのもの S' Sが回文: S'はSの逆順そのもの というわけで、Sに対してまったく条件が課されないことがわかります。単にS'をSの逆順として定めてしまえば任意のSに対して条件を満たすS'となります。この判定はO(1)なので当然オーケーです。 もしよくわからなかったら具体的に一ケース挙げて考えてみるといいと思います。(ex. S = \u0026quot;12345\u0026quot;) K \u0026gt; N 以降 小休憩 ここから少し複雑になります。そこで、今まで何のために場合分けをしていたのかを再確認しておきます。 ここまで、「最もシンプルな手」すなわち、「与えられた条件から実際にS'を構成してみて、そこから考える」という手段をとってきました。 ここで問題になるのは、「Kが非常に大きいケースにおいては、S'を構成するのに少し手間がかかりそう」という事実です。なぜKが小さいときにS'を構成しやすいかはここを見返してみてください。 よく見直してみると、K \u0026gt; Nのケースにもまだ比較的シンプルにS'を構成できるものが残っています。まずはそれを片づけましょう。 2N \u0026gt; K \u0026gt; N の場合 この時も、Sが与えられたらすぐにS'を構成することが可能です。なぜなら、以下の画像の通り、前からN文字、後ろからN文字が確定するのでS'が(存在するなら)一つに定まるからです。 一見するとK \u0026gt; Nの場合と変わらないように見えますが、このケースにおいて回文の判定をするのはS'の中になるという違いがあります。従って、直接Sを評価して答えを出すことができるわけではなく、「S'が存在するなら、Sから構成したこの文字列は-な条件を満たす。」という説明付けになっています。最後はプログラムに落とし込まないといけないわけなので、やはりできるだけ分割は細かくしておくべきだとと思います。 この時、S'の満たすべき条件は以下の2つになります。 S'の中心付近の(上図にも示されている)「重なり合う場所」で、互いに打ち消しあわない S'の先頭K-N文字と末尾K-N文字が回文を成す 前述のとおり、これは実際にS'を構成して確かめる必要があります。このチェックにはO(N+K)が必要ですが、十分間に合います。(計算量の見積もりあってるか自信ないです) K = 2N の場合 今回も一応イコールを分けておきました。この時、S'を構成しても「互いに重なり合う場所」が発生しません。なので、条件は非常にシンプルになり、「Sが回文」が構成可能になる必要十分条件となります。 これも上の議論を考えれば直ちに従うので、もしわからなければ具体例を考えてみるといいかもしれません。(ex. S = \u0026quot;1234321\u0026quot;, K = 14) また、このケースは2N \u0026gt; Kのケースと全く同じ判定法を使うことができます。したがって、実際に実装するときは統合してもよいかもしれません。 K \u0026gt; 2N の場合 まず、これまでの議論から、S'が存在すると仮定すると次のことが言えます。「S'は先頭と末尾のN文字はSの逆順そのものである」「S'の先頭と末尾のK-N文字は回文を成す」 この情報から残りの部分がどうなる必要があるか考えます。 上に示した画像の通り、これらの情報からS'の不明だった場所が少しだけ確定させることができます。これと全く同じ議論をS' -\u0026gt; Sのパターンでも考えることによって、S'はSの逆順 \u0026gt; Sの正順 \u0026gt; Sの逆順 \u0026gt; ...という風に、2NずつSの逆順か正順のどちらかに挟まれていることがわかります。 これは、S'の残りの部分が2N未満になるまでまったく同様に続けることができます。結果的に、以下の図のようになります。 結局、この「あまり」の部分の周りについてのみ考えればよいことになります。この余りは0~2Nまでの値をとりますが，このあまりの部分の長さによって場合分けが発生することに注意する必要があります。 上の画像に示したように，あまりの周辺を考えるとは，「Sの逆順または正順と余った部分を左右に結合したもの」どちらもが回文をなすかどうかをチェックすればよいことになります。 場合分けが発生するというのは，K \u0026gt; Nと2N \u0026gt; Kで分けたのとちょうど同じような事情が発生するからです。したがって， 「あまり」がN以上の時: この判定を使うことができる 「あまり」がN未満の時: この判定を使うことができる というようになります。この計算量は，Kがいくら多くてもざっくりO(N)に近いはずなので，おそらく大丈夫です。以上により，この問題を解くことができます。 実装例(C言語) 以下に私の実装例を示しますが，可読性をあまり考慮して書いていないので，実装に詰まったときの参考程度が良いと思います。 実装例(AtCoder上での提出) あとがき 今回新しい試みとして解説を作ってみましたが，改めて自分のアイデアを説明するということの難しさを実感します。また，画像の作成が思ったより面倒くさいので，競プロ勢の解説が短文+実装例だけになりがちなのはある程度しょうがないのかなとも思いました。 誤り，「ここが分からんからもっと細かく」等があればTwitterのほうに連絡いただけると幸いです。ここまで読んでいただきありがとうございました。 前回の記事から気が付いたら一か月くらいかかってしまいましたが，ABCとかにはちゃんと参加しているのでこれからはまた参加記録毎週書こうかなと思っている所存です。それでは次の記事でお会いしましょう。"
  },
  {
    url: "/post/abc284/",
    title: "ABC284参加記録",
    date: "2023-01-07T00:00:00Z",
    body: "ABC284参加記録 今週もABCのお時間になりました。 みなさん，あけましておめでとうございます。本日2023年1月7日は記念すべき新年最初のAtCoder Beginners Contestでした。今週も参加してきたのでいつも通り参加記録です。 早速余談ですが，皆様は正月休みを有意義に使えましたか？私は久しぶりに帰省して，運動不足解消にと鍋蓋山に登りました。 鍋蓋山の道中にある林 登頂成功。これ元旦です。いいでしょ？ 冬ということもあって，道中も結構寒い時がありました。普通に服着ててこれなので，中学高校の持久走で言われた「走ってたら寒くないから」とか言うクッソ無責任な言葉を思い出したりしてました。 長距離深夜バスにて東京に再召喚...(実家に帰りたい) また，我らがUECは1月5日から授業なので，年明けてすぐ帰りました。なお新年初授業は来てる人少なかった模様 閑話休題。それでは本編行きましょう 今回の結果 今回の提出はこんな感じでした。 今回はA, B, Dの三完でした。めちゃくちゃWAが多いのは気にしないでください。傷つきます。 なお，今回は初めてコンテスト中にD問題を解くことができました！ うれしい！でもお前C解けないじゃん 今回のコンテストによるレーティング変動は以下の通りでした。 遂に茶色までの折り返しを超えることができました！ やはりD問題が解けたのが大きかったようです。Cが解けなかったのに今までで最高のパフォーマンス(732でした。)を出すことができました。 各問題に対する解法など いつも通りに私の考えたことなどを書いていきます。 A - Sequence of Strings 問題文は以下の通りでした。 文字列をN個受け取って，逆順で出力する問題でした。 一旦文字列をすべて保持して，あとから出力していけばオーケーです。ほかの言語についてはよくわかりませんが，C言語ならとりあえずいっつも理解が浅いせいで事故るからできるだけ避けたいけど二次元配列を使うと比較的アッサリ解けます。 具体的に言うと，char s[n][11]みたいなものを宣言して，scanf関数で\u0026amp;s[i][0]から受け取ればいいです。以下はAC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n][11]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[i][0]); } for(int i = n - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%s\\n\u0026#34;, s[i]); } return 0; } ちなみに，この問題の制約下では各文字列は10文字以下です。したがって，配列は終端文字'\\0'を含めて11以上で宣言しなければいけません。私は普通に忘れててWA食らいました。 B - Multi Test Cases 問題文は以下の通りでした。 複数のテストケースに対して判定していくというちょっと変わった問題ですね。私がAtCoderに参加し始めてから初めて見るタイプでした。 幸い判定することは偶奇判定なので，2で割った余りを見ていけばOKです。ポイントを挙げるとするなら，答えはテストケースの順番に出力する必要があるので，入力を受け取るごとに出力をしていく感じで実装するとスマートです。以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int t; scanf(\u0026#34;%i\u0026#34;, \u0026amp;t); for(int i = 0; t \u0026gt; i; i++) { int n; int ans = 0; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); for(int i = 0; n \u0026gt; i; i++) { int temp; scanf(\u0026#34;%i\u0026#34;, \u0026amp;temp); if(temp % 2 == 1) { ans++; } } printf(\u0026#34;%i\\n\u0026#34;, ans); } return 0; } 完全に余談ですが，最近変数のスコープの管理が少しだけうまくなったような気がします。 D - Happy New Year 2023 問題文は以下の通りでした。 一言でいうなら素因数分解をする問題です。ただし，今回の問題では対象となる数が2つの素数p, qによってp2qと表せることが分かっています。あと，この問題でもB問題と同じく複数のケースの判定を行う問題でした。 この問題を最も単純なアイデアから膨らませて考えていきます。 最も簡単な解き方は，単純にすべて試し割りしてみることです。「ある自然数は，それ以下の素数の積としてただ1通りに表すことができる」という事実を利用しています。要は素因数分解の一意性ってことです。換言すると，「ある数Nは，2からNまでのいずれかの素数で割っていくといずれ1になる」ということです。 例を挙げましょう。例えば2023は17×17×7，63は3×3×7に分解することができます。このことを利用すると以下のような実装が可能です。 for(int i = 2; n \u0026gt;= i; i++) { if(n % i == 0) { // nを割ることができる数を発見 while(n % i == 0) { // 同じ数が複数回掛け算されている可能性もある n /= i; } } } これをいい感じに今回の問題に当てはめると「原理的には」解くことができます。しかし，*実際には解くことができません。*競技プログラミングをやる方ならお分かりかと思いますが，今回の制約におけるNが9 × 1018以下という部分が引っ掛かります。つまり，無駄な計算が多すぎて実行時間に間に合いません。さて，どのような工夫が可能でしょうか？ 私がこの問題を解くにあたって，まず足掛かりにしたのは「ある数Nは，Nの平方根より大きな素因数を多くても一つしか持たない」という事実です。残念ながらこの知識は当意即妙的に知らなかった状態からパッと思いつくのは難しいかなと(私は)思います。しかし，素数を扱うときに強力な武器になりえるので知らなかった人は憶えておくとよいかもしれません。よく考えると当たり前のことで，もしNの平方根より大きな素因数を2つもっていたとすると，その2数の積がすでにNを越えてしまうので，明らかに矛盾するからです。 この事実を使うと何が良いのでしょうか？それは，探索範囲が小さくできるからです。前述の事実から次のことが言えます。 NがNの平方根以下の素因数しか持たないとき，もちろんNの平方根までの探索で，すべての素因数を見つけることができる。 NがNの平方根より大きな素因数を持つ時，Nの平方根までの探索で見つけた素数でNを割ることで，残りの素因数を見つけることができる。 以上より，さっきまではNまで探索していたのに対して，Nの平方根までの探索でよいことを示すことができました。より具体的な方法を挙げると，Nの平方根まで「Nを割ることができる数」を見つけたらその都度見つけた数で限界まで割っていきます。探索がNの平方根まで終わったら，これまで割られてきたNを確認します。もしこの数が1になっていなければ，それは素数ということが確定しています。 この方法で問題を解くことができるでしょうか？残念ながら，おそらくまだ間に合いません。それはNの平方根が最大で109のオーダーに達するからです。 このアイデアは無駄だったのでしょうか？いや，まだあきらめるのは早いです。制約を見直してみましょう。今回はNは(重複を許して)3つの素因数を持ちます。先ほどの考え方を応用すると，Nの三乗根までの探索で少なくとも一つの素因数を見つけることが可能ということがいえます。これは，もしそれ以上の素因数を3つ以上持っていると先ほど示したものと同様の矛盾が生じるからです。 この時，探索範囲は最大で106のオーダーまで減少します。AtCoderでは，およそループを108くらいまで回せるそうなので，よほど定数倍を悪化させるような処理を書かなければおそらく通るでしょう。 基本的にはこのアイデアで通ると思います。が，私の実装ではまだ注意点があります。それは，三乗根までの探索ですべての素因数が確定するパターンと確定しないパターンに分かれるからです。 問題で言うところの素因数p(つまり，Nに二つ含まれているもの)を見つけることができれば，残りの素因数はNをpで割ることで見つけることができますが，もしqしか見つけられなかった場合，Nをqで割ることにより得られる数はp2となり，これをpに「ほぐす」作業が必要となります。私はこの処理を二分探索にて実装しました。 以下私のACコードです。 #include \u0026lt;stdio.h\u0026gt; int disassembly(long long int *a, long long int *b, long long int *n, int *map) { // 素因数がすべてまたは2乗じゃないほうだけ見つかる int flag; for(int i = 2; 3000000 \u0026gt; i; i++) { if(map[i] != 0) { if(*n % map[i] == 0) { *n /= map[i]; if(*n % map[i] == 0) { // このケースは確定 *a = map[i]; *n /= map[i]; *b = *n; flag = 1; break; } else { // このケースはまだわからない *b = map[i]; flag = 0; break; } } } } if(flag == 1) { return 0; } else { return -1; } } void Sqrt(long long int *a, long long int *n) { long long int left, center, right; left = 0; if(*n \u0026gt; 3000000000) { right = 3000000000; } else { right = *n; } for(; right - left \u0026gt; 10;) { center = (right + left) / 2; if(center * center \u0026gt; *n) { right = center; } else { left = center; } } for(; *n != left * left; left++) {} *a = left; } int main(void) { int t; scanf(\u0026#34;%i\u0026#34;, \u0026amp;t); int map[3000000]; // エラトステネス for(int i = 0; 3000000 \u0026gt; i; i++) { map[i] = i; } for(int i = 2; 1734 \u0026gt; i; i++) { for(int j = 2 * i; 3000000 \u0026gt; j; j += j) { map[j] = 0; } } for(int i = 0; t \u0026gt; i; i++) { long long int n; scanf(\u0026#34;%lli\u0026#34;, \u0026amp;n); long long int a, b; // 素因数 if(disassembly(\u0026amp;a, \u0026amp;b, \u0026amp;n, map) == 0) { printf(\u0026#34;%lli %lli\\n\u0026#34;, a, b); } else { Sqrt(\u0026amp;a, \u0026amp;n); printf(\u0026#34;%lli %lli\\n\u0026#34;, a, b); } } return 0; } クソ長コードですまんかった。ポイントとしては，まず素数のリストを事前にエラトステネスの篩を用いて事前計算しておくことで多少の軽量化を図っています。あとは二分探索でオーバーフローしないようにしています。いずれも制約ありきなので一般的に使えるコードではないです。 余談ですが，最近こんな風にvoidを返す関数にポインターの引数を与えることで，面倒くさい処理を外部委託するのにハマっています。それにしてもint *aみたいなやつを与えたときに*aって書くの面倒くさいですね。 C - Count Connected Components 問題文は以下の通りです。 無理でした。はい。 この問題に出てくる「グラフ」というのは，よくある「y = xのグラフ」のようなものではなくて，離散数学における「頂点と線をいくつか組み合わせた図形」のようなものらしいです。 例えば，以下のようなものがグラフです。(出典: AtCoder Beginners Contest284問題ページより) この問題の題意は多分「辺と頂点の情報が与えられるので，独立しているパーツの数を答えなさい」です。しかし，グラフの定義やそこから導かれる性質がよくわかっていなかったため，有効な解法がよくわかりませんでした。先にある程度グラフについて知らないと厳しそうです。 グラフ，完全に理解した。 ということで，今後の課題ということにさせてください。 終わりに 今回の参加記録は以上です。ここまで読んでいただきありがとうございました。 余談ですが，AtCoder Problemsにて今回のC問題のdifficultyを確認してきたのですが，なんと灰色の真ん中くらいでした。...うせやろ？ どうやらグラフの探索は簡単めの典型のようです。次出たときには解けるようになりたいといいたいところですが，グラフを勉強するってどうすればいいんでしょうか...解説によると幅優先探索とかで解けるらしいです。 なんだよそれ あと，最近はAtCoder Problems上のBoot camp for Beginnersを少しずつ進めています。ついでにLongest Streak(ACを出した日の継続日)を伸ばそうと頑張っています。もしやっていない人がいたらおすすめです。 それでは次の記事でお会いしましょう。皆様にとって2023年がいい年になりますように！"
  },
  {
    url: "/post/abc283/",
    title: "ABC283参加記録！",
    date: "2022-12-26T00:00:00Z",
    body: "ABC283参加記録！ ABC283参加してきた！ こんにちは。最近近所のスーパーが扱っている冷凍パスタのメーカーが変わって一瞬焦ったInです。(でもちゃんとおいしかったのでセーフ) アドベントカレンダーを執筆していた影響で遅れてしまいましたが，今週もちゃんとABCに参加してきましたので，その参加記録を生やしておきます。 今週の成績発表のコーナー まずは今週の成績です。前回爆死したのが記憶に新しいですが，今回はこんな感じでした。 大体16分でCまで通して，そのあとD問題に敗北しました。全体で3完です。 このためだけに10分くらいで作った雑コラ。 なお，今回のコンテストによるレート変動は以下の通りでした。 茶色まで折り返し地点といった感じでなかなかいいんじゃないでしょうか？今回は結構早解きに成功したので，3完ですがそこそこの順位になりました。ペナルティも食らってないし 各問題と解法 いつも通り自分が解いた問題の説明を載せていきたいと思います。まずはA問題です。 A - Power 問題文は以下の通りでした。 AのB乗を出力するだけのシンプルな問題です。 ご存じの方も多いかもしれませんが一応書いておきますと，ABというのはBが自然数の場合は素朴に定義されており， AB=A×A×\u0026hellip;×A (AがB個掛け算されている) というものです。 この問題の制約下では，ABの最小値はA=B=1の時1で，最大値はA=B=9の時387420489となります。これはintの範囲内に収まります。また，計算回数も9回程度に収まることが分かるので，定義通り計算して出力したらOKであることが分かります。以下にAC通ったコードを載せます。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int a, b; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;a, \u0026amp;b); int ans = 1; for(int i = 0; b \u0026gt; i; i++) { ans *= a; } printf(\u0026#34;%i\u0026#34;, ans); return 0; } このA問題はここ最近の中では簡単な問題だと思います。というかほとんどの言語が組み込みで冪乗計算の機能を備えているので，簡単に解けた人が多いんじゃないかと思います。 B - First Query Problem 問題文は以下の通りでした。 この問題はAtCoderによくあるタイプのクエリを処理する奴ですね。この手の問題は工夫したら真面目にクエリを処理しなくてもいい場合があります。したがって，まずは条件をよく見ることが大切です。 問題文を見ると，クエリの件数の制約や，行う必要のある操作の制約がかなり緩いことが分かります。まず第一引数が1であるようなクエリは，受け取った数列を配列などに保持するだけでO(1)で行うことができます。また，第一引数が2であるようなクエリに対しても同様です。一つしか値を操作しないので軽いですね。操作回数も105が上限となっており，愚直に処理しても十分間に合いそうです。 もしかしたら何らかの最適化があるのかもしれませんが，私は書いてある通りに実装して通りました。以下コードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n, q; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); int a[n]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;a[i]); } scanf(\u0026#34;%i\u0026#34;, \u0026amp;q); int temp; //クエリ種類 int k; // インデックス int num; // すり替え数字 for(int i = 0; q \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;temp); scanf(\u0026#34;%i\u0026#34;, \u0026amp;k); if(temp == 1) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;num); a[k - 1] = num; } else { printf(\u0026#34;%i\\n\u0026#34;, a[k - 1]); } } return 0; } クエリの種類によって与えられる引数の数が変わるのに注意です。私の実装ではシンプルにif文で分岐してあります。あと完全に余談なのですが，うえのコードでは実行時で確定していない変数を用いて配列を宣言するというC言語(C99以降?)の機能を使っているのですが，便利だけど罪悪感があります(笑) C - Cash Register 問題文は以下の通りでした。 与えられた数字をレジの機械で打ち込むときに必要なストローク数を調べるという問題でした。ほとんどの人がまずは制約に目が行くのではないでしょうか？制約は整数が10100000らしいです。デカ過ぎんだろ... デカさのイメージ図 ということで、明らかに「非常に簡単な処理」でどうにかなる、もしくは規則性などに注目して簡略化する必要があることが推察できます。そこで、問題文から具体的に考えてみます。 詳細は省きますが、具体例をいくつか考えることで「数字のキーを押す」ということと「現在表示されている数字の末尾に押した数字を追加する」ということが(一回目の入力を除いて)完全に一対一に対応していることに気づきます。すなわち、「0が二つ並んでいる」という状態を除くと、追加される数字に関係なく「キーを押す回数」=「数字の桁数」ということがわかります。 したがって、入力を文字列として受け取り、前述した「0が二つ並んでいる」状況のときのみを別処理になるようにして、あとは桁数をカウントするだけで良いです。 文字列として扱う理由は値が大きすぎてC言語組み込みのあらゆる整数型に収まらないからというのと、単純に各桁の数値を確認するだけなら配列としてアクセスしたほうが有利だからです。例えば整数型として格納できたとすると、各桁を取り出すためには割り算や剰余演算くらいしか手がないです。剰余を取る操作などは明らかに配列へのアクセスより遅く、今回の条件ではあまり意味がありません。以下はACコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[100002] = {0}; scanf(\u0026#34;%s\u0026#34;, s); int ans = 0; for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if(s[i] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;0\u0026#39;) { ans++; i++; } else { ans++; } } printf(\u0026#34;%i\u0026#34;, ans); return 0; } まず配列を100002以上で宣言します。これは、10100000=10...0(0が100000個並んでいる)で100001ブロック消費して、さらに文字列として処理しているので終端文字\\0の分が必要だからです。 前述の連続した0の処理は、二つ並んだものを見つけたら配列の参照カウントをインクリメントする処理に分岐させるようにしています。これで一回で二文字打ったということと等価になります。 見ての通り計算量的には各桁を見て回るだけなのでO(1)の処理を桁数だけ行うことになります。与えられた数字の桁数は最大で100001なので、余裕で間に合います。 D - Scope 問題文は以下の通りでした。 問題文が長くて問われていることを理解するだけでも結構大変な問題ですね。最終的にコンテスト後にACすることができたので，思考の過程を載せておきたいと思います。 問題文が複雑なので，まず問われていることを整理しました。この問題で問われていることは，細部を無視するとざっとこんな感じです。 (、)、「英小文字」のみからなる「ある条件」を満たす良い文字列が与えられる。 文字列の先頭からある操作をしていく。この時、文字列の最後まで操作を行うことができるかどうかを判定する。 (以下の議論では上の条件でぼかした「ある条件」と「ある操作」については説明しません。ご了承ください。)具体例を見ながらどういう判定法をするといいのかを考えました。例えば，具体例としてコンテストのページに乗っている入力例を以下に提示します。 この例などを見ながら考えると，良い文字列を)から遡って構成するには，(と)の数を釣り合わせればいいことに気が付くと思います。 例えば上記の入力例をとって説明しましょう。まず最初に出会う)は4文字目です。そこから遡って見返していくと，ほかの)に出会う前に(と出会うことが分かります。この場合，(と)の数が等しい最小の範囲を見つけることができました。 次に出会う)は最後の文字です。ここからさかのぼってみていくと，(に出会う前に)と出会ってしまうことが分かります。したがって，その他の)に出会わなければ2つの(が見つかった場所までが条件を満たす範囲になるはずです。もしこれが本当に正しいのか気になる人は，ほかの良い文字列のパターンなどに適用して確認してみてください。 このような操作を思いつくのは結構大変かもしれません。(実際，私はコンテスト中は間違った方針で進めてしまっていました。)個人的には，まずは「良い数列」の様々なパターンなどを書き出してみて，実際に自分がこの判定をするときにどのような部分に着目するかなどを考えるといいかもしれません。厳密に正しいという証明を出すのは難しくても，発見的手法が威力を発揮する場面は多いと思います。 それでは見つけ出した方法を愚直に実装してみましょう。私は()の数をカウントするのではなく，一番深いネストの()を終えたら()を違う文字で置き換えてしまうという方法をとりました。この操作によって，常に最初に見つかった(で止めればよくなります。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[300001] = {0}; scanf(\u0026#34;%s\u0026#34;, s); char ascii[123] = {0}; // アルファベット小文字はa-\u0026gt;97からz-\u0026gt;122だからそれぞれのインデックスに対応させる。1がたってたら使用済み for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if(s[i] == \u0026#39;(\u0026#39;) { continue; } else if(s[i] == \u0026#39;)\u0026#39;) { s[i] = 0; for(int j = 0; ; j++) { if(s[i - j] == \u0026#39;(\u0026#39;) { s[i - j] = 0; break; } else if(s[i - j] == 0){ continue; } else { ascii[s[i - j]] = 0; } } } else { if(ascii[s[i]] == 1) { printf(\u0026#34;No\\n\u0026#34;); return 0; } else { ascii[s[i]] = 1; } } } printf(\u0026#34;Yes\\n\u0026#34;); return 0; } こんな感じの実装になりました。英小文字カウンターは，asciiコード表でa~zが97~122に割り当てられているのを利用して，そのまま配列にアクセスするキーとして利用しています。途中でブレークすることなく最後までループを回せたらそれはYesの文字列だったという風に判定しています。 ...はい，このコード実はTLEを食らいました。 あれだけ自信満々に解説しておいてなんですが，これでは通らないようです。今の方針を維持したままもう少し工夫できるところがないか考えてみましょう。 具体例を見ながら条件をよく考察すると，上記のコードでは必要ない処理をかなり含んでいることが分かります。まずは以下の例を見てください。 文字列(((a(bcd)cde))ef)を考える。 まずabcdと書かれたボールが箱に入れられる。(箱の中: abcd) )に出会って，bcdが取り出される。(箱の中: a) cdeと書かれたボールが箱に入れられる。(箱の中: acde) abcdeが取り出される。(箱の中: なし) abcdeが取り出される。(二回目)(箱の中: なし) ボールefが箱に入れられる。(箱の中: ef) abcdefが取り出される。(箱の中: なし) 高橋君が操作を終えることができると分かる 注目していただきたいのは，ボールを取り出すフェーズです。よく見ると一度取り出した部分は，その後考える必要がないことが分かります。直観に反すると思うので，もう少し定性的に考えてみます。現在考えている階層より深いネストの()の中にある小文字は，以下の2パターンに分岐します。((abc)abe)を見ながら考えてみるといいと思います。 現在の階層にあるものとと同じ小文字 -\u0026gt; 「現在の階層」の)に出会えば，より深い部分に行く前にボールは取り出される。(上の例のabが該当する) 現在の階層に無い小文字 -\u0026gt; 「現在の階層」に至る前に取り出され，それ以降箱に入れられること自体がない。(上の例でcが該当する) 以上から，例えば((abc)abe)は，一回目のボール取り出しをした後は( abe)として扱っても良いということになります。 これを繰り返すことで，一回見た部分を今後見ないという改善策が見つかります。これを実装しましょう。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { char *s = (char *)calloc(300001, sizeof(char)); scanf(\u0026#34;%s\u0026#34;, s); int len = 0; for(; s[len] != \u0026#39;\\0\u0026#39;; len++) {} char ascii[123] = {0}; // アルファベット小文字はa-\u0026gt;97からz-\u0026gt;122だからそれぞれのインデックスに対応させる。1がたってたら使用済み char *s1 = NULL; for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if(s[i] == \u0026#39;(\u0026#39;) { continue; } else if(s[i] == \u0026#39;)\u0026#39;) { int j; for(j = 1; ; j++) { if(s[i - j] == \u0026#39;(\u0026#39;) { break; } else { ascii[s[i - j]] = 0; } } s1 = (char *)calloc(len - j, sizeof(char)); // 新しい配列の宣言+代入 for(int k = 0; i - j \u0026gt; k; k++) { s1[k] = s[k]; } for(int k = i + 1, k1 = i - j; len \u0026gt; k; k++, k1++) { s1[k1] = s[k]; } len = len - j - 1; i = i - j - 1; free(s); s = s1; s1 = NULL; } else { if(ascii[s[i]] == 1) { printf(\u0026#34;No\\n\u0026#34;); return 0; } else { ascii[s[i]] = 1; } } } printf(\u0026#34;Yes\\n\u0026#34;); return 0; } これでAC通りました。うれしい。 かなりごちゃごちゃしてしまいましたが，このコードの要点は， 最もネストの深い()を見つけて，ボール解放を行う。 新しく配列を宣言して，その部分のみを除いた文字列を作る。 これを繰り返しているだけです。C言語以外なら多分もっと簡潔に書けると思います。 ちなみにこれは全然最適な方法ではないらしく，今回のコンテストでC言語を用いてD問題を通した中で最も実行時間がかかっていました。余裕があればほかの人のコードも解析しようかな。 終わりに 今回の記事は書くのに過去一番時間がかかりました。ひとえにD問題が強敵だったからです。とんでもねえな 実はいまだにコンテスト中にD問題を通したことがありません。そろそろ通させてくださいマジで。ちなみにレーティングが今回で199まで上がったので，茶色までの折り返しに到達しました。何とか茶色に到達できるように今後も頑張っていけたらなと思います。 完全に私事ですが，このくらいの規模の記事になると流石にタグ含めすべてを手打ちするの結構大変になってきました。もうちょっと何とかしたいです。 それではここまで読んでいただきありがとうございました。よいお年を。"
  },
  {
    url: "/post/uec-advent2022/",
    title: "あなたの知らない(知ってるかもしれない)SCPの世界 [UEC Advent Calendar 2022] 24日目",
    date: "2022-12-22T00:00:00Z",
    body: "あなたの知らない(知ってるかもしれない)SCPの世界 [UEC Advent Calendar 2022] 24日目 はじめに あなたは誰？ 始めまして。基礎科学実験Aを落としそうな22生のInと申します。 アドベントカレンダーの募集をtwitterで見て、楽しそうだなと思ったので初参加です。いろいろと至らない点があるかもしれませんが、ある程度温かい目で見守っていただけるとありがたいです。 え？この記事、CSS適用されてませんよだって？ほならね？(以下略) (手打ちの温かみのあるサイトなので許して) この記事は何？ UEC外からこの記事を見に来る人がそんなにいるとは思えませんが，この記事はUEC Advent Calendar 2022 その2の24日目の記事です。(その1もあります。)ほかにもたくさん面白い記事があるので，気になる人はぜひ見てみてください。 23日の記事は，かわいいねさんの「メンタルの話」でした。自分の弱い部分(？)と向き合って、しっかりと言語化することができるのがすごいと思います。World's Smallest Violinとかいかがですか...？(隙あらばAJR推し) 25日はとりゑもんさんの「僕の友達の競馬予想と競馬を始めて1年を振り返りたいと思います」です。電気通信大学は(というか調布は)確か近くに競馬場があったので、競馬を嗜んでいる方も多いかと思います。楽しみですね。私ですか？私は毎年有馬記念のCMを聞いては季節を感じているだけの人です() 明日の記事も楽しみですね。 本題 で、今日は何についての記事なんだい？ この記事で私が紹介するのは、SCP Foundationです。(ファイル転送するやつではありません) SCPを知らない人は、この記事を通してSCPを知ってもらう、すでに知っている人は、私の一押しをシェア出来たらいいなと思います。 最近はyoutube向けに動画を投稿する人が増えてきたので、詳しくはなくてもチラ見、小耳にはさむなどはある人が多いかもしれません。実際scp関連の動画は結構再生数があるものもあり、コンテンツやコミュニティーは年々肥大化しているように感じます(主観なのでデータなんかねえよ (画像掲載めちゃくちゃ雑です。すみません。)さらっと人気どころを挙げるとこんなところでしょうか。まだあるかもしれませんが私が知らないので終わりです。興味ない人もサムネくらい見たことある人が多いんじゃないでしょうか。ちなみにどのチャンネルも好きですが、私が一番見るのはscp情報局です。 SCP Foundationとは？ この記事の目標の一つが「SCPを知らなかった人に興味を持ってもらう」なので、今一度SCPとはなんなのかさらっとおさらいしておきます。 ざっくりとした説明なので、もしもっとちゃんと知りたい人はこことか公式あたりを参照してもらうといいです。 SCPとは、創作及び創作投稿サイトの総称です。その起源は4chanで行われていた、貼られたホラー画像に対してキャプションをつける遊びで、現在も(画像などのライセンス管理は厳しくなっていますが、)そのようなスタイルです。(したがって、今でもたまにホラー画像が使われることがあり、知らずに開いたら普通に怖いです。) SCPの一番の特徴は、SCiPおよびSCP財団というサイト共通の土台のもとで作品が作られることです。SCiPとはこの世の常識に反するような事象、物体のことで、SCP財団はこれらの異常から世界を保護するという使命の元活動しています。(異常物品の例: 無限に水が出てくる水筒、姿を見ると猛スピードで殺しに来る化け物、RPG世界のようにされてしまった空間など) SCPとはSecure Contain Protectの略称で、(ほかにもSpecial Containment Proceduresだったりしますが、こまけぇこたぁいいんだよ)これはSCP財団の理念を表しており、異常物品を確保、収容し、一般人の目に触れぬように保護します。財団はあくまでSCiPという世界の不条理を取り除くことを第一として動きます。すなわち、世界の正常性さえ保たれていればいいという団体です。 財団はふつう超技術を持っており、今の文明の2歩くらい先に行ったオーパーツみたいな装備でSCiPの確保を行います。しかし、前述の通り世界の正常性さえ保たれていたらいいというスタンスです。例えば非異常性の何かによって地球がやばくなったりしたとき、財団は動きませんこの性質はよくSCP記事の主題に挙がったりするような奥の深いテーマだといえるでしょう。 また、特筆すべきなのはSCP記事の体裁です。以下にある記事の画像を載せます。 ソース: http://www.scp-wiki.net/scp-1009 ライセンス: CC BY-SA 3.0 タイトル: tree2-small.png 著作権者: Sophia Light 公開年: 2011 上の画像を見ていただければわかるように、SCPの記事は基本的にすべて報告書の体裁をとっており、財団がマークした異常物品に対する情報が機械的に記述されています。SCPの醍醐味はこの語り口にもあり、機械的な記述の中で作品の雰囲気が作り上げられます。基本的には決まった流れで作成されるので、読み方さえわかると初心者でも楽しみやすいかなとも思います。(時々format-screwという変則記事もありますが、多くはないです。これとか) 報告書の中で出てくるセクションについて、軽くまとめてみました。 アイテム番号: これは、財団がオブジェクト(SCiP)を管理するときに使用している番号という設定のものです。同じ番号を共有するアイテムはありません。メタ的には、この番号は早い者勝ちなのでキリ番など人気のある番号はコンテストの景品として与えられる場合があります。なお、この番号とは別に「メタネーム」というものも持っています。これはいわば「作品名」です。当然財団世界ではなじみのない呼び方なので、記事内に出てくることはないです。 オブジェクトクラス: 一言でいうと、アイテムの脅威度です。ざっくりKeter-\u0026gt;Euclid-\u0026gt;safeの順番でヤバいと考えてもらえればいいです。ただ、このクラスは様々な要素が複合して決定されているので、初心者はなんでこのアイテムにこのクラスがつけられているんだろうとかを考えると楽しいかもしれません。 特別収容プロトコル: これは財団が現段階で確立しているアイテムの取り扱いに関するベストプラクティスです。オブジェクトクラスが低いアイテムに関しては基本的に収容方法が確立されているものも多く、実質的には管理マニュアルという意味になります。しかしketerクラスなどになると、実質的な抑え込みをあきらめて、まだ「マシ」な方法を提示しているだけの場合もあります。ちなみに、このパートがオブジェクトクラスの下に来ている理由は、緊急時に取り扱い方法がすぐわかるようにできるだけ上に書くべきというものらしいです。ネタが細かいですね。 説明: アイテムの説明です。多くの記事はこの部分に一番主眼が置かれています。多くは発見状況や、どのような異常性があるのかなどの説明、現在に至るまでに起こったインシデントなどが書かれます。 大体このくらいの知識でも楽しく読めると思います。再掲になりますが、もし興味を持った方がいましたら、セクション先頭で貼ったようなリンク先などものぞきに行ってみることをお勧めします。私のものよりもより詳細で正確な説明があります。 オレオレSCP紹介！(初心者向け) まずはSCPについて知ってもらえたと思います。次に、私の一押しSCPを「ここすきポイント」とともに紹介していこうと思います。まずは初心者に知ってほしい(または，初心者でも読みやすいと思われるやつ)作品を紹介します。 SCP-040-JP(通称: ねこですよろしくおねがいします) 栄えある先頭に選ばれたのはscp-040-jpです。本家記事を見に行く人向けの注意: この記事は詳細を展開するとちょっとびっくりするような画像が使われていますので，折り畳みを開けるときはそういうつもりで開けましょう このscpは，一言でいうと「中を覗き込んでしまうと，以降暗闇の中に幻覚が見えるようになり精神が死ぬ」scpです。この記事は非常に有名で，scp殿堂入りコレクションにも入っています。皆さんはyoutubeなどのコメント欄で「ねこでした」とか，「ねこはいます」とかみたことあるんじゃないでしょうか？それの元ネタです。 ちなみに，すでに知っている人向けなんですけどこんなジョーク記事も存在します。 ここすきポイント この作品のここすきポイントは，やはりその圧倒的な知名度です。このscpを知ってるだけで学校で友達100人は固い(適当) SCP-173(通称: いなみちゃん) 仮にもscpを紹介する記事なら絶対に外すことはできないと思ってランクインです。このscpは事実上の「最初のscp」です。すなわち，掲示板で一番最初に考えられたscpということです。^要出典^ならなんで173番なんだって？知らん このscpは，一言で説明するなら「目を離したら襲ってくるやべー奴」です。実際，特別収容プロトコルにも掃除の際は3人以上で入室するように規定されています。詳細は記事を見てみてください！(短いので) ここすきポイント この記事のここすきポイントはアイテムのシンプルさです。じつは，最近の記事になるほど作者が力を入れ過ぎて難解になるという傾向があります。しかし，この記事は最初期の作品だけあってすごく設定がシンプルで，ミステリアスな雰囲気がscpって感じがしてとても好きです。ちなみに世界的にもかなり愛されているみたいで，各国支部の173番ナンバーを決めるためにコンテストとかやってた気がします。(初めての方は困惑するかもしれませんが，scp-173-○○(国のコード)とscp-173は別の記事です。実際上で紹介した040-jpは日本支部の記事で，本部の040とは違うものです。) SCP-8900-EX(通称: 青い，青い空(メタネーム)) お次に紹介するのはscp-8900-exです。この記事の末尾についているexというのは，オブジェクトクラスがexplainedに設定されているものにしかつかない特別なものです。本来このような特殊クラスを紹介するのは，初心者向けかといわれると「ｳｰﾝ」っていう感じですが，日本での知名度が非常に高いため取り上げました。 オブジェクトクラスExplainedとは，次のいずれかの条件を満たすオブジェクトにに付けられることが多いです。 かつて財団しかもっていなかった超技術だったが，世界のレベルがその技術に追いついたため「異常」ではなくなった アイテムが原因のれっきとした異常であったが，財団がその異常を抑え込むことができず，遂にはそれが新しい「常識」となるまで広がってしまった このアイテムは後者の条件を満たしています。あまりネタバレをしたくないので気になる方は見に行ってみてください！ ここすきポイント この記事のここすきポイントは，まず現実との親和性の高さです。実はこのオブジェクトは普段皆さんも非常に親しんでいるもので，この記事を初めて読んだときは「こんなの思いつくなんて天才か？」って思いました。 また，作品中のO5の言葉(O5っていうのは財団の偉い人です。)は，scp財団の理念をよくあらわしている名文です。たまにコメント欄とかで見かける気がします。 SCP紹介(無差別級) ここからは，書くのしんどくなってきたので読んでいる人も知っている人がある程度いると思うので，個人的に好きな記事のみをいくつか紹介していきます。できるだけマイナーなものとかを紹介していけたらと思います(私は英語読めないので，未翻訳記事とかは無理ですが)ちなみに選定基準はすべて私の好みなので，結構読みづらいものとかも入ってたりします。ご了承ください SCP-023-JP(影の鉄道路線) このscpは，鉄道駅に突如現れるヤバい路線です。誰も監視していないときに，まるで元からそこにあったかのように突如その路線への入り口が生成されます。そこに走っている電車に乗ると，当然えらい目にあいます(ほとんど帰還した例がないそうです。) ここすきポイント scpならではのこの意味不明さがとっても好きです。記事中に出てくる当然のように役に立たないgpsとかもいい味出してます。あと，このscpの魅力は実験記録が面白いことです。作品には4回の実験記録が載っており，なかなかヤバい様子が伝わってきます。中でも最後の実験記録は突っ込みどころ満載で好きです。 SCP-3300(The Rain) このscpは日本ではそんなに有名ではないかもしれません。モンタナ州クリアウォーターの町で年に一回起こる「元の住民が消失して，新しい住民に置き換わる」という超常現象です。 ここすきポイント この記事のいいところは，なんといってもその圧倒的な雰囲気です。まず名前がいい！うん！シンプルでとってもいいです。そして舞台がモンタナ州クリアウォーターという何とも「リアルだけど日本人には想像がつかない隔世感」がいいです。何より，機械的な報告書の語り口と補遺に残されているかつてのクリアウォーターの住人の日誌との差異がまたいい感じです。うん。いいよね。正直全然記事紹介できてないような気がするけどヨシッ！ Tale: マリアナ海溝から回収された文書 お次はtaleです。taleとは，scp関連の小説のようなもので，多くはアイテムや財団職員の裏話的なものだったりします。つまり正規のアイテムではないです。(遂にscpですらなくなったのか) このtaleは、文字通りマリアナ海溝から回収された文章という設定になっています。内容は、数々の異常物品が財団のコントロール下から離れ、世界が危機に瀕している様子を何も知らない一般人がつづっているというものです。 ここすきポイント まず財団外部の人間の視点で書かれているという点です。異常な物品を知らない人々がどんなふうに感じるのかを映し出しているのがすごいと思います。そして、途中に出てくるある財団職員の会話が底知れない不気味さというか、常識が通じない感じというかがすごく好きです。 「なぜできないと？前にもやったんだぞ」←ここすき 「どうか、彼らが私を洗い流さないように。彼らが我々を隠さないように。もっといろいろなものを見つけてくれ、何かを残そうとした人たちがいることを私は知っている。世界を無駄死にさせないでくれ。我々を忘れないでくれ。(Remember us.)」←ここすき よもやま話 あれ？この文章で世界滅んでね？と思った方もいるかもしれません。しかし、こうやって財団のデーターベースの中に保存されているということはいまだ世界は存続しているようです。すなわち、財団は世界を修復するほどの何かを持っているという示唆になっています。実際、財団の保有する異常物品の中にはそのようなチートアイテムとしか言えないようなものがいくつか存在します。例えばSCP-2000は、機械仕掛けの神というメタネームで、(機械仕掛けの神というのは、古代ギリシアの演劇において物語を収束させる何でもありな存在を指す言葉からきているようです。)世界がやばくなった時にrebootすることができるというものです。しかしメタ的にはscp-2000よりもこの記事のほうが先に投稿されており、事実上の元ネタという説が有力です。いかにこのtaleがscpコミュニティに影響を与えているかがよくわかります。 また、このtaleに登場するscpも実際に記事として存在するものがたくさんあります。実はメタ的には各報告書はパラレルワールドとして書かれることが多いのですが、(すなわち、作者の数だけ財団世界があり、それぞれで矛盾した設定をはらんでいても基本的にはOK)この記事はクロスリンクはしてないものの、様々な他記事と密接につながりがあって楽しいですね。 SCP-1986(架空図書館) この作品は、アルゼンチン国立図書館の地下にあるトンネルのような空間です。それは無限に奥に続いており、(実際に無限かはわからないが、財団の探索では「最後」は見つかっていない)壁には無数の本がずらっと並んでいます。その内容は非常に多岐にわたり、場合によっては未知の言語で書かれていることもあります。 ここすきポイント なんといってもこの独特な雰囲気がたまらないです。無限のトンネルにある無限の本、そこには文字によって表現可能な一切を含んでいる。。。無限への憧れを感じます。 また、探索記録にある多彩な本も魅力の一つです。この記事のfootnoteには、「ある研究者は、認識できる本を求めてトンネルを探すことは、有理数を探して実数直線を横断するようなものであると喚起する比較を打ち出してきました。」とあります。(もうこれすき)すなわち、非常に厖大な本から見つけ出した貴重なサンプルというわけです。その内容も「そうはならんやろ」みたいなものばかりで面白いです。 この作品には元ネタがあります。それは、J.L.ボルヘスというアルゼンチンの作家の作品「伝奇集」に収録されている「バベルの図書館」という作品です。以下にこの作品からの引用を書きます。 …これらの例示のおかげで、ある天才的な司書が図書館の基本的な法則を発見した。この思想家のいうには、いかに多種多様であっても、すべての本は行間、ピリオド、コンマ、アルファベットの二十五字という、おなじ要素からなっていた。また彼は、すべての旅行者が確認するに至ったある事実を指摘した。広大な図書館に、おなじ本は二冊ない。彼はこの反論の余地のない前提から、図書館は全体的なもので、その書棚は二十数個の記号のあらゆる可能な組み合わせ―その数はきわめて厖大であるが無限ではない―を、換言すれば、あらゆる言語で表現可能なもののいっさいをふくんでいると推論した。いっさいとは、未来の詳細な歴史、熾天使らの自伝、図書館の信頼すべきカタログ、何千何万もの虚偽のカタログ、これらのカタログの虚偽性の証明、真実のカタログの虚偽性の証明、バシリデスのグノーシス派の福音書、この福音書の注解、この福音書の注解の注解、あなたの死の真実の記述、それぞれの本のあらゆる言語への翻訳、それぞれの本のあらゆる本のなかへの挿入、などである…\" 岩波文庫 伝奇集, J.L.ボルヘス この特徴、非常に架空図書館と似ていませんか？実はバベルの図書館の中に出てくる図書館は、六角形のパーツが無限に重なってできたような構造をしており、いろいろなところで類似点が見えると思います。そうです。このscpのスタンスは、ボルヘスが架空図書館を発見しており、そこから着想を得てバベルの図書館を書いたというものになっております。この嘘か本当かわからないくらいの現実世界とのリンクがとってもいいです。。 ちなみに原作のほうもめちゃくちゃ面白かったです。電通大図書館にも置いてあるので、興味があったら見てみてください(12/6のタイムスタンプは私です笑) SCPワールドの歩き方(の勧め) さて、scp紹介もまだまだしょうかいしたいものがありますが、 そのあたりは次の機会に譲るとして、俺的scpの楽しみ方を紹介します。 いやほら、scpって読むのも追いかけるのも大変じゃん？ はい、まず大前提として、原文をそのまま読むのは結構大変です。当たり前っちゃ当たり前なんですが、scpのフォーマットに従って書いた文って、結構かみ砕きながら読まないと理解が難しい場合も多いと思います。特に「説明」セクションの前に「特別収容プロトコル」があるので、(基本的にプロトコルはマニュアルなので、全体像をつかんでからじゃないとなんでそんなことするのかわかりにくい場合が多いです)前から通しで読んで一回ですべて内容を読み取るのは結構大変だと思います。特殊な言い回しも多いですしお寿司。 そこで、あんまり大変じゃない楽しみ方をいくつか紹介します。私みたいな人向けです。実際私はこんな生意気に解説みたいな書いてますが、原文をすべて読んだ記事はそんなに多くないです。(この辺は人にもよりますが、、、) アニヲタwikiを読む 個人的にはアニヲタwikiのscp記事が非常に素晴らしいと思っています。口語調で非常に簡潔にまとまっており、それでいて細かい説明もたくさんあります。scpに関する裏話や考察なども非常に質が高いと思います。また、更新が非常に速い(ものもある)ことがいいです。時折読んだだけだと全然意味が理解できないscpとかに出会うことがあります。そんな時は基本的にまずアニヲタwikiから見てます。ということで最推しです。 youtube/niconicoの紹介動画 youtubeやniconicoではたくさんの人が開設動画をあげてくれています。scpはかなり緩いライセンスで公開されることが多いので、第三者によるコンテンツ作成も活発です。ただ、ジャンルが偏りがちだったり、解説の質がまちまちだったりという点はありますが、お気に入りの人を見つけると楽しいです。 原文読み上げ scp作品はその性質上、音声コンテンツとして提供されている場合も多いです。上で紹介したような解説ではなく、完全に原文をAquesTalkなどで読み上げするというようなものです。 この方法のおすすめポイントは報告書風の文章と合成音声が非常にマッチしているという点です。個人差はあると思いますが、私は好きです。また、自動再生で適当に流すだけでいろいろなscpと出会えるのもいいところだと思います。SCP情報局さんは大量のコンテンツをyoutube/niconicoにアップロードしてくれているので、私はよく聞き流しています。あと、解説の茶番とかが嫌いな人にもいいかもしれません。(コメント欄でそういう意見見たことあります) 気に入ったscpを見つけたら 上で書いたような方法で、お気に入りのscpをみつけたら、次は本家に行って読んでみることをお勧めします。きっとまた違う印象とか感じるんじゃないでしょうか？(適当)あと、記事内でクロスリンクされている先を見に行ってみるのも面白いと思います。 長い。三行で。 アニヲタwikiと読み上げがおすすめ 気に入ったのがあったら本家 ただ、楽しみ方は人による\\ 終わりに 内容は以上で終了です！めっちゃ長い記事になってしまいましたが、読んでくれた人もそうでない人もこのページに来ていただきありがとうございます。 あまり考えずに勢いで書いてしまったので、結構読みづらい記事になってしまったかもしれません。というかそもそもこんな長い文章めったに書かないのでそりゃそうかもしれません。もし誤字脱字や内容に関する訂正依頼、記事への感想や文句などがあればそれらはtwitterのほうにお願いします。githubわからない人類なので、githubでなんかしていただいても反応できない可能性が高いからです。 初めてのアドベントカレンダーですが、ほかの参加者の記事などを読めて楽しいなと思いました。また来年も続くといいですね！ この記事を通してscpを楽しむ人が増えてくれたら私は嬉しいです。それではありがとうございました！メリークリスマス！"
  },
  {
    url: "/post/abc282/",
    title: "ABC282参加記録",
    date: "2022-12-18T00:00:00Z",
    body: "ABC282参加記録 今週もABC参加してきた こんにちは，冷凍うどんを食べようとしたら鍋の口が小っちゃくて入らなかったInです。 毎週ABCに参加し続けて，今回のABC282で5回目になりました。今週も結果報告と自分の忘備録を兼ねて記事を残しておきます。 結果報告のコーナー まずはいつも通り結果報告からです。今回の提出状況はこのような感じでした。 まずB問題で問題文の読み間違えが発生して無駄に悩んだ挙句，C問題で3WAを出して爆死しました。はい。結果的にはABCの三完でした。何とか途中で修正できてよかったです。ちなみにD以降は私にはもうちんぷんかんぷんでした。 今回のコンテストによるレーティング変動は，以下の通りでした。ジャン！ コラ～～～～！！！！！！！ ...ということで爆死でした。パフォーマンスは210で，今までで2番目に低い値を記録してしまいました。絶望感漂う中，記事を書いていきたいと思います。 もう終わりだよこの国 問題と解法 どんなふうに問題を解いたかを紹介します。 A問題 問題文は以下の通りでした。 与えられた整数Kの分だけ英大文字を出力する問題です。制約からZよりあとに関しては考えなくてもいいことが分かります。したがって，ASCIIコードを利用してprintf関数で標準出力に出力していけばオーケーです。 もう少し具体的に言うと，ASCIIコード表によると，英大文字は65番にAから始まって，90番にZまで順番に割り当てられています。したがって，ループ毎に1ずつ増やしていけばオーケーです。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int k; scanf(\u0026#34;%i\u0026#34;, \u0026amp;k); for(int i = 0; k \u0026gt; i; i++) { printf(\u0026#34;%c\u0026#34;, 65 + i); } return 0; } 最近のABCは毎回ASCIIコード表を見ながらやってる気がします。次B問題です。 B問題 問題文は以下の通りです。 N人の人が，コンテストに出題される各問題を解けるかどうかのデータが渡されます。参加者から2人を選んで，コンテストの問題をすべて解けるペアを作るとするとき，作ることができるペアの数を調べる問題です。 この時，作ることができるペアとは，「同時に作ることができるペア」ではないことに注意する必要があります。私はこれを勝手に同時に作ることができるペアの数のことだと勘違いして，永遠に悩んでいました。 また，この問題にはもう一つ注意する必要のある点があります。それは，ペアには順序を考えないことです。具体的には，ある一人を選んで，その人が一緒に組むことで全問正解できるようなペアをすべて列挙していくコードで解こうとすると，気を付けないとA-BのペアとB-Aのペアを区別してカウントしてしまうということが起こります。私はこの方針で解きましたが，前述の問題は，二重forループの二重目のループ変数を，一重目のループ変数で初期化することで対処しました。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n, m; // nが人，mが問題 scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;m); char s[n][31]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[i][0]); } int ans = 0; char flag = 0; for(int i = 0; n \u0026gt; i; i++) { for(int j = i; n \u0026gt; j; j++) { if(i == j) { continue; //同じ番号同士は考えない } for(int k = 0; m \u0026gt; k; k++) { if(s[i][k] == \u0026#39;x\u0026#39; \u0026amp;\u0026amp; s[j][k] == \u0026#39;x\u0026#39;) { //ダメだった flag = 1; break; } } if(flag == 0) { ans++; // 可能ペア発見 } else { flag = 0; //戻す } } } printf(\u0026#34;%i\u0026#34;, ans); return 0; } 少し見にくいかもしれません。すみません。途中3重forループがありますが，最初の二つが人を選ぶところと対応しており，三つめが問題をすべて解けるかの判定になっています。 C問題 最後にC問題です。問題文は以下の通りです。 \u0026quot;に挟まれていない部分にのみ違う処理を施して，文字列を得る問題です。 正直，この問題はC問題の中では簡単なほうかなと思います。(簡単というのは，方針が思い浮かびやすいという意味です。)しかし，私はこの問題で大コケしてしまい，*順位が死にました。*結構ガチでショックです。 解法としては，文字列を配列で受け取り，\u0026quot;を発見したら，次の\u0026quot;までそのまま出力するようにするとオッケーです。この分岐の処理をいかに簡単にするかがキモだと思います。 まずは私がWAを出したクソコードを載せます。反面教師です。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n]; scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[0]); for(int i = 0; n \u0026gt; i; i++) { if(s[i] == \u0026#39;\u0026#34;\u0026#39;) { printf(\u0026#34;%c\u0026#34;, s[i]); for(int j = i + 1; s[j] != \u0026#39;\u0026#34;\u0026#39;; j++) { if(s[j] == \u0026#39;,\u0026#39;) { printf(\u0026#34;%c\u0026#34;, \u0026#39;.\u0026#39;); } else { printf(\u0026#34;%c\u0026#34;, s[j]); } i++; } i++; printf(\u0026#34;%c\u0026#34;, s[i]); } else { printf(\u0026#34;%c\u0026#34;, s[i]); } } return 0; } まずはクソコードその一です。言うまでもなくこのコードの抱える一番の問題点は，とにかくごちゃごちゃしている点です。このコードはprintf関数を5回も使っており，いかに事前にどうやって組むかを考えていなかったかがバレバレです。また，もう一つの重大な欠点は問題の要求と逆の処理をしていることです。問題文の読み違えには気を付けよう！(公開ブログでゆうさくを貼れるほど度胸は無かった) お次に，これをもう少し修正したけどダメだったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n]; scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[0]); for(int i = 0; n \u0026gt; i; i++) { if(s[i] == \u0026#39;\u0026#34;\u0026#39;) { printf(\u0026#34;%c\u0026#34;, s[i]); i++; for(; s[i] != \u0026#39;\u0026#34;\u0026#39;; i++) { printf(\u0026#34;%c\u0026#34;, s[i]); } printf(\u0026#34;%c\u0026#34;, s[i]); i++; } if(s[i] == \u0026#39;,\u0026#39;) { printf(\u0026#34;%c\u0026#34;, \u0026#39;.\u0026#39;); } else { printf(\u0026#34;%c\u0026#34;, s[i]); } } return 0; } このコードは，問題ページにあるテストケースは無事に突破しました。しかし，いまだ重大な問題を抱えています。それは*極端な入力に対してバッファーオーバーランが起こりえます。*これはヤバい(確信) このコードは，最初に\u0026quot;が来たかどうかを判定して，来ていたら次の\u0026quot;までそのまま出力し続けるようにしてあります。これだけ聞くとまともそうですが，一番ダメなのはインクリメントを管理しきれていない点です。ループの途中に分岐点を作っていたりする関係上，コード中のあちこちでインクリメントが発生するせいでバグを追いきれませんでした。 例えば入力が\u0026quot;\u0026quot;\u0026quot;\u0026quot;だったりすると，余分なインクリメントが発生してバッファの外側に突き抜けます。そして次の\u0026quot;が見つかるまで止まることはありません。うーんこの 最後にAC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n]; scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[0]); for(int i = 0; n \u0026gt; i; i++) { if(s[i] == \u0026#39;\u0026#34;\u0026#39;) { printf(\u0026#34;%c\u0026#34;, s[i]); i++; for(; s[i] != \u0026#39;\u0026#34;\u0026#39;; i++) { printf(\u0026#34;%c\u0026#34;, s[i]); } printf(\u0026#34;%c\u0026#34;, s[i]); continue; } if(s[i] == \u0026#39;,\u0026#39;) { printf(\u0026#34;%c\u0026#34;, \u0026#39;.\u0026#39;); } else { printf(\u0026#34;%c\u0026#34;, s[i]); } } return 0; } このコードはさっきのコードにcontinue処理を挟むことで(一時的なものですが)さっき挙げた不正なインクリメントを防止しています。 教訓: インクリメントはわかりやすい場所で管理しよう。continueやbreakをちゃんと使おう。 完走した感想 今回のコンテストはかなり残念な感じになってしまいました。しかしとりあえずC問題まででも解けて良かったです。結構実装の技術的な点でコケることが多いなと感じているので，もっと問題数を解いてデバッグなどに慣れたいです。また，D問題以降は数学的知識や競プロ的な技術がかなり問われる問題かなと(一見)思いました。したがって，大学での数学の勉強などはしっかり頑張りたいです。(願望) 今回の結果はかなり来るものがあるけど，今日体調悪かったから多少はね？ ここまで読んでいただき，ありがとうございました。また次の記事でお会いしましょう。ちなみに一週間後のUECアドベントカレンダーに登録したはいいもののまだ一文字も書いていません(絶望)じゃあね。"
  },
  {
    url: "/post/abc281/",
    title: "ABC281に参加してきた。",
    date: "2022-12-10T00:00:00Z",
    body: "ABC281に参加してきた。 今週もABCに参加してきたよ こんにちは。あいも変わらず今週もABCに参加してきました。その結果報告の記事です。 今回の戦績発表 まずは今回の戦績です。以下は今回の私の提出です。 今回は珍しくWAを出さずにコンテストを終えることができました。D問題は解けなかったので，実質コンテスト参加時間は30分でした笑 ちなみにレーティングは今回で+62でした。着々と上がっている感じが結構うれしいし，モチベーションになっているような気がします。 解法など 今回の記事も，自分がどうやって解いたかを残しておきます。 A問題 以下は問題文です。 今回のA問題は最近の中では簡単なほうかな？っていうのが率直な意見です。この問題はforなどのループ構造を書ければ回答できそうですね。具体的には，受け取った数字分のループを回して，その中で変数をデクリメントしながら出力すればオーケーですね。以下は私の提出です。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); for(int i = n; i \u0026gt;= 0; i--) { printf(\u0026#34;%i\\n\u0026#34;, i); } return 0; } c言語ではfor文でインデックス変数が利用できるので，比較的簡単に記述することができます。 B問題 まずは問題文です。 文字列の照合問題ですね。正直この手の問題は結構苦手とするところですが，，，今回は何とか解けました。 方針としては，まず与えられた文字列をscanf関数で文字列型として読み取って，ASCIIコードで照合していきました。具体的に言うと，まず「先頭の文字が一文字の英大文字」という条件は，受け取った文字列が入っている配列の一つ目の要素が，「数値として」65以上かつ90以下という条件により判別することができます。このようなことを繰り返して判別していきます。以下はACが通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[11] = {0}; //全部ゼロで初期化する scanf(\u0026#34;%s\u0026#34;, s); if(!(s[0] \u0026gt;= 65 \u0026amp;\u0026amp; 90 \u0026gt;= s[0])) { // 頭大文字チェック printf(\u0026#34;No\\n\u0026#34;); return 0; } if(s[1] == 48) { printf(\u0026#34;No\\n\u0026#34;); return 0; } for(int i = 1; 7 \u0026lt; i; i++) { if(!(s[i] \u0026gt;= 48 \u0026amp;\u0026amp; 57 \u0026gt;= s[i])) { printf(\u0026#34;No\\n\u0026#34;); return 0; } } if(!(s[7] \u0026gt;= 65 \u0026amp;\u0026amp; 90 \u0026gt;= s[7])) { // ラスト大文字チェック printf(\u0026#34;No\\n\u0026#34;); return 0; } if(s[8] != 0) { // きっちり8文字かチェック printf(\u0026#34;No\\n\u0026#34;); return 0; } printf(\u0026#34;Yes\\n\u0026#34;); return 0; } コメントで「きっちり8文字かチェック」と書かれている部分について少しだけ補足します。今回の問題の制約では，ASCIIコードにおいて十進数表示で0になるような文字が入力されることがないので，この条件により確実に仕分けることができます。しかし，一般的な場合に関してはそうとは限らないので，注意が必要です。(今回0という条件にしたのはたまたま配列を0で初期化しようと思ったからというだけで特に深い理由はありません。) C言語でこういう文字列処理をするのはかなり面倒くさいですね。。。もっといい方法があるのかもしれませんが。 C問題 以下問題文です。 循環するプレイリストにおいて，与えられた時間が経過したときに何曲目が流れているかを考える問題ですね。 この問題を考える上でまず大切なのが，プレイリストの総再生時間よりも再生時間が大きくなるようなパターンが存在することです。この時，プレイリストの総再生時間分だけ経過したら一番最初の状態に戻るので，再生時間を総再生時間で割った余りを考えることで問題を簡単にすることができます。(なお，総再生時間が再生時間よりも大きいような場合には，再生時間がそのまま余りとなります。したがって，とりあえず剰余を考えるという方法でも大丈夫です。) この後，その余りを，一つ一つの楽曲再生時間の和が超えたタイミングが答えの曲の位置になります。これはほぼ自明ですね。 以下は提出コードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; long long int t; long long int sum = 0; // 全曲の総再生時間 scanf(\u0026#34;%i %lli\u0026#34;, \u0026amp;n, \u0026amp;t); int a[n]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;a[i]); sum = sum + a[i]; } if(t \u0026gt; sum) { t = t % sum; } sum = 0; //sumリセット int num; for(int i = 0; ;i++) { sum = sum + a[i]; if(sum \u0026gt; t) { num = i + 1; sum = sum - a[i]; break; } } printf(\u0026#34;%i %lli\\n\u0026#34;, num, t - sum); return 0; } やっていることはほとんど上で書いたことそのままです。ただし，for文のインデックス変数が(というより配列の要素が)0からスタートする一方，曲の順番は1からスタートするので気を付けましょう。 D問題 D問題は，解けなかったよ。。。(n回目) とりあえず問題の紹介だけはします。以下問題文です。 つまりは，Aの元から任意にK個を選んできて，それらを足したものの集合を考えるときに，与えたDの倍数であるようなもので最大のものを探すというものです。 この問題の恐ろしいところは，Aの元から任意にK個を選ぶ組み合わせの数が非常に大きくなることがあるという点です。この問題において最悪ケースを考えると， Aの要素が100個 Kが50(詳細は省きます) となるときです。この時の組み合わせの数はなんと100,891,344,545,564,193,334,812,497,256になります。どう考えても愚直にやるのは無理です。 しかし現在の私ではこの問題に対する有効な解法はわかりませんでした。なのでC問題を解き終わってからコンテスト終了まで机の前でｳﾝｳﾝうなってました。う～ん，アホ！w なお，コンテスト終了後に公開される解説によると，この問題は動的計画法なるもので解くことができるらしいです。知らんが？ というわけでボロボロでした。精進します。 終わりに 今回の参加記は以上です。だんだんレートが上がっているとは言えども，専門的なアルゴリズムの知識なんてないのでこういう問題にぼこぼこにされる日々です。しかし，思ってる以上に競プロを通じて数学などに触れることは新鮮で楽しいと思っています。今のところは。ということでこれからも頑張っていけたらなと思います。 DPなんかねえよ(K重forループをおもむろに書き始める) というわけで，ここまで読んでいただきありがとうございました。また次の記事でお会いしましょう。"
  },
  {
    url: "/post/abc280/",
    title: "ABC280に参加してきました！",
    date: "2022-12-04T00:00:00Z",
    body: "ABC280に参加してきました！ 今回もABCに参加してきました。 どうもこんにちは。大学の課題が結構やばいことになっているInです。今回もABCに参加してきましたので，その参加記事になっております。別に競技プログラミングのためだけにこのブログ(?)を開設したわけじゃないのに，現状では競技プログラミングの記事しかないことを憂いております。(やる気やらなんやらの問題で筆が進まないんですよね) 閑話休題。それでは今週の参加感想記事です。 結果発表のコーナー 今週の提出結果です。 なんと今回は運よくCまで解くことができました。(ドンドンパフパフ) 今回の成績は，4888/8672で，パフォーマンス375でした。そこそこよろしいんじゃないでしょうか？(そこ，灰パフォでイキるなとか言わない！)レーティング変動は今回プラス34で現在104です。入茶が楽しみです。 解法やらなんやらの振り返り 今週もいつものごとく問題をどのように解いたのかを忘備録として記録しておきます。まずはA問題です。 *Oh...*今週のA問題はなんだか見た目がいかついですね。正直A問題でつまずいて死ぬパターンかと思いました。 さて，見た目はいかついですが，この問題はよく見てみるとそんなに難しいことを言っていないことが分かります。 要するに#.##...#←こんな感じの文字列(文字列一つにつきW個の文字)がH回入力されるので，#の数を数えてくださいねということです。先週の文字列祭りに比べたらだいぶんましですね。方針としては，HもWも少ないのが制約からわかるので，シンプルに文字列として標準入力から読み取って，一文字づつ見ていく感じで処理しました。以下コードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int h, w; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;h, \u0026amp;w); char word[11]; int count = 0; for(int i = 0; h \u0026gt; i; i++) { scanf(\u0026#34;%s\u0026#34;, word); for(int j = 0; w \u0026gt; j; j++) { if(word[j] == \u0026#39;#\u0026#39;) { count++; } else if(word[j] == \u0026#39;0\u0026#39;) { break; } } } printf(\u0026#34;%i\\n\u0026#34;, count); return 0; } そこそこシンプルに書くことができました。ある程度標準入出力の使い方には慣れてきたんじゃないかなと思います。 さて，次はB問題です。以下問題文です。 記号と数字がわちゃわちゃしていて結構ウッってなる人多いかもしれません。僕もそうでした。 しかし，一回紙に書くとかなりシンプルに整理されることが分かります。 実際，Sk+1=Sk+Ak+1が成立しますから，逆に見るとAk=Sk-Sk-1(ただしS0=0) という関係式が成り立つことが分かります。したがって，二つのSから一つのAを錬成しながら出力していく方針で解けます。いやー数学って偉大ですね。以下通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); int s1, s2; s1 = 0; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;s2); printf(\u0026#34;%i \u0026#34;, s2 - s1); s1 = s2; } return 0; } なんとA問題よりも短くなってしまいました。個人的には実装含めての難易度だと今回Bのほうが簡単だと思いました。 あと余談なんですが，誰が読んでも誤解を与えないという点では競プロのような問題文の書き方は適切だとは思いますが，記号を大量に使用するのは可読性っていう点だとどうなのかなってちょっと思ったりします。まあ例がついているので支障はそんなにないですが。 次はC問題です。以下問題文です。 英小文字のみからなる文字列を比較する問題のようです。文字列TはSにもう一つだけ文字を追加して作られているもののようですね。今回のC問題はなんかやたらとシンプルで助かりました。 方針としては，まず二つの配列を用意して文字列として読み取り，次にSとTを頭から見ていって，初めて一致しなくなった場所が答えという感じで行きました。配列としてみるときはインデックスが一つずれるので注意です。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[500001]; char t[500002]; scanf(\u0026#34;%s\u0026#34;, s); scanf(\u0026#34;%s\u0026#34;, t); for(int i = 0; ; i++) { if(s[i] != t[i]) { printf(\u0026#34;%i\\n\u0026#34;, i + 1); break; } } return 0; } こんな感じで実装しました。手元のマシンだとstaticではない配列の宣言で要素500000とかあまりやらないので結構ジャッジサーバーは融通効くなって印象です。 ちなみに余談ですが，この問題多くの人が引っ掛かったポイントがあったようで，(自分も1WA食らいました。)それは，「Sの最後に付け足すパターン」の見落としです。このミスは初心者から上位勢までみんな食らっててちょっと面白かったです。おそらく多くの人が引っ掛かった理由は，普通は\\0(終端文字)が出現したら読み取りのループをブレークするのですが，この問題に関しては必ずTがSから構成される文字列であることが保証されているので，そんな気遣いをしなくてもOKだったっていう感じだと思われます。 D問題は，，解けなかったよ 今回Cの提出まで結構スムーズに行けたので，「お！ワンチャンあるか？」と思っていましたが，D問題結局解けませんでした。。。 Dの問題文は以下の通りでした。 この問題，見た目は結構シンプルなんですが，かなり厄介で手を動かすだけだと無理でした。 というのも，直接階乗を計算するのが無理なんですよね。 Cでの整数型の最大値unsigned long long intの最大が，18446744073709551615となっており，20桁まで入るんですが，実は20!の時点で18桁の整数になります。 階乗はおそロシア。なので，ほかの部分に注目して行かなくてはいけないんですけど，効率的な方法を見つけられなかったのと，実装力の低さのせいでスパゲッティコードを錬成してタイムアップしました。ただ，数学的に解を見つけられそうなので解けたら別記事として投稿したいなとは思っています。 終わりに ABCを始めてから3週間ほどたちますが，少しは成長したのかなと思います。課題で忙しい時もありますが，ドンドンAtCoder Beginer's Selectionや競プロ典型90問などにも取り組んでいけたらいいなと思います。(アルゴ式も)目指せ茶コーダー！ 余談ですが，このサイトに投稿されている記事は，markdownからの変換とかではなくすべてhtmlを手打ちしているので，手書きhtmlかなり慣れてきたような気もします。いいことなのかは知らん。 今回も読んでいただきありがとうございました。次の記事で会いましょう。 P.S. UEC Advent Calendar1とUEC Advent Calendar2が開催中ですので，興味があったら皆さんも読みましょう。(私も24日に寄稿(?)予定です。)"
  },
  {
    url: "/post/abc279/",
    title: "ABC279参加してきた！",
    date: "2022-11-27T00:00:00Z",
    body: "ABC279参加してきた！ はじめに 今回ABC279に参加してきましたので，その記録です。 今回の成績 まずは今回の成績からです。以下画像です。 AとBしか，解けませんでした！！！！(キース団長並感) いや，文字列扱う問題多くないですか？？？？？？私は文字列を操作する練習を全然してなかったのでB問題で死ぬほど苦労しました... 今回はあまり語るようなことがないので，サクッと解法紹介と今回の反省のパートに行きたいと思います。 解法 (注意: 筆者はc言語使ってます。)まずはA問題からです。以下問題文です。 これは文字列を扱う練習みたいな問題ですね。「下に尖った部分」というのはvは1箇所，wは2箇所なので，文字列を最初から見ていって，「vの個数」× 1と「wの個数」× 2を足したものをprintf関数で標準出力で出したらオッケーですね。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char a[100]; scanf(\u0026#34;%s\u0026#34;, a); int score = 0; int i = 0; while(a[i] != \u0026#39;\\0\u0026#39;) { if(a[i] == \u0026#39;v\u0026#39;) { score = score + 1; } else if(a[i] == \u0026#39;w\u0026#39;) { score = score + 2; } i++; } printf(\u0026#34;%i\\n\u0026#34;, score); return 0; } 関係ない話ですが，問題の名前が「wwwvvvvvv」だったり問題文に平気で「尖っている部分」とか書いてあるのが地味にじわじわ来る問題ですね。 お次はB問題です。以下問題です。 この問題は全探索で解きました。簡単に流れを説明すると，まず最初に文字列Tの最初の文字を文字列Sの先頭から探します。見つかったら一文字ずつ後続も一致しているか確認して，もしTが'\\0'(終端文字)になるまでずっと一致していたら，Sは条件を満たしていたということが分かるので，適当にフラグを立ててループを抜けます。ここで後続に一致しないものが存在した場合は，また先頭文字が一致するか順に確認していきます。このサイクルをSが終端文字になるまで続けてもフラグがたたなかった場合は，条件を満たさないということが分かります。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char S[101]; char T[101]; //比較する方 scanf(\u0026#34;%s\u0026#34;, S); scanf(\u0026#34;%s\u0026#34;, T); int flag = 0; for(int i = 0; S[i] != \u0026#39;\\0\u0026#39;; i++) { if(T[0] == S[i]) { int k = i; int j = 0; for(; S[k] == T[j] \u0026amp;\u0026amp; T[j] != \u0026#39;\\0\u0026#39;;) { k++; j++; } if(T[j] == \u0026#39;\\0\u0026#39;) { flag = 1; } } } if(flag == 1) { printf(\u0026#34;Yes\\n\u0026#34;); } else { printf(\u0026#34;No\\n\u0026#34;); } return 0; } *この問題を通すのに本当に苦労しました。。。*実はこの問題を通すだけで今回1時間8分，WAを6回も出したことで私の順位がボロボロになりました。泣きそうです。 この問題では文字列を扱うときは必然と'\\0'の検出が必要になるのですが，それを「whileの条件式で簡単にかけるやろw」とか思ってたらマジで痛い目見ました。とにかくループ用の変数がわちゃわちゃしてしまって，ループを抜けるときの条件式がぐちゃぐちゃになってしまったのが痛すぎました。。。泣きそうです(2回目) もうwhileなんて使わない(知らんけど) ちなみに，この問題でつまずいた理由はおそらく配列の余った要素がすべて0であることを見逃していたことだと思います。アホですか？ ラスト，ACは取れなかったもののC問題を紹介しておきます。以下問題です。 この問題は正直知識不足でした。せっかくですので私の行おうとした解法を説明します。 与えられた図形SとTが「列の並べ替え」によって一致すればよいということですので，受け取ったデータをリアルタイムに処理することはできなさそうです。したがって，いったん配列に保持することにしました。この問題では行番号と列番号の情報が重要ですので，二次元配列を用意して代入しました。そして，「並べ替え」によって同じものが作れるということは，「Sのある列」を持ってくると，常に必ず一つ以上「Tのある列」が一致しているという言い換えが可能です。これなら全探索により実装可能だと判断したので，この方針で行きました。実はこの探索方法，ほとんどB問題と同じです。一番ACに近かったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int H, W; //Hは行数，Wは列数 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;H, \u0026amp;W); char buffer; int flag = 0; int delflag = 0; int ans = 0; char S[H][W]; char T[H][W]; for(int i = 0; H \u0026gt; i; i++) { for(int j = 0; W \u0026gt; j; j++) { scanf(\u0026#34; %c\u0026#34;, \u0026amp;buffer); S[i][j] = buffer; } } for(int i = 0; H \u0026gt; i; i++) { for(int j = 0; W \u0026gt; j; j++) { scanf(\u0026#34; %c\u0026#34;, \u0026amp;buffer); T[i][j] = buffer; } } for(int i = 0; W \u0026gt; i; i++) { for(int j = 0; W \u0026gt; j; j++) { if(S[0][i] == T[0][j]) { for(int k = 0; H \u0026gt; k; k++) { if(S[k][i] != T[k][j]) { flag = 1; break; } } if(flag != 1) { for(int l = 0; H \u0026gt; l; l++) { T[l][j] = 0; } delflag = 1; break; } flag = 0; } } if(delflag != 1) { printf(\u0026#34;No\\n\u0026#34;); return 0; } } for(int i = 0; W \u0026gt; i; i++) { if(T[0][i] != 0) { ans = 1; break; } } if(ans == 1) { printf(\u0026#34;No\\n\u0026#34;); } else { printf(\u0026#34;Yes\\n\u0026#34;); } return 0; } このコードで最終的にTLEが2ケースでした。考え方自体は正解を出せるコードみたいです。 公式解説では，私のとった手順と似たようなものでしたが，最後の同じ列が存在するかの判定を「文字列のソート」にて実現していました。私は文字列の扱いに関してほとんど何もわかっていなかったので，選択肢にすらあがらなかったです。次頑張ります。 余談ですが，終了後に私のコードを見た並走者が，あまりのforループの深さにびっくりしていました。こんな頭の悪い全探索しか書けないの正直ね。。 *True Programer* only use for statement and if statement.(逆張り) 終わりに 正直にいうと，今回の結果は非常に悔しかったです。もっとほかの問題に時間をかけられると思っていたし，レーティングもあまり気にしていないとはいえ重要な指標の一つでしょう。「この悔しさをバネに～」みたいな文言めちゃくちゃ嫌いなんですが，今はそんな気分です。来週のABCに向けてできるだけ準備したいと思います。 今回解けなかったC問題はもう少し取り組んでみようと思います。もし解けたら追記します。 長文読んでいただきありがとうございました。"
  },
  {
    url: "/post/abc278/",
    title: "ABC278に参加してみた！",
    date: "2022-11-19T00:00:00Z",
    body: "ABC278に参加してみた！ こんにちは。Inです。この度初めて競技プログラミング，もといAtCoderに参加してみたので，その記録もかねてこの記事に残しておきます。注意: 筆者はプログラミング初心者なので競プロ的には特に参考になる点はありません。 競プロって何？ 競技プログラミングでは、参加者全員に同一の課題が出題され、より早く与えられた要求を満足するプログラムを正確に記述することを競う。コンピュータサイエンスや数学の知識を必要とする問題が多く、新卒学生の採用活動などに使われることもある[7][8]。多くのコンテストでオンラインジャッジが採用されている。また、競技プログラミングに参加する人を「競技プログラマ」または「競プロer」と呼ぶことがある。近年、プログラミング教育において、競争型学習が注目されている。特に、一定の時間内にプログラミング問題を解く競技系のコンテストは、授業中の演習形式として期待される。しかしこれらは高度であり入門的な授業にコンテストを取り入れるには、初心者向けに視野を広げる適応を考える必要がある。 Wikipedia, 競技プログラミング だそうです。(適当)まぁ要するに与えられた問題をプログラムで解くんですね。私が参加したのはAtCoderというサイトで行われているものです。正直私はあまり詳しくないです。 初めて参加しての感想 今回あまり下調べせずに適当に参加してみたんですけど，はっきり言ってボロボロでした。。。でも楽しかったです。まず結果から載せます。以下が今回の提出状況でした。 A問題で躓きすぎだろ！！！！！ はい。ということで，AとBだけ通すことができまして，得点は3200点中200点取れました。こんなにAがボロボロだったのにも少し訳がありまして，今回私は何の下調べもせずに参加してしまったせいで，標準入力を受け取る方法をずっと模索してたんですよね。前半の何回かのWAはそれにやられました。ちなみに，B問題はコンテスト終了8秒前に提出完了したので，ほんとに奇跡的に通すことができたって感じでした。 自分なりの解法(覚書) AとBしか通せない雑魚が何をいっちょ前にと思うかもしれませんが，せっかく考えたプログラムですので，どんな感じでやったのかを残しておこうと思います。使用言語はcで，コンパイラはClang10.0.0を使用しました。 まずはA問題です。以下が問題文です。 この問題は，配列を用意して数列を入れていき，操作の回数番目のところから出力して，0で水増しするような感じで解きました。以下コードです。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int input = 0; int length = 0; int operation_times = 0; char sequence[100]; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;length, \u0026amp;operation_times); for(int i = 0; length \u0026gt; i; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); sequence[i] = input; } for(int i = operation_times; length \u0026gt; i; i++){ printf(\u0026#34;%d \u0026#34;, sequence[i]); } if (operation_times \u0026lt; length){ for(int i = 0; operation_times \u0026gt; i; i++){ printf(\u0026#34;0 \u0026#34;); } } else { for(int i = 0; length \u0026gt; i; i++){ printf(\u0026#34;0 \u0026#34;); } } return 0; } この問題で，最初操作の回数が数列の長さを上回るパターンを見落としていて見事にWAを食らいました。あと，前にも書きましたが標準入力の取り扱いが分からないせいで1時間くらいかかりました。 次B問題です。 この問題は，きちんと考えるのが大変だったので取り合えず全探索をしようという方針で行きました。「見間違えやすい時刻」を評価するために，〇〇時△△分を十の位，一の位に分解してから初めて「時間として許容できる組み合わせ」に到達したらループを抜けるようにしました。なお，日付をまたいでも(24時以降)いいように，24で割った余りを利用しています。以下コードです。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void){ int hour = 0; int min = 0; int hour_tens = 0; int hour_ones = 0; int min_tens = 0; int min_ones = 0; int hour_remain = 0; int min_remain = 0; int flag = 0; int breakflag = 0; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;hour, \u0026amp;min); for(int i = hour; 48 \u0026gt; i; i++){ hour_remain = i % 24; hour_tens = hour_remain / 10; hour_ones = hour_remain % 10; if(flag == 1){ min = 0; } for(int j = min; 60 \u0026gt; j; j++){ min_tens = j / 10; min_ones = j % 10; if(24 \u0026gt; hour_tens * 10 + min_tens \u0026amp;\u0026amp; 60 \u0026gt; hour_ones * 10 + min_ones){ printf(\u0026#34;%d %d\u0026#34;, hour_tens * 10 + hour_ones, min_tens * 10 + min_ones); breakflag = 1; break; } } flag = 1; if(breakflag == 1){ break; } } return 0; } 絶対こんなに変数いらなかっただろ ということでこれでAC通りました。もっと数学的に考察したら簡単に解けたかも？(面倒くさいからやらない) 終わりに 初めてのコンテスト参加でしたが，全体的に見て楽しかったです。これからもコンテストは出ていこうかなと思っています。やる気のある時にまたこうやって記事も書いてみたいなと思います。それでは読んでいただき，ありがとうございました。この記事に関して何かございましたら私のTwitterまでどうぞ。"
  },
  {
    url: "/about/",
    title: "About",
    date: "0001-01-01T00:00:00Z",
    body: "About About Me 電気通信大学に在学中。 最近は競技プログラミングをよくやっています。 ハンドルネームはInかInTheBloomを使っていることが多いです。 サイトの方針 常識的に問題ないと思う範囲で書きたいことを書こうかなと思っています。 google analyticsなどのアクセス解析は特に利用していません。 私が作ったコンテンツに関しては自由に利用してもらって大丈夫です。(そんなやついるのか？) 連絡先 Twitter(X) gmail (nato.rider.smm2 [at] gmail.com) など 最後に 当サイトはgithub pages、hugo、simplogのおかげで作成できました。ありがとう！"
  },
];

function search(query) {
  const result = searchData(query);
  const html = createHtml(result);
  showResult(html);
  showResultCount(result.length, data.length);
}

function searchData(query) {
  
  
  const result = [];

  query = query.trim();
  if (query.length < 1) {
    return result;
  }
  const re = new RegExp(query, 'i');
  for (let i = 0; i < data.length; ++i) {
    const pos = data[i].body.search(re);
    if (pos != -1) {
      result.push([i, pos, pos + query.length]);
    }
  }
  return result;
}

function createHtml(result) {
  const htmls = [];
  for (let i = 0; i < result.length; ++i) {
    const dataIndex = result[i][0];
    const startPos = result[i][1];
    const endPos = result[i][2];
    const url = data[dataIndex].url;
    const title = data[dataIndex].title;
    const body = data[dataIndex].body;
    htmls.push(createEntry(url, title, body, startPos, endPos));
  }
  return htmls.join('');
}

function createEntry(url, title, body, startPos, endPos) {
  return '<div class="item">' +
      '<a class="item_title" href="' + url + '">' + title + '</a>' +
      '<div class="item_excerpt">' + excerpt(body, startPos, endPos) + '</div>' +
      '</div>';
}

function excerpt(body, startPos, endPos) {
  return [
    body.substring(startPos - 30, startPos),
    '<b>', body.substring(startPos, endPos), '</b>',
    body.substring(endPos, endPos + 200)
  ].join('');
}

function showResult(html) {
  const el = document.getElementById('result');
  el.innerHTML = html;
}

function showResultCount(count, total) {
  const el = document.getElementById('resultCount');
  el.innerHTML = '<b>' + count + '</b> 件見つかりました（' + total + '件中）';
}
</script>

</body>







<hr class="block-separater">










<div class="content-footer-item neighbor">
	
	
</div>














<script src="/js/single.js"></script>





	</div><div id="content-footer" class="sub">
  
  <div class="credit">
    Power by <a href="https://gohugo.io">Hugo</a> /
    Theme <a href="https://github.com/michimani/simplog/">simplog</a> by <a href="https://github.com/michimani/">michimani</a>
  </div>
</div></body>

</html>