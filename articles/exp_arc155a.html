<!DOCTYPE html>
<html lang="ja" prefix="og: http://ogp.me/ns#">
	<head>
		<title>精説ARC155A - InTheDayDream</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=devicewidth, initial-scale=1">
		<base href="../">
		<script> let base = ''; let tmp = [...window.location.href]; let i = 0; let str = 'articles'; for (; ; i++) { let flag = 0; for (let j = 0; str.length > j; j++) { if (str[j] != tmp[i + j]) { flag = 1; break; } } if (flag == 0) { break; } } let roop = tmp.length - i; for (let j = 0; roop > j; j++) { tmp.pop(); } base = tmp.join(''); let a = document.getElementsByTagName("base"); a[0].setAttribute('href', base); </script>
		<link rel="stylesheet" href="default.css">
		<script src="headliner.js"></script>
		<script src="highlight.js"></script>
		<link rel="icon" href="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1673863461/pictures/favicon.png.png">
		<link rel="apple-touch-icon" href="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1673863461/pictures/favicon.png.png">
		<meta name="description" content="ARC155A問題の自分なりの解法を解説します。">

		<!-- 以下SNSのカード設定 -->
		<meta property="og:url" content="https://inthebloom.github.io/articles/exp_arc155a.html"> <!-- ページのURL -->
		<meta property="og:title" content="精説ARC155A - InTheDayDream"> <!-- ページタイトル -->
		<meta property="og:description" content="ARC155A問題の自分なりの解法を解説します。"> <!-- ページの説明 -->
		<meta property="og:type" content="article"> <!-- コンテンツタイプ(Website or article) -->
		<meta property="og:image" content="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1675258394/pictures/exp_arc155a.html/ogp_xkk25g.png"> <!-- 表示される画像(絶対パス) -->
		<!-- Twitter用の設定 -->
		<meta name="twitter:card" content="summary">
		<meta name="twitter:site" content="@UU9782wsEdANDhp">
	</head>

	<body>
		<header>
			<a href="home.html"><img src="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1675069885/pictures/sitelogo_p1inzg.png" class="sitelogo" alt="sitelogo"></a>
		</header>

		<div class="outer">
			<aside>
				<div id="table-of-content">
				</div>
			</aside>
			<div class="main">
				<nav>
					<ol class="crumbs">
						<li class="crumb"><a href="home.html">Home</a></li>
						<li class="crumb">精説ARC155A</li>
					</ol>
				</nav>

				<h1>精説ARC155A</h1>
				<div class="date">
					<p>書いた日: 2023/2/1</p>
					<p>最終更新日: N/A</p>
				</div>

				<h2>はじめに</h2>
					<p>先日1月29日に<a href="https://atcoder.jp/contests/arc155">AtCoder Regular Contest 155</a>がありました。ARCのA問題は，ARCがA~Fの6問体制になったARC104から現在に至るまでdifficultyの最大値は緑でした。しかし，今回のA問題は<em>水色</em>でした。</p>
					<figure>
						<img style="max-height: 300px;" src="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1675259104/pictures/exp_arc155a.html/problems_dziwbv.png" alt="ARC155aのdiff">
						<figcaption><a href="https://kenkoooo.com/atcoder/#/table/">AtCoder Problems</a>より</figcaption>
					</figure>
					<p>現在レート400+程度の私にとって，ARCにおいては一問解くだけでパフォーマンス700+くらいが望めるので非常に「コスパのいい」大会だと思っていたのですが，今回のA問題が思いのほか難しく，一問も解くことができませんでした。</p>
					<p>コンテスト後にもう少し粘ってみたら解けたので，(公式解説が思いのほかよくわからないこともあり)解法を残しておくことにします。</p>
				<h2>問題の概要</h2>
					<p>問題文は以下の通りです。</p>
					<img src="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1675259673/pictures/exp_arc155a.html/A_kwyxtn.png" alt="問題文">
					<p>要約すると，「与えられた文字列をSとする。この時，Sの前にくっつけてもSの後ろにくっつけても回文になるような長さKの文字列が存在するか？」というものになります。</p>
					<img src="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1675260101/pictures/exp_arc155a.html/sample_vntino.png" alt="サンプル">
					<p>上の画像はビジュアル化したものになります。</p>
				<h2>方針</h2>
					<p>まず制約を見てみましょう。特筆すべき点は，Kがかなり大きくなる可能性があるということでしょうか。また，一つの入力に含まれるテストケースについて，Nの総和が2×10<sup>5</sup>以下というのも重要そうです。一つの入力に与えられるテストケースの数が非常に多いからです。</p>
					<p>さて，この問題を解くためにどうすればよいのでしょうか？数多くの方針があると思いますが，私はこういう時は<em>最もシンプルな方針</em>を試してみます。この問題に対して最もシンプルな方針は何でしょうか？それは与えられた条件からできるだけ実際にK文字のS'を構成するというものです。</p>
					<p>幸い文字列Sは与えられるので，この考え方は試すことができそうです。</p>
				<h2>シンプルに考えてみる</h2>
					<p>さて，「実際に構成する」といったものの，どのようにすればいいのでしょうか？まずは以下の図をご覧ください。</p>
					<img src="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1675261292/pictures/exp_arc155a.html/kaibun_waaxxn.png" alt="回文の例">
					<p>回文の定義を考えれば，「一番左にある文字」は「一番右にある文字」と同じで，それがずっと続くわけです。つまり，「左から〇番目にある文字」は「右から〇番目にある文字」と同じわけです。</p>
					<p>すなわち，問題の題意を満たすような文字列S'が存在するなら，それは与えられた文字列Sの<em>逆順の一部分</em>に他ならないわけです。</p>
					<p>さて，ここで一つ疑問がわきます。もし「与えられた文字列」が「構成しようとしている文字列」よりも長かった場合，今言った方法で構成しきることができます。しかし，もしそうでないなら？すなわち，<em>構成しようとしている文字列が与えられた文字列よりも長い時</em>に，残りの部分がどうなるのかを考える必要が出てきそうです。</p>
					<h3>K &lt; N の場合</h3>
						<p>まずはややこしいパターンを考える前に，比較的簡単なパターンを処理してしまいましょう。</p>
						<p>この時、前述のとおり各ケース実際にk文字分すべてを構成することができます。したがって、確認する必要があるのはS -&gt; S'の順番で考えた時のS'と、S' -&gt; Sの順番で考えた時のS'が一致するかどうかです。</p>
						<img src="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1675743707/pictures/exp_arc155a.html/condition1_ygzo67.png" alt="n > kの時の条件">
						<p>上にある画像の通り、回文となるようなS'が存在することを仮定すると、<em>S'はどちらのケースでも同一であるという仮定</em>から、</p>
						<ol>
							<li>文字列Sの先頭K文字と末尾K文字が一致する</li>
							<li>文字列Sの先頭N-K文字と、末尾のN-K文字が回文を成す</li>
						</ol>
						<p>という<em>Sが要請される条件</em>が見えてきます。このチェックにかかる計算量はO(N)になるので、制約的にも問題なさそうです。</p>
					<h3>K = N の場合</h3>
						<p>場合分けは漏らさずに考えることが必要です。イコールも忘れずにチェックします。先ほどのケースにこれを含めなかった理由は、場合分けはできるだけ細切れのほうが一ケース当たりに考えることが減るからです。</p>
						<p>この時も同様に考えてみます。</p>
						<ol>
							<li>S S'が回文: S'はSの逆順そのもの</li>
							<li>S' Sが回文: S'はSの逆順そのもの</li>
						</ol>
						<p>というわけで、Sに対してまったく条件が課されないことがわかります。単にS'をSの逆順として定めてしまえば任意のSに対して条件を満たすS'となります。この判定はO(1)なので当然オーケーです。</p>
						<p>もしよくわからなかったら具体的に一ケース挙げて考えてみるといいと思います。(ex. S = "12345")</p>
				<h2>K > N 以降</h2>
					<h3>小休憩</h3>
						<p>ここから少し複雑になります。そこで、今まで何のために場合分けをしていたのかを再確認しておきます。</p>
						<p>ここまで、「最もシンプルな手」すなわち、「与えられた条件から実際にS'を構成してみて、そこから考える」という手段をとってきました。</p>
						<p>ここで問題になるのは、「Kが非常に大きいケースにおいては、S'を構成するのに少し手間がかかりそう」という事実です。なぜKが小さいときにS'を構成しやすいかは<a href="articles/exp_arc155a.html#head3">ここ</a>を見返してみてください。</p>
						<p>よく見直してみると、K &gt; Nのケースにもまだ比較的シンプルにS'を構成できるものが残っています。まずはそれを片づけましょう。</p>
					<h3>2N > K > N の場合</h3>
						<p>この時も、Sが与えられたらすぐにS'を構成することが可能です。なぜなら、以下の画像の通り、前からN文字、後ろからN文字が確定するのでS'が(存在するなら)一つに定まるからです。</p>
						<img src="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1675746014/pictures/exp_arc155a.html/condition2_texl0s.png" alt="2N > K > Nの時">
						<p>一見するとK &gt; Nの場合と変わらないように見えますが、このケースにおいて回文の判定をするのはS'の中になるという違いがあります。従って、直接Sを評価して答えを出すことができるわけではなく、「S'が存在するなら、Sから構成したこの文字列は-な条件を満たす。」という説明付けになっています。最後はプログラムに落とし込まないといけないわけなので、やはりできるだけ分割は細かくしておくべきだとと思います。</p>
						<p>この時、S'の満たすべき条件は以下の2つになります。</p>
						<ol>
							<li>S'の中心付近の(上図にも示されている)「重なり合う場所」で、互いに打ち消しあわない</li>
							<li>S'の先頭K-N文字と末尾K-N文字が回文を成す</li>
						</ol>
						<p>前述のとおり、これは実際にS'を構成して確かめる必要があります。このチェックにはO(N+K)が必要ですが、十分間に合います。(計算量の見積もりあってるか自信ないです)</p>
					<h3>K = 2N の場合</h3>
						<p>今回も一応イコールを分けておきました。この時、S'を構成しても「互いに重なり合う場所」が発生しません。なので、条件は非常にシンプルになり、「Sが回文」が構成可能になる必要十分条件となります。</p>
						<p>これも上の議論を考えれば直ちに従うので、もしわからなければ具体例を考えてみるといいかもしれません。(ex. S = "1234321", K = 14)</p>
						<p>また、このケースは2N &gt; Kのケースと全く同じ判定法を使うことができます。したがって、実際に実装するときは統合してもよいかもしれません。</p>
					<h3>K > 2N の場合</h3>
						<p>まず、これまでの議論から、<em>S'が存在すると仮定すると</em>次のことが言えます。「S'は先頭と末尾のN文字はSの逆順そのものである」「S'の先頭と末尾のK-N文字は回文を成す」</p>
						<p>この情報から残りの部分がどうなる必要があるか考えます。</p>
						<img src="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1675749029/pictures/exp_arc155a.html/condition3_o0adlx.png" alt="K > 2Nの場合">
						<p>上に示した画像の通り、これらの情報からS'の不明だった場所が少しだけ確定させることができます。これと全く同じ議論をS' -&gt; Sのパターンでも考えることによって、S'はSの逆順 &gt; Sの正順 &gt; Sの逆順 &gt; ...という風に、2NずつSの逆順か正順のどちらかに<em>挟まれている</em>ことがわかります。</p>
						<p>これは、S'の残りの部分が2N未満になるまでまったく同様に続けることができます。結果的に、以下の図のようになります。</p>
						<img src="https://res.cloudinary.com/dqoqdn2sk/image/upload/v1675749819/pictures/exp_arc155a.html/condition4_l5mtio.png" alt="S'の最終状態">
						<p>結局、この「あまり」の部分の周りについてのみ考えればよいことになります。
			</div>
		</div>
			<footer>
				<p class="copyright"><small>&copy; 2023 InTheDayDream</small></p>
			</footer>
	</body>
</html>
