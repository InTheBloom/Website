---
title: "BSTより高速なデータ構造、Y-Fast Trie [UEC Advent Calendar 2024] 12日目"
# description: 

date: 2024-12-12
# lastmod: yyyy-mm-dd
# hidedate: true

# ogimage: https://hoge/fuga/piyo.img

tags:
  - アルゴリズム
  - データ構造
  - UEC Advent Calendar
archives:
  - 2024
  - 2024-12
# sample
# - yyyy
# - yyyy-mm

draft: true
math: true
# toc: false
# build: {list: never}
---

## まえがき
こんにちは、[InTheBloom](https://x.com/UU9782wsEdANDhp)です。
今年もUECアドカレの季節がやってきましたね。Twitterでカレンダーが生えたのを観測したので、これ幸いと枠をいただきました。これで3年目になります。

このエントリはUEC Advent Calendar 2024の12日目を担当します。

<iframe src="https://adventar.org/calendars/10127/embed" width="620" height="362" frameborder="0" loading="lazy"></iframe>

また、今年もUEC2が建っています。こちらもぜひどうぞ。

<iframe src="https://adventar.org/calendars/10198/embed" width="620" height="362" frameborder="0" loading="lazy"></iframe>

11日目はえぐちさんの[Proxmoxの運用Tips【自宅鯖】](https://zenn.dev/kk79it/articles/proxmox-tutorial)でした。
自宅鯖という単語、非常に魅力的に感じます。とは言いつつ、前提知識がなさすぎて大半が呪文に見えました。。勉強が必要そうです。

UEC2ははんかくさんが担当ですが、まだアップされていないみたいです。

今年も力作ぞろいです。これからのエントリも楽しみですね！

## はじめに
このエントリでは、Y-Fast Trie(ワイ-ファスト トライ)と呼ばれるデータ構造の動作原理を説明し、実際に組んだものを示します。
Y-Fast Trieの美しさ、ロマンを体感してください！

誤りの指摘は随時募集しています。指摘いただいたものは随時修正していきますので、お気軽にどうぞ。

## Y-Fast Trieの概要
Y-Fast Trieは非負整数値に対して各種操作を提供する**データ構造**です。

データ構造とは何かについて厳密に定義を与えるのは難しいです。
ここでは、大まかに、**できる操作の集合**と、**操作を実現する具体的なアルゴリズム**をひとまとめにしたものをデータ構造と呼ぶことにしましょう。

前者を**インターフェース**、後者を**内部実装**と呼ぶことにします。

性能を議論する上で、各種操作をどれくらい効率よく、どれくらい省メモリで行えるかが知りたいです。
そこで、本文書内ではインターフェースについて考えるとき、同時に各種操作の時間計算量と、全体を通しての空間計算量に言及します。

計算量というのは、かかる時間や必要な領域を定量的に評価するための概念です。
詳細は[計算量について(外部リンク)](https://noshi91.hatenablog.com/entry/2019/10/08/235335)を参照してください。

例えば、C++の`std::vector`は

- $i$番目の要素への読み書き: $O(1)$時間
- 要素を末尾へ挿入: ならし$O(1)$時間

というインターフェースを提供するデータ構造です。空間計算量は、確保した列の長さ$N$に対して、$O(N)$です。
空間計算量が$O(N)$であるとは、格納した値や補助のデータを含めて$O(N)$byteしか必要としないことを表します。

### Y-Fast Trieのインターフェース
Y-Fast Trieは、扱う整数の範囲を$\lbrack 0, 2 ^ w - 1 \rbrack$としたとき、以下のインターフェースを提供します。

| 操作                      | 内容                                | 時間計算量                    |
| ------------------------- | ----------------------------------- | ----------------------------- |
| $\mathrm{insert}(x)$      | 集合に$x$を追加する                 | $\text{expected } O(\log(w))$ |
| $\mathrm{remove}(x)$      | 集合から$x$を削除する               | $\text{expected } O(\log(w))$ |
| $\mathrm{successor}(x)$   | 集合に含まれる$x$以上最小の値を返す | $\text{expected } O(\log(w))$ |
| $\mathrm{predecessor}(x)$ | 集合に含まれる$x$以下最大の値を返す | $\text{expected } O(\log(w))$ |

$\text{expected}$という表記はその操作にかかる時間が確率変数で表現されることを表します。値はその期待値です。

このインターフェースの内部実装を[赤黒木](https://ja.wikipedia.org/wiki/%E8%B5%A4%E9%BB%92%E6%9C%A8)や[AVL木](https://ja.wikipedia.org/wiki/AVL%E6%9C%A8)といった二分探索木にした場合、各操作は全体の操作回数を$N$として、$O(\log(N))$時間になります。
一方、Y-Fast Trieは$N$に依存することなく、$O(\log(w))$時間です。

$w$は整数を表現するのに必要なビット数であり、ほとんどのケースで$w \leq 64$になります。自然な仮定の元ではY-Fast Trieは二分探索木よりも理論的に高速です。

驚くべきことに、Y-Fast Trie空間計算量は$O(N)$です。
扱う値を非負整数に絞ることにより、二分探索木と同等レベルに省メモリかつ二分探索木よりも期待値的に高速な操作を提供します。

つまり、ロマンたっぷりというわけです。

前置きはここまでです。次の章からはY-Fast Trieの動作原理を見ていきましょう。

## Binary Trieによるsuccessor query
Y-Fast Trieの仕組みを理解するためには、trie木を知る必要があります。
trieは**グラフ**の一種です。グラフとは、頂点集合$V$と頂点間を結ぶ辺集合$E$の組のことで、ものとものの**つながりかた**だけを抜き出した数学モデルです。

![graph\_sample.png](/images/uec-advent2024/graph_sample.png)

これがグラフです。この場合、頂点数が6で、辺数が8です。[Graph Editor](https://csacademy.com/app/graph_editor/)でビジュアライザを試すことができます。

プログラム上でグラフを表現するさいは、通常隣接リストを用いた表現を使います。
これは、各頂点に対応する構造体をつくり、辺を別の構造体へのポインタで表すものです。
以下に疑似コードを示します。

```d
struct vertex { // vertex: 「頂点」の意
    Data data; // 頂点番号や、それ以外の値をもたせることもある
    vertex *[] adj; // 自分から辺がある頂点へのポインタ
    // その他、辺に重みをつけることもある
}
```

うまく実装すると、$O(\vert V \vert + \vert E \vert)$の空間でグラフを表現することができます。

trieは、文字列の集合を表現するグラフです。
常に次のルールに従っています。

- 根と呼ばれる「スタート地点」をもつ。
- 各辺には文字が割り当てられる。
- 根は空文字列を表現する。他の頂点は、根からそこまでたどったときに通った辺の文字を連結した文字列を表現する。

![trie木](/images/uec-advent2024/trie_wiki.png)

wikipediaの[トライ](https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%A9%E3%82%A4_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0))からパブリックドメインの画像をお借りしました。
これがtrie木です。"A", "to", "tea", "ted", "ten", "i", "in", "inn"から構築されています。

trieに文字列を追加/削除することもできます。

追加するときは、根から出来るだけ既存の頂点を経由して文字を伸ばしていけばよいです。
削除するときは、その文字列を表現する頂点からはじめて、他の文字列に影響しない部分の頂点を削除しながら根までのぼっていけばよいです。

### Binary Trie
進数表記された数字を文字列として扱うことができます。
つまり、1234を"1234"、432795を"432795"としてみなすということです。
これにより、trieで数字を扱うことができるようになります。

trieの辺に乗せられる文字を"0"と"1"に限定することにします。
すると、各ノードは0と1の連結を表現します。
こうすることで、任意の数を
